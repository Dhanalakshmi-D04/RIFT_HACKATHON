{"inputs" : {"inputs": {"filePath": "app/services/data_processor.rb", "language": "Ruby", "fileContent": "class DataProcessor\n  def initialize\n    @processors = []\n    @results = []\n  end\n\n  def register_processors(configs)\n    configs.each do |config|\n      @processors << lambda { |data| process_with_config(data, config) }\n    end\n  end\n\n  def build_validators(rules)\n    validators = []\n    rules.each do |rule|\n      validators << Proc.new { |value| validate_with_rule(value, rule) }\n    end\n    validators\n  end\n\n  def create_handlers(names)\n    handlers = {}\n    names.each do |name|\n      handlers[name] = -> { handle(name) }\n    end\n    handlers\n  end\n\n  def process_all(data_list)\n    data_list.each do |data|\n      @processors.each { |p| @results << p.call(data) }\n    end\n    @results\n  end\n\n  def async_process(items)\n    threads = []\n    items.each do |item|\n      threads << Thread.new { process_item(item) }\n    end\n    threads.map(&:value)\n  end\n\n  def filter_with_callback(items, &callback)\n    results = []\n    items.each do |item|\n      result = callback.call(item)\n      results << item if result\n    end\n    results\n  end\n\n  private\n\n  def process_with_config(data, config)\n    # Processing logic\n    { data: data, config: config[:name] }\n  end\n\n  def validate_with_rule(value, rule)\n    case rule[:type]\n    when :required then !value.nil? && !value.empty?\n    when :min_length then value.to_s.length >= rule[:value]\n    when :max_length then value.to_s.length <= rule[:value]\n    else true\n    end\n  end\n\n  def handle(name)\n    \"Handled: #{name}\"\n  end\n\n  def process_item(item)\n    # Item processing\n    item.to_s.upcase\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/data_processor.rb'\n\n@@ -0,0 +1,78 @@\n__new hunk__\n1 +class DataProcessor\n2 +  def initialize\n3 +    @processors = []\n4 +    @results = []\n5 +  end\n6 +\n7 +  def register_processors(configs)\n8 +    configs.each do |config|\n9 +      @processors << lambda { |data| process_with_config(data, config) }\n10 +    end\n11 +  end\n12 +\n13 +  def build_validators(rules)\n14 +    validators = []\n15 +    rules.each do |rule|\n16 +      validators << Proc.new { |value| validate_with_rule(value, rule) }\n17 +    end\n18 +    validators\n19 +  end\n20 +\n21 +  def create_handlers(names)\n22 +    handlers = {}\n23 +    names.each do |name|\n24 +      handlers[name] = -> { handle(name) }\n25 +    end\n26 +    handlers\n27 +  end\n28 +\n29 +  def process_all(data_list)\n30 +    data_list.each do |data|\n31 +      @processors.each { |p| @results << p.call(data) }\n32 +    end\n33 +    @results\n34 +  end\n35 +\n36 +  def async_process(items)\n37 +    threads = []\n38 +    items.each do |item|\n39 +      threads << Thread.new { process_item(item) }\n40 +    end\n41 +    threads.map(&:value)\n42 +  end\n43 +\n44 +  def filter_with_callback(items, &callback)\n45 +    results = []\n46 +    items.each do |item|\n47 +      result = callback.call(item)\n48 +      results << item if result\n49 +    end\n50 +    results\n51 +  end\n52 +\n53 +  private\n54 +\n55 +  def process_with_config(data, config)\n56 +    # Processing logic\n57 +    { data: data, config: config[:name] }\n58 +  end\n59 +\n60 +  def validate_with_rule(value, rule)\n61 +    case rule[:type]\n62 +    when :required then !value.nil? && !value.empty?\n63 +    when :min_length then value.to_s.length >= rule[:value]\n64 +    when :max_length then value.to_s.length <= rule[:value]\n65 +    else true\n66 +    end\n67 +  end\n68 +\n69 +  def handle(name)\n70 +    \"Handled: #{name}\"\n71 +  end\n72 +\n73 +  def process_item(item)\n74 +    # Item processing\n75 +    item.to_s.upcase\n76 +  end\n77 +end\n78 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in app/services/data_processor.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "configs.each do |config|\n      @processors << lambda { |data| process_with_config(data, config) }\n    end", "improvedCode": "configs.each do |config|\n      config_copy = config.dup.freeze\n      @processors << lambda { |data| process_with_config(data, config_copy) }\n    end", "relevantFile": "app/services/data_processor.rb", "relevantLinesEnd": 10, "suggestionContent": "The `register_processors` method captures `config` in a lambda inside a loop. However, unlike Python, Ruby's blocks capture variables by reference at closure creation time correctly. But there's still an issue: if configs is mutated after registration, the lambdas will use the mutated values. More importantly, this pattern creates a memory leak as each lambda holds a reference to the config objects.", "oneSentenceSummary": "Lambda captures mutable config reference - changes after registration affect behavior", "relevantLinesStart": 8}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/pricing_calculator.rb", "language": "Ruby", "fileContent": "class PricingCalculator\n  TAX_RATE = 0.08\n  DISCOUNT_THRESHOLD = 100.0\n\n  def calculate_total(items)\n    subtotal = items.sum { |item| item[:price] * item[:quantity] }\n    tax = subtotal * TAX_RATE\n    subtotal + tax\n  end\n\n  def apply_discount(total, discount_percent)\n    discount = total * (discount_percent / 100.0)\n    total - discount\n  end\n\n  def verify_payment(expected, received)\n    expected == received\n  end\n\n  def is_zero_balance?(balance)\n    balance == 0.0\n  end\n\n  def split_bill(total, people_count)\n    per_person = total / people_count\n    remainder = total - (per_person * people_count)\n\n    shares = Array.new(people_count, per_person)\n    shares[-1] += remainder if remainder != 0.0\n\n    shares\n  end\n\n  def prices_match?(price1, price2)\n    price1 == price2\n  end\n\n  def calculate_change(paid, owed)\n    change = paid - owed\n    return 0.0 if change == 0.0\n    change\n  end\n\n  def eligible_for_discount?(subtotal)\n    subtotal == DISCOUNT_THRESHOLD || subtotal > DISCOUNT_THRESHOLD\n  end\n\n  def round_to_cents(amount)\n    (amount * 100).round / 100.0\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/pricing_calculator.rb'\n\n@@ -0,0 +1,52 @@\n__new hunk__\n1 +class PricingCalculator\n2 +  TAX_RATE = 0.08\n3 +  DISCOUNT_THRESHOLD = 100.0\n4 +\n5 +  def calculate_total(items)\n6 +    subtotal = items.sum { |item| item[:price] * item[:quantity] }\n7 +    tax = subtotal * TAX_RATE\n8 +    subtotal + tax\n9 +  end\n10 +\n11 +  def apply_discount(total, discount_percent)\n12 +    discount = total * (discount_percent / 100.0)\n13 +    total - discount\n14 +  end\n15 +\n16 +  def verify_payment(expected, received)\n17 +    expected == received\n18 +  end\n19 +\n20 +  def is_zero_balance?(balance)\n21 +    balance == 0.0\n22 +  end\n23 +\n24 +  def split_bill(total, people_count)\n25 +    per_person = total / people_count\n26 +    remainder = total - (per_person * people_count)\n27 +\n28 +    shares = Array.new(people_count, per_person)\n29 +    shares[-1] += remainder if remainder != 0.0\n30 +\n31 +    shares\n32 +  end\n33 +\n34 +  def prices_match?(price1, price2)\n35 +    price1 == price2\n36 +  end\n37 +\n38 +  def calculate_change(paid, owed)\n39 +    change = paid - owed\n40 +    return 0.0 if change == 0.0\n41 +    change\n42 +  end\n43 +\n44 +  def eligible_for_discount?(subtotal)\n45 +    subtotal == DISCOUNT_THRESHOLD || subtotal > DISCOUNT_THRESHOLD\n46 +  end\n47 +\n48 +  def round_to_cents(amount)\n49 +    (amount * 100).round / 100.0\n50 +  end\n51 +end\n52 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/services/pricing_calculator.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def verify_payment(expected, received)\n    expected == received\n  end", "improvedCode": "def verify_payment(expected, received)\n    (expected - received).abs < 0.001\n  end", "relevantFile": "app/services/pricing_calculator.rb", "relevantLinesEnd": 18, "suggestionContent": "The `verify_payment` method compares floating point numbers with `==`. Due to floating point representation, `0.1 + 0.2 != 0.3` in Ruby. Payment amounts like `100.10 + 50.20` may not equal `150.30` exactly. Use a threshold comparison or `BigDecimal` for financial calculations.", "oneSentenceSummary": "Floating point == comparison fails due to precision errors", "relevantLinesStart": 16}, {"label": "bug", "language": "Ruby", "existingCode": "def is_zero_balance?(balance)\n    balance == 0.0\n  end", "improvedCode": "def is_zero_balance?(balance)\n    balance.abs < 0.001\n  end", "relevantFile": "app/services/pricing_calculator.rb", "relevantLinesEnd": 22, "suggestionContent": "The `is_zero_balance?` method compares with `0.0` using `==`. A balance calculated as `100.0 - 50.0 - 50.0` might be `1.4210854715202004e-14` instead of exactly `0.0`. This causes incorrect zero detection.", "oneSentenceSummary": "Zero check fails for near-zero floating point values", "relevantLinesStart": 20}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/controllers/users_controller.rb", "language": "Ruby", "fileContent": "class UsersController < ApplicationController\n  before_action :authenticate_user!\n  before_action :set_user, only: [:show, :edit, :update, :destroy]\n\n  def index\n    @users = User.all\n  end\n\n  def show\n  end\n\n  def new\n    @user = User.new\n  end\n\n  def create\n    @user = User.new(params[:user])\n\n    if @user.save\n      redirect_to @user, notice: 'User created successfully.'\n    else\n      render :new\n    end\n  end\n\n  def edit\n  end\n\n  def update\n    if @user.update(params[:user])\n      redirect_to @user, notice: 'User updated successfully.'\n    else\n      render :edit\n    end\n  end\n\n  def destroy\n    @user.destroy\n    redirect_to users_path, notice: 'User deleted.'\n  end\n\n  def bulk_update\n    params[:users].each do |user_data|\n      user = User.find(user_data[:id])\n      user.update(user_data)\n    end\n    redirect_to users_path, notice: 'Users updated.'\n  end\n\n  def profile_update\n    current_user.update(params.permit(:name, :email, :avatar))\n    redirect_to profile_path\n  end\n\n  private\n\n  def set_user\n    @user = User.find(params[:id])\n  end\n\n  def user_params\n    params.require(:user).permit(:name, :email, :password, :password_confirmation)\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/controllers/users_controller.rb'\n\n@@ -0,0 +1,65 @@\n__new hunk__\n1 +class UsersController < ApplicationController\n2 +  before_action :authenticate_user!\n3 +  before_action :set_user, only: [:show, :edit, :update, :destroy]\n4 +\n5 +  def index\n6 +    @users = User.all\n7 +  end\n8 +\n9 +  def show\n10 +  end\n11 +\n12 +  def new\n13 +    @user = User.new\n14 +  end\n15 +\n16 +  def create\n17 +    @user = User.new(params[:user])\n18 +\n19 +    if @user.save\n20 +      redirect_to @user, notice: 'User created successfully.'\n21 +    else\n22 +      render :new\n23 +    end\n24 +  end\n25 +\n26 +  def edit\n27 +  end\n28 +\n29 +  def update\n30 +    if @user.update(params[:user])\n31 +      redirect_to @user, notice: 'User updated successfully.'\n32 +    else\n33 +      render :edit\n34 +    end\n35 +  end\n36 +\n37 +  def destroy\n38 +    @user.destroy\n39 +    redirect_to users_path, notice: 'User deleted.'\n40 +  end\n41 +\n42 +  def bulk_update\n43 +    params[:users].each do |user_data|\n44 +      user = User.find(user_data[:id])\n45 +      user.update(user_data)\n46 +    end\n47 +    redirect_to users_path, notice: 'Users updated.'\n48 +  end\n49 +\n50 +  def profile_update\n51 +    current_user.update(params.permit(:name, :email, :avatar))\n52 +    redirect_to profile_path\n53 +  end\n54 +\n55 +  private\n56 +\n57 +  def set_user\n58 +    @user = User.find(params[:id])\n59 +  end\n60 +\n61 +  def user_params\n62 +    params.require(:user).permit(:name, :email, :password, :password_confirmation)\n63 +  end\n64 +end\n65 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/controllers/users_controller.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "@user = User.new(params[:user])", "improvedCode": "@user = User.new(user_params)", "relevantFile": "app/controllers/users_controller.rb", "relevantLinesEnd": 17, "suggestionContent": "The `create` method uses `params[:user]` directly without strong parameters, allowing mass assignment. An attacker can pass `user[admin]=true` or `user[role]=superadmin` to escalate privileges. Always use permitted parameters.", "oneSentenceSummary": "Mass assignment vulnerability allows setting admin/role attributes", "relevantLinesStart": 17}, {"label": "bug", "language": "Ruby", "existingCode": "if @user.update(params[:user])", "improvedCode": "if @user.update(user_params)", "relevantFile": "app/controllers/users_controller.rb", "relevantLinesEnd": 30, "suggestionContent": "The `update` method also uses `params[:user]` directly. Combined with `set_user` that finds by ID, an attacker can modify any user's attributes including sensitive fields like `admin`, `role`, or `password`.", "oneSentenceSummary": "Mass assignment in update allows privilege escalation", "relevantLinesStart": 30}, {"label": "bug", "language": "Ruby", "existingCode": "params[:users].each do |user_data|\n      user = User.find(user_data[:id])\n      user.update(user_data)\n    end", "improvedCode": "params[:users].each do |user_data|\n      user = User.find(user_data[:id])\n      permitted = user_data.permit(:name, :email)\n      user.update(permitted)\n    end", "relevantFile": "app/controllers/users_controller.rb", "relevantLinesEnd": 45, "suggestionContent": "The `bulk_update` method iterates over user params without any permission checking. An attacker can update any user's attributes by passing arbitrary user IDs and data, including making themselves admin.", "oneSentenceSummary": "Bulk update allows mass assignment on arbitrary users", "relevantLinesStart": 42}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/notification_service.rb", "language": "Ruby", "fileContent": "class NotificationService\n  def initialize(config = {})\n    @config = config\n    @notifications = []\n  end\n\n  def create_notification(user_id:, message:, metadata: {})\n    notification = {\n      id: SecureRandom.uuid,\n      user_id: user_id,\n      message: message,\n      metadata: metadata,\n      created_at: Time.current\n    }\n\n    metadata[:sent_at] = Time.current\n    @notifications << notification\n\n    Rails.logger.info(\"Created notification for user #{user_id}\")\n    notification\n  end\n\n  def bulk_notify(user_ids, message, tags: [])\n    user_ids.each do |user_id|\n      tags << \"bulk_#{user_id}\"\n      create_notification(\n        user_id: user_id,\n        message: message,\n        metadata: { tags: tags }\n      )\n    end\n  end\n\n  def get_notifications(user_id)\n    @notifications.select { |n| n[:user_id] == user_id }\n  end\n\n  def clear_notifications\n    @notifications.clear\n  end\n\n  def notification_count\n    @notifications.size\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/notification_service.rb'\n\n@@ -0,0 +1,46 @@\n__new hunk__\n1 +class NotificationService\n2 +  def initialize(config = {})\n3 +    @config = config\n4 +    @notifications = []\n5 +  end\n6 +\n7 +  def create_notification(user_id:, message:, metadata: {})\n8 +    notification = {\n9 +      id: SecureRandom.uuid,\n10 +      user_id: user_id,\n11 +      message: message,\n12 +      metadata: metadata,\n13 +      created_at: Time.current\n14 +    }\n15 +\n16 +    metadata[:sent_at] = Time.current\n17 +    @notifications << notification\n18 +\n19 +    Rails.logger.info(\"Created notification for user #{user_id}\")\n20 +    notification\n21 +  end\n22 +\n23 +  def bulk_notify(user_ids, message, tags: [])\n24 +    user_ids.each do |user_id|\n25 +      tags << \"bulk_#{user_id}\"\n26 +      create_notification(\n27 +        user_id: user_id,\n28 +        message: message,\n29 +        metadata: { tags: tags }\n30 +      )\n31 +    end\n32 +  end\n33 +\n34 +  def get_notifications(user_id)\n35 +    @notifications.select { |n| n[:user_id] == user_id }\n36 +  end\n37 +\n38 +  def clear_notifications\n39 +    @notifications.clear\n40 +  end\n41 +\n42 +  def notification_count\n43 +    @notifications.size\n44 +  end\n45 +end\n46 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/services/notification_service.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def create_notification(user_id:, message:, metadata: {})", "improvedCode": "def create_notification(user_id:, message:, metadata: nil)\n    metadata ||= {}", "relevantFile": "app/services/notification_service.rb", "relevantLinesEnd": 7, "suggestionContent": "The `create_notification` method has a mutable default argument `metadata: {}`. In Ruby, default argument values are evaluated once when the method is defined, not on each call. All calls without metadata will share the same hash object. When `metadata[:sent_at] = Time.current` is executed, it modifies this shared hash, affecting all notifications.", "oneSentenceSummary": "Mutable default argument causes shared state between method calls", "relevantLinesStart": 7}, {"label": "bug", "language": "Ruby", "existingCode": "def bulk_notify(user_ids, message, tags: [])\n    user_ids.each do |user_id|\n      tags << \"bulk_#{user_id}\"", "improvedCode": "def bulk_notify(user_ids, message, tags: nil)\n    tags = (tags || []).dup\n    user_ids.each do |user_id|\n      tags << \"bulk_#{user_id}\"", "relevantFile": "app/services/notification_service.rb", "relevantLinesEnd": 25, "suggestionContent": "The `bulk_notify` method has `tags: []` as a default argument. The `tags << \"bulk_#{user_id}\"` modifies this shared array. After one bulk operation, subsequent calls will have all previous tags accumulated.", "oneSentenceSummary": "Mutable default array accumulates values across calls", "relevantLinesStart": 23}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/config_loader.rb", "language": "Ruby", "fileContent": "require 'yaml'\nrequire 'erb'\n\nclass ConfigLoader\n  def initialize(config_dir)\n    @config_dir = config_dir\n    @cache = {}\n  end\n\n  def load_config(filename)\n    return @cache[filename] if @cache[filename]\n\n    filepath = File.join(@config_dir, filename)\n    raise \"Config file not found: #{filepath}\" unless File.exist?(filepath)\n\n    content = File.read(filepath)\n    config = YAML.load(content)\n\n    @cache[filename] = config\n    config\n  end\n\n  def load_config_with_erb(filename)\n    filepath = File.join(@config_dir, filename)\n    content = File.read(filepath)\n    processed = ERB.new(content).result\n    YAML.load(processed)\n  end\n\n  def load_from_string(yaml_string)\n    YAML.load(yaml_string)\n  end\n\n  def load_all_configs\n    configs = {}\n    Dir.glob(File.join(@config_dir, '*.yml')).each do |filepath|\n      name = File.basename(filepath, '.yml')\n      configs[name] = YAML.load(File.read(filepath))\n    end\n    configs\n  end\n\n  def merge_configs(*filenames)\n    result = {}\n    filenames.each do |filename|\n      config = load_config(filename)\n      result = deep_merge(result, config)\n    end\n    result\n  end\n\n  def reload_config(filename)\n    @cache.delete(filename)\n    load_config(filename)\n  end\n\n  private\n\n  def deep_merge(hash1, hash2)\n    hash1.merge(hash2) do |_key, old_val, new_val|\n      if old_val.is_a?(Hash) && new_val.is_a?(Hash)\n        deep_merge(old_val, new_val)\n      else\n        new_val\n      end\n    end\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/config_loader.rb'\n\n@@ -0,0 +1,69 @@\n__new hunk__\n1 +require 'yaml'\n2 +require 'erb'\n3 +\n4 +class ConfigLoader\n5 +  def initialize(config_dir)\n6 +    @config_dir = config_dir\n7 +    @cache = {}\n8 +  end\n9 +\n10 +  def load_config(filename)\n11 +    return @cache[filename] if @cache[filename]\n12 +\n13 +    filepath = File.join(@config_dir, filename)\n14 +    raise \"Config file not found: #{filepath}\" unless File.exist?(filepath)\n15 +\n16 +    content = File.read(filepath)\n17 +    config = YAML.load(content)\n18 +\n19 +    @cache[filename] = config\n20 +    config\n21 +  end\n22 +\n23 +  def load_config_with_erb(filename)\n24 +    filepath = File.join(@config_dir, filename)\n25 +    content = File.read(filepath)\n26 +    processed = ERB.new(content).result\n27 +    YAML.load(processed)\n28 +  end\n29 +\n30 +  def load_from_string(yaml_string)\n31 +    YAML.load(yaml_string)\n32 +  end\n33 +\n34 +  def load_all_configs\n35 +    configs = {}\n36 +    Dir.glob(File.join(@config_dir, '*.yml')).each do |filepath|\n37 +      name = File.basename(filepath, '.yml')\n38 +      configs[name] = YAML.load(File.read(filepath))\n39 +    end\n40 +    configs\n41 +  end\n42 +\n43 +  def merge_configs(*filenames)\n44 +    result = {}\n45 +    filenames.each do |filename|\n46 +      config = load_config(filename)\n47 +      result = deep_merge(result, config)\n48 +    end\n49 +    result\n50 +  end\n51 +\n52 +  def reload_config(filename)\n53 +    @cache.delete(filename)\n54 +    load_config(filename)\n55 +  end\n56 +\n57 +  private\n58 +\n59 +  def deep_merge(hash1, hash2)\n60 +    hash1.merge(hash2) do |_key, old_val, new_val|\n61 +      if old_val.is_a?(Hash) && new_val.is_a?(Hash)\n62 +        deep_merge(old_val, new_val)\n63 +      else\n64 +        new_val\n65 +      end\n66 +    end\n67 +  end\n68 +end\n69 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in app/services/config_loader.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "config = YAML.load(content)", "improvedCode": "config = YAML.safe_load(content, permitted_classes: [Symbol, Date, Time])", "relevantFile": "app/services/config_loader.rb", "relevantLinesEnd": 17, "suggestionContent": "Multiple methods use `YAML.load` which is unsafe in Ruby. It can deserialize arbitrary Ruby objects, allowing remote code execution. A malicious YAML file with `!ruby/object:Gem::Installer` can execute system commands. Use `YAML.safe_load` instead, which only allows basic types.", "oneSentenceSummary": "YAML.load allows arbitrary code execution via malicious YAML files", "relevantLinesStart": 17}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/cache_service.rb", "language": "Ruby", "fileContent": "class CacheService\n  def initialize\n    @store = {}\n    @stats = { hits: 0, misses: 0 }\n  end\n\n  def get(key)\n    if @store.key?(key)\n      @stats[:hits] += 1\n      @store[key]\n    else\n      @stats[:misses] += 1\n      nil\n    end\n  end\n\n  def set(key, value, ttl: nil)\n    @store[key] = {\n      value: value,\n      expires_at: ttl ? Time.current + ttl : nil\n    }\n  end\n\n  def fetch(key, &block)\n    return get(key) if exists?(key)\n\n    value = block.call\n    set(key, value)\n    value\n  end\n\n  def exists?(key)\n    @store.key?(key)\n  end\n\n  def delete(key)\n    @store.delete(key)\n  end\n\n  def process_options(options)\n    ttl = options['ttl'] || options[:ttl] || 3600\n    namespace = options['namespace'] || options[:namespace] || 'default'\n    compress = options['compress'] || options[:compress] || false\n\n    { ttl: ttl, namespace: namespace, compress: compress }\n  end\n\n  def get_from_params(params)\n    key = params['key']\n    namespace = params[:namespace]\n\n    full_key = \"#{namespace}:#{key}\"\n    get(full_key)\n  end\n\n  def stats\n    @stats.dup\n  end\n\n  def clear\n    @store.clear\n    @stats = { hits: 0, misses: 0 }\n  end\n\n  def import_data(data)\n    data.each do |key, value|\n      @store[key.to_s] = value\n    end\n  end\n\n  def export_data\n    @store.transform_keys(&:to_s)\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/cache_service.rb'\n\n@@ -0,0 +1,75 @@\n__new hunk__\n1 +class CacheService\n2 +  def initialize\n3 +    @store = {}\n4 +    @stats = { hits: 0, misses: 0 }\n5 +  end\n6 +\n7 +  def get(key)\n8 +    if @store.key?(key)\n9 +      @stats[:hits] += 1\n10 +      @store[key]\n11 +    else\n12 +      @stats[:misses] += 1\n13 +      nil\n14 +    end\n15 +  end\n16 +\n17 +  def set(key, value, ttl: nil)\n18 +    @store[key] = {\n19 +      value: value,\n20 +      expires_at: ttl ? Time.current + ttl : nil\n21 +    }\n22 +  end\n23 +\n24 +  def fetch(key, &block)\n25 +    return get(key) if exists?(key)\n26 +\n27 +    value = block.call\n28 +    set(key, value)\n29 +    value\n30 +  end\n31 +\n32 +  def exists?(key)\n33 +    @store.key?(key)\n34 +  end\n35 +\n36 +  def delete(key)\n37 +    @store.delete(key)\n38 +  end\n39 +\n40 +  def process_options(options)\n41 +    ttl = options['ttl'] || options[:ttl] || 3600\n42 +    namespace = options['namespace'] || options[:namespace] || 'default'\n43 +    compress = options['compress'] || options[:compress] || false\n44 +\n45 +    { ttl: ttl, namespace: namespace, compress: compress }\n46 +  end\n47 +\n48 +  def get_from_params(params)\n49 +    key = params['key']\n50 +    namespace = params[:namespace]\n51 +\n52 +    full_key = \"#{namespace}:#{key}\"\n53 +    get(full_key)\n54 +  end\n55 +\n56 +  def stats\n57 +    @stats.dup\n58 +  end\n59 +\n60 +  def clear\n61 +    @store.clear\n62 +    @stats = { hits: 0, misses: 0 }\n63 +  end\n64 +\n65 +  def import_data(data)\n66 +    data.each do |key, value|\n67 +      @store[key.to_s] = value\n68 +    end\n69 +  end\n70 +\n71 +  def export_data\n72 +    @store.transform_keys(&:to_s)\n73 +  end\n74 +end\n75 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/services/cache_service.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "ttl = options['ttl'] || options[:ttl] || 3600\n    namespace = options['namespace'] || options[:namespace] || 'default'\n    compress = options['compress'] || options[:compress] || false", "improvedCode": "options = options.with_indifferent_access\n    ttl = options.fetch(:ttl, 3600)\n    namespace = options.fetch(:namespace, 'default')\n    compress = options.fetch(:compress, false)", "relevantFile": "app/services/cache_service.rb", "relevantLinesEnd": 42, "suggestionContent": "The `process_options` method tries to handle both string and symbol keys with `options['ttl'] || options[:ttl]`. However, if `options['ttl']` is `false` or `0`, the `||` will skip it and check `:ttl`. This causes incorrect behavior when falsy values are valid. Also, this pattern is error-prone and verbose. Use `Hash#fetch` or `HashWithIndifferentAccess`.", "oneSentenceSummary": "String/symbol key handling with || fails for falsy values like false or 0", "relevantLinesStart": 40}, {"label": "bug", "language": "Ruby", "existingCode": "key = params['key']\n    namespace = params[:namespace]", "improvedCode": "params = params.with_indifferent_access\n    key = params[:key]\n    namespace = params[:namespace]", "relevantFile": "app/services/cache_service.rb", "relevantLinesEnd": 48, "suggestionContent": "The `get_from_params` method accesses `params['key']` (string) and `params[:namespace]` (symbol) inconsistently. If params uses symbol keys, `params['key']` returns nil. This causes `full_key` to be `\"namespace:\"` without the actual key.", "oneSentenceSummary": "Inconsistent string/symbol key access causes nil values", "relevantLinesStart": 47}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/file_processor.rb", "language": "Ruby", "fileContent": "class FileProcessor\n  def initialize(base_path)\n    @base_path = base_path\n  end\n\n  def read_file(filename)\n    path = File.join(@base_path, filename)\n    file = File.open(path, 'r')\n    content = file.read\n    file.close\n    content\n  end\n\n  def write_file(filename, content)\n    path = File.join(@base_path, filename)\n    file = File.open(path, 'w')\n    file.write(content)\n    file.close\n  end\n\n  def process_csv(filename)\n    path = File.join(@base_path, filename)\n    file = File.open(path, 'r')\n\n    results = []\n    file.each_line do |line|\n      fields = line.strip.split(',')\n      results << process_row(fields)\n    end\n\n    file.close\n    results\n  end\n\n  def copy_file(source, destination)\n    source_path = File.join(@base_path, source)\n    dest_path = File.join(@base_path, destination)\n\n    source_file = File.open(source_path, 'rb')\n    dest_file = File.open(dest_path, 'wb')\n\n    while (chunk = source_file.read(8192))\n      dest_file.write(chunk)\n    end\n\n    source_file.close\n    dest_file.close\n  end\n\n  def read_safe(filename)\n    path = File.join(@base_path, filename)\n    File.read(path)\n  end\n\n  def write_safe(filename, content)\n    path = File.join(@base_path, filename)\n    File.write(path, content)\n  end\n\n  private\n\n  def process_row(fields)\n    { id: fields[0], name: fields[1], value: fields[2] }\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/file_processor.rb'\n\n@@ -0,0 +1,66 @@\n__new hunk__\n1 +class FileProcessor\n2 +  def initialize(base_path)\n3 +    @base_path = base_path\n4 +  end\n5 +\n6 +  def read_file(filename)\n7 +    path = File.join(@base_path, filename)\n8 +    file = File.open(path, 'r')\n9 +    content = file.read\n10 +    file.close\n11 +    content\n12 +  end\n13 +\n14 +  def write_file(filename, content)\n15 +    path = File.join(@base_path, filename)\n16 +    file = File.open(path, 'w')\n17 +    file.write(content)\n18 +    file.close\n19 +  end\n20 +\n21 +  def process_csv(filename)\n22 +    path = File.join(@base_path, filename)\n23 +    file = File.open(path, 'r')\n24 +\n25 +    results = []\n26 +    file.each_line do |line|\n27 +      fields = line.strip.split(',')\n28 +      results << process_row(fields)\n29 +    end\n30 +\n31 +    file.close\n32 +    results\n33 +  end\n34 +\n35 +  def copy_file(source, destination)\n36 +    source_path = File.join(@base_path, source)\n37 +    dest_path = File.join(@base_path, destination)\n38 +\n39 +    source_file = File.open(source_path, 'rb')\n40 +    dest_file = File.open(dest_path, 'wb')\n41 +\n42 +    while (chunk = source_file.read(8192))\n43 +      dest_file.write(chunk)\n44 +    end\n45 +\n46 +    source_file.close\n47 +    dest_file.close\n48 +  end\n49 +\n50 +  def read_safe(filename)\n51 +    path = File.join(@base_path, filename)\n52 +    File.read(path)\n53 +  end\n54 +\n55 +  def write_safe(filename, content)\n56 +    path = File.join(@base_path, filename)\n57 +    File.write(path, content)\n58 +  end\n59 +\n60 +  private\n61 +\n62 +  def process_row(fields)\n63 +    { id: fields[0], name: fields[1], value: fields[2] }\n64 +  end\n65 +end\n66 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/services/file_processor.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def read_file(filename)\n    path = File.join(@base_path, filename)\n    file = File.open(path, 'r')\n    content = file.read\n    file.close\n    content\n  end", "improvedCode": "def read_file(filename)\n    path = File.join(@base_path, filename)\n    File.open(path, 'r') do |file|\n      file.read\n    end\n  end", "relevantFile": "app/services/file_processor.rb", "relevantLinesEnd": 12, "suggestionContent": "The `read_file` method opens a file but if `file.read` raises an exception, `file.close` is never called, causing a file descriptor leak. Use block form of `File.open` which automatically closes the file, or use `ensure`.", "oneSentenceSummary": "File descriptor leak if exception occurs before close", "relevantLinesStart": 6}, {"label": "bug", "language": "Ruby", "existingCode": "source_file = File.open(source_path, 'rb')\n    dest_file = File.open(dest_path, 'wb')\n\n    while (chunk = source_file.read(8192))\n      dest_file.write(chunk)\n    end\n\n    source_file.close\n    dest_file.close", "improvedCode": "File.open(source_path, 'rb') do |source_file|\n      File.open(dest_path, 'wb') do |dest_file|\n        while (chunk = source_file.read(8192))\n          dest_file.write(chunk)\n        end\n      end\n    end", "relevantFile": "app/services/file_processor.rb", "relevantLinesEnd": 45, "suggestionContent": "The `copy_file` method opens two files but if an error occurs during copying, neither file is closed. This leaks two file descriptors per failed copy operation.", "oneSentenceSummary": "Two file descriptors leaked if copy operation fails", "relevantLinesStart": 37}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/counter_service.rb", "language": "Ruby", "fileContent": "class CounterService\n  @@instance = nil\n\n  def self.instance\n    @@instance ||= new\n  end\n\n  def initialize\n    @counters = {}\n    @total = 0\n  end\n\n  def increment(name, amount = 1)\n    @counters[name] ||= 0\n    @counters[name] += amount\n    @total += amount\n  end\n\n  def decrement(name, amount = 1)\n    @counters[name] ||= 0\n    @counters[name] -= amount\n    @total -= amount\n  end\n\n  def get(name)\n    @counters[name] || 0\n  end\n\n  def total\n    @total\n  end\n\n  def check_and_increment(name, threshold)\n    current = @counters[name] || 0\n    if current < threshold\n      @counters[name] = current + 1\n      @total += 1\n      true\n    else\n      false\n    end\n  end\n\n  def reset(name)\n    old_value = @counters[name] || 0\n    @counters[name] = 0\n    @total -= old_value\n    old_value\n  end\n\n  def all_counters\n    @counters.dup\n  end\n\n  def reset_all\n    @counters.clear\n    @total = 0\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/counter_service.rb'\n\n@@ -0,0 +1,60 @@\n__new hunk__\n1 +class CounterService\n2 +  @@instance = nil\n3 +\n4 +  def self.instance\n5 +    @@instance ||= new\n6 +  end\n7 +\n8 +  def initialize\n9 +    @counters = {}\n10 +    @total = 0\n11 +  end\n12 +\n13 +  def increment(name, amount = 1)\n14 +    @counters[name] ||= 0\n15 +    @counters[name] += amount\n16 +    @total += amount\n17 +  end\n18 +\n19 +  def decrement(name, amount = 1)\n20 +    @counters[name] ||= 0\n21 +    @counters[name] -= amount\n22 +    @total -= amount\n23 +  end\n24 +\n25 +  def get(name)\n26 +    @counters[name] || 0\n27 +  end\n28 +\n29 +  def total\n30 +    @total\n31 +  end\n32 +\n33 +  def check_and_increment(name, threshold)\n34 +    current = @counters[name] || 0\n35 +    if current < threshold\n36 +      @counters[name] = current + 1\n37 +      @total += 1\n38 +      true\n39 +    else\n40 +      false\n41 +    end\n42 +  end\n43 +\n44 +  def reset(name)\n45 +    old_value = @counters[name] || 0\n46 +    @counters[name] = 0\n47 +    @total -= old_value\n48 +    old_value\n49 +  end\n50 +\n51 +  def all_counters\n52 +    @counters.dup\n53 +  end\n54 +\n55 +  def reset_all\n56 +    @counters.clear\n57 +    @total = 0\n58 +  end\n59 +end\n60 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/counter_service.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def self.instance\n    @@instance ||= new\n  end", "improvedCode": "require 'singleton'\n\nclass CounterService\n  include Singleton", "relevantFile": "app/services/counter_service.rb", "relevantLinesEnd": 6, "suggestionContent": "The singleton implementation `@@instance ||= new` is not thread-safe. Multiple threads can see `@@instance` as nil simultaneously and each create their own instance. Use `Mutex` or Ruby's built-in `Singleton` module.", "oneSentenceSummary": "Non-thread-safe singleton - race condition creates multiple instances", "relevantLinesStart": 4}, {"label": "bug", "language": "Ruby", "existingCode": "def increment(name, amount = 1)\n    @counters[name] ||= 0\n    @counters[name] += amount\n    @total += amount\n  end", "improvedCode": "def increment(name, amount = 1)\n    @mutex.synchronize do\n      @counters[name] ||= 0\n      @counters[name] += amount\n      @total += amount\n    end\n  end", "relevantFile": "app/services/counter_service.rb", "relevantLinesEnd": 17, "suggestionContent": "The `increment` method has a race condition. The `@counters[name] += amount` is not atomic - it reads, adds, then writes. Two threads can read the same value, add their amounts, and write, losing one increment. Use `Mutex` or `Concurrent::AtomicFixnum`.", "oneSentenceSummary": "Race condition in counter increment - concurrent updates lose counts", "relevantLinesStart": 13}, {"label": "bug", "language": "Ruby", "existingCode": "def check_and_increment(name, threshold)\n    current = @counters[name] || 0\n    if current < threshold\n      @counters[name] = current + 1", "improvedCode": "def check_and_increment(name, threshold)\n    @mutex.synchronize do\n      current = @counters[name] || 0\n      if current < threshold\n        @counters[name] = current + 1", "relevantFile": "app/services/counter_service.rb", "relevantLinesEnd": 36, "suggestionContent": "The `check_and_increment` method has a TOCTOU (time-of-check-time-of-use) race condition. Between checking `current < threshold` and incrementing, another thread can increment past the threshold.", "oneSentenceSummary": "TOCTOU race condition allows exceeding threshold", "relevantLinesStart": 33}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/text_processor.rb", "language": "Ruby", "fileContent": "class TextProcessor\n  def initialize\n    @encoding = 'UTF-8'\n  end\n\n  def read_file(path)\n    File.read(path)\n  end\n\n  def process_user_input(input)\n    input.downcase.strip\n  end\n\n  def extract_characters(text, count)\n    text[0, count]\n  end\n\n  def count_characters(text)\n    text.length\n  end\n\n  def truncate(text, max_length)\n    return text if text.length <= max_length\n    text[0, max_length] + '...'\n  end\n\n  def search_in_file(path, term)\n    content = File.read(path)\n    content.include?(term)\n  end\n\n  def parse_csv_line(line)\n    line.split(',').map(&:strip)\n  end\n\n  def normalize_whitespace(text)\n    text.gsub(/\\s+/, ' ').strip\n  end\n\n  def safe_read(path)\n    File.read(path, encoding: 'UTF-8')\n  end\n\n  def combine_strings(*strings)\n    result = ''\n    strings.each { |s| result += s }\n    result\n  end\n\n  def build_report(items)\n    report = ''\n    items.each_with_index do |item, index|\n      report += \"#{index + 1}. #{item}\\n\"\n    end\n    report\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/text_processor.rb'\n\n@@ -0,0 +1,58 @@\n__new hunk__\n1 +class TextProcessor\n2 +  def initialize\n3 +    @encoding = 'UTF-8'\n4 +  end\n5 +\n6 +  def read_file(path)\n7 +    File.read(path)\n8 +  end\n9 +\n10 +  def process_user_input(input)\n11 +    input.downcase.strip\n12 +  end\n13 +\n14 +  def extract_characters(text, count)\n15 +    text[0, count]\n16 +  end\n17 +\n18 +  def count_characters(text)\n19 +    text.length\n20 +  end\n21 +\n22 +  def truncate(text, max_length)\n23 +    return text if text.length <= max_length\n24 +    text[0, max_length] + '...'\n25 +  end\n26 +\n27 +  def search_in_file(path, term)\n28 +    content = File.read(path)\n29 +    content.include?(term)\n30 +  end\n31 +\n32 +  def parse_csv_line(line)\n33 +    line.split(',').map(&:strip)\n34 +  end\n35 +\n36 +  def normalize_whitespace(text)\n37 +    text.gsub(/\\s+/, ' ').strip\n38 +  end\n39 +\n40 +  def safe_read(path)\n41 +    File.read(path, encoding: 'UTF-8')\n42 +  end\n43 +\n44 +  def combine_strings(*strings)\n45 +    result = ''\n46 +    strings.each { |s| result += s }\n47 +    result\n48 +  end\n49 +\n50 +  def build_report(items)\n51 +    report = ''\n52 +    items.each_with_index do |item, index|\n53 +      report += \"#{index + 1}. #{item}\\n\"\n54 +    end\n55 +    report\n56 +  end\n57 +end\n58 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/text_processor.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def read_file(path)\n    File.read(path)\n  end", "improvedCode": "def read_file(path)\n    File.read(path, encoding: 'UTF-8')\n  end", "relevantFile": "app/services/text_processor.rb", "relevantLinesEnd": 8, "suggestionContent": "The `read_file` method uses `File.read` without specifying encoding. If the file contains UTF-8 characters but the system default is ASCII-8BIT, string operations will fail with `Encoding::CompatibilityError`. Always specify encoding explicitly.", "oneSentenceSummary": "File.read without encoding causes encoding errors on non-ASCII content", "relevantLinesStart": 6}, {"label": "bug", "language": "Ruby", "existingCode": "def extract_characters(text, count)\n    text[0, count]\n  end", "improvedCode": "def extract_characters(text, count)\n    text.chars.first(count).join\n  end", "relevantFile": "app/services/text_processor.rb", "relevantLinesEnd": 16, "suggestionContent": "The `extract_characters` and `truncate` methods use `String#length` and `String#[]` which count bytes, not characters in some Ruby versions and encodings. For multi-byte UTF-8 characters like emojis, this can split a character mid-byte, corrupting the string. Use `String#chars` for character-safe operations.", "oneSentenceSummary": "String slicing may split multi-byte UTF-8 characters", "relevantLinesStart": 14}, {"label": "bug", "language": "Ruby", "existingCode": "def combine_strings(*strings)\n    result = ''\n    strings.each { |s| result += s }\n    result\n  end", "improvedCode": "def combine_strings(*strings)\n    result = ''\n    strings.each { |s| result << s }\n    result\n  end", "relevantFile": "app/services/text_processor.rb", "relevantLinesEnd": 39, "suggestionContent": "The `combine_strings` and `build_report` methods use `+=` for string concatenation in a loop. In Ruby, strings are mutable but `+=` creates a new string each time, causing O(n²) performance. Use `<<` or `String#concat` for efficient appending.", "oneSentenceSummary": "String += in loop creates O(n²) performance - use << instead", "relevantLinesStart": 35}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/base_handler.rb", "language": "Ruby", "fileContent": "class BaseHandler\n  def initialize(config)\n    @config = config\n    @logger = Rails.logger\n  end\n\n  def handle(request)\n    validate(request)\n    process(request)\n    log_completion(request)\n  end\n\n  def validate(request)\n    raise 'Invalid request' if request.nil?\n  end\n\n  def process(request)\n    raise NotImplementedError, 'Subclass must implement'\n  end\n\n  private\n\n  def log_completion(request)\n    @logger.info(\"Handled request: #{request[:id]}\")\n  end\n\n  def internal_helper\n    # Some helper logic\n  end\nend\n\nclass OrderHandler < BaseHandler\n  def initialize(config, payment_gateway)\n    @payment_gateway = payment_gateway\n    super(config)\n  end\n\n  def handle(request)\n    pre_process(request)\n    result = process(request)\n    post_process(result)\n  end\n\n  def process(request)\n    @payment_gateway.charge(request[:amount])\n  end\n\n  def validate(request)\n    raise 'Amount required' unless request[:amount]\n  end\n\n  private\n\n  def pre_process(request)\n    @logger.info(\"Starting order: #{request[:id]}\")\n  end\n\n  def post_process(result)\n    log_completion(result)\n  end\nend\n\nclass RefundHandler < BaseHandler\n  def process(request)\n    @payment_gateway.refund(request[:transaction_id], request[:amount])\n  end\n\n  def validate(request)\n    super\n    raise 'Transaction ID required' unless request[:transaction_id]\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/base_handler.rb'\n\n@@ -0,0 +1,73 @@\n__new hunk__\n1 +class BaseHandler\n2 +  def initialize(config)\n3 +    @config = config\n4 +    @logger = Rails.logger\n5 +  end\n6 +\n7 +  def handle(request)\n8 +    validate(request)\n9 +    process(request)\n10 +    log_completion(request)\n11 +  end\n12 +\n13 +  def validate(request)\n14 +    raise 'Invalid request' if request.nil?\n15 +  end\n16 +\n17 +  def process(request)\n18 +    raise NotImplementedError, 'Subclass must implement'\n19 +  end\n20 +\n21 +  private\n22 +\n23 +  def log_completion(request)\n24 +    @logger.info(\"Handled request: #{request[:id]}\")\n25 +  end\n26 +\n27 +  def internal_helper\n28 +    # Some helper logic\n29 +  end\n30 +end\n31 +\n32 +class OrderHandler < BaseHandler\n33 +  def initialize(config, payment_gateway)\n34 +    @payment_gateway = payment_gateway\n35 +    super(config)\n36 +  end\n37 +\n38 +  def handle(request)\n39 +    pre_process(request)\n40 +    result = process(request)\n41 +    post_process(result)\n42 +  end\n43 +\n44 +  def process(request)\n45 +    @payment_gateway.charge(request[:amount])\n46 +  end\n47 +\n48 +  def validate(request)\n49 +    raise 'Amount required' unless request[:amount]\n50 +  end\n51 +\n52 +  private\n53 +\n54 +  def pre_process(request)\n55 +    @logger.info(\"Starting order: #{request[:id]}\")\n56 +  end\n57 +\n58 +  def post_process(result)\n59 +    log_completion(result)\n60 +  end\n61 +end\n62 +\n63 +class RefundHandler < BaseHandler\n64 +  def process(request)\n65 +    @payment_gateway.refund(request[:transaction_id], request[:amount])\n66 +  end\n67 +\n68 +  def validate(request)\n69 +    super\n70 +    raise 'Transaction ID required' unless request[:transaction_id]\n71 +  end\n72 +end\n73 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/base_handler.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def handle(request)\n    pre_process(request)\n    result = process(request)\n    post_process(result)\n  end", "improvedCode": "def handle(request)\n    validate(request)\n    pre_process(request)\n    result = process(request)\n    post_process(result)\n  end", "relevantFile": "app/services/base_handler.rb", "relevantLinesEnd": 41, "suggestionContent": "The `OrderHandler#handle` method overrides `BaseHandler#handle` but doesn't call `super` or the parent's `validate` method. This skips the nil check from `BaseHandler#validate`, allowing invalid requests through. The parent's `log_completion` is also skipped.", "oneSentenceSummary": "Overridden handle skips parent validation - allows nil requests", "relevantLinesStart": 37}, {"label": "bug", "language": "Ruby", "existingCode": "def validate(request)\n    raise 'Amount required' unless request[:amount]\n  end", "improvedCode": "def validate(request)\n    super\n    raise 'Amount required' unless request[:amount]\n  end", "relevantFile": "app/services/base_handler.rb", "relevantLinesEnd": 49, "suggestionContent": "The `OrderHandler#validate` method overrides `BaseHandler#validate` without calling `super`. This loses the nil check from the parent class. Compare with `RefundHandler#validate` which correctly calls `super` first.", "oneSentenceSummary": "Override without super skips parent validation logic", "relevantLinesStart": 47}, {"label": "bug", "language": "Ruby", "existingCode": "class RefundHandler < BaseHandler\n  def process(request)\n    @payment_gateway.refund(request[:transaction_id], request[:amount])\n  end", "improvedCode": "class RefundHandler < BaseHandler\n  def initialize(config, payment_gateway)\n    super(config)\n    @payment_gateway = payment_gateway\n  end\n\n  def process(request)\n    @payment_gateway.refund(request[:transaction_id], request[:amount])\n  end", "relevantFile": "app/services/base_handler.rb", "relevantLinesEnd": 64, "suggestionContent": "The `RefundHandler` class references `@payment_gateway` in `process` but never initializes it. The `initialize` method is not overridden, so `@payment_gateway` is `nil`. This will raise `NoMethodError: undefined method 'refund' for nil:NilClass`.", "oneSentenceSummary": "Uninitialized instance variable @payment_gateway causes NoMethodError", "relevantLinesStart": 61}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/session_store.rb", "language": "Ruby", "fileContent": "require 'base64'\n\nclass SessionStore\n  def initialize(redis_client)\n    @redis = redis_client\n    @namespace = 'sessions'\n  end\n\n  def store(session_id, data)\n    serialized = Marshal.dump(data)\n    encoded = Base64.strict_encode64(serialized)\n    @redis.set(key_for(session_id), encoded)\n  end\n\n  def retrieve(session_id)\n    encoded = @redis.get(key_for(session_id))\n    return nil unless encoded\n\n    serialized = Base64.strict_decode64(encoded)\n    Marshal.load(serialized)\n  end\n\n  def delete(session_id)\n    @redis.del(key_for(session_id))\n  end\n\n  def import_session(encoded_data)\n    serialized = Base64.strict_decode64(encoded_data)\n    Marshal.load(serialized)\n  end\n\n  def restore_from_cookie(cookie_value)\n    return nil if cookie_value.nil? || cookie_value.empty?\n\n    decoded = Base64.strict_decode64(cookie_value)\n    Marshal.load(decoded)\n  end\n\n  def export_session(session_id)\n    encoded = @redis.get(key_for(session_id))\n    encoded\n  end\n\n  private\n\n  def key_for(session_id)\n    \"#{@namespace}:#{session_id}\"\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/session_store.rb'\n\n@@ -0,0 +1,50 @@\n__new hunk__\n1 +require 'base64'\n2 +\n3 +class SessionStore\n4 +  def initialize(redis_client)\n5 +    @redis = redis_client\n6 +    @namespace = 'sessions'\n7 +  end\n8 +\n9 +  def store(session_id, data)\n10 +    serialized = Marshal.dump(data)\n11 +    encoded = Base64.strict_encode64(serialized)\n12 +    @redis.set(key_for(session_id), encoded)\n13 +  end\n14 +\n15 +  def retrieve(session_id)\n16 +    encoded = @redis.get(key_for(session_id))\n17 +    return nil unless encoded\n18 +\n19 +    serialized = Base64.strict_decode64(encoded)\n20 +    Marshal.load(serialized)\n21 +  end\n22 +\n23 +  def delete(session_id)\n24 +    @redis.del(key_for(session_id))\n25 +  end\n26 +\n27 +  def import_session(encoded_data)\n28 +    serialized = Base64.strict_decode64(encoded_data)\n29 +    Marshal.load(serialized)\n30 +  end\n31 +\n32 +  def restore_from_cookie(cookie_value)\n33 +    return nil if cookie_value.nil? || cookie_value.empty?\n34 +\n35 +    decoded = Base64.strict_decode64(cookie_value)\n36 +    Marshal.load(decoded)\n37 +  end\n38 +\n39 +  def export_session(session_id)\n40 +    encoded = @redis.get(key_for(session_id))\n41 +    encoded\n42 +  end\n43 +\n44 +  private\n45 +\n46 +  def key_for(session_id)\n47 +    \"#{@namespace}:#{session_id}\"\n48 +  end\n49 +end\n50 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in app/services/session_store.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def restore_from_cookie(cookie_value)\n    return nil if cookie_value.nil? || cookie_value.empty?\n\n    decoded = Base64.strict_decode64(cookie_value)\n    Marshal.load(decoded)\n  end", "improvedCode": "def restore_from_cookie(cookie_value)\n    return nil if cookie_value.nil? || cookie_value.empty?\n\n    decoded = Base64.strict_decode64(cookie_value)\n    JSON.parse(decoded, symbolize_names: true)\n  end", "relevantFile": "app/services/session_store.rb", "relevantLinesEnd": 37, "suggestionContent": "Multiple methods use `Marshal.load` to deserialize data, including data from cookies and external sources (`import_session`, `restore_from_cookie`). Marshal can deserialize arbitrary Ruby objects, allowing remote code execution. An attacker can craft a malicious payload that executes code when deserialized. Use JSON or `MessagePack` for untrusted data.", "oneSentenceSummary": "Marshal.load on untrusted data allows arbitrary code execution", "relevantLinesStart": 32}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/validators/input_validator.rb", "language": "Ruby", "fileContent": "class InputValidator\n  EMAIL_REGEX = /^([a-zA-Z0-9_\\-\\.]+)+@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z]{2,})+$/\n  URL_REGEX = /^(https?:\\/\\/)?([\\w\\-]+\\.)+[\\w\\-]+(\\/[\\w\\-\\.~]*)*\\/?$/\n  SLUG_REGEX = /^[a-z0-9]+(-[a-z0-9]+)*$/\n\n  def validate_email(email)\n    return false if email.nil? || email.empty?\n    email.match?(EMAIL_REGEX)\n  end\n\n  def validate_url(url)\n    return false if url.nil? || url.empty?\n    url.match?(URL_REGEX)\n  end\n\n  def validate_slug(slug)\n    return false if slug.nil? || slug.empty?\n    slug.match?(SLUG_REGEX)\n  end\n\n  def extract_domain(email)\n    match = email.match(/@(.+)$/)\n    match[1] if match\n  end\n\n  def validate_phone(phone)\n    phone =~ /^\\+?[0-9]{10,14}$/\n  end\n\n  def validate_input(input, pattern_string)\n    regex = Regexp.new(pattern_string)\n    input.match?(regex)\n  end\n\n  def sanitize_for_regex(input)\n    input.gsub(/[^a-zA-Z0-9]/, '')\n  end\n\n  def find_matches(text, pattern)\n    regex = /#{pattern}/\n    text.scan(regex)\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/validators/input_validator.rb'\n\n@@ -0,0 +1,44 @@\n__new hunk__\n1 +class InputValidator\n2 +  EMAIL_REGEX = /^([a-zA-Z0-9_\\-\\.]+)+@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z]{2,})+$/\n3 +  URL_REGEX = /^(https?:\\/\\/)?([\\w\\-]+\\.)+[\\w\\-]+(\\/[\\w\\-\\.~]*)*\\/?$/\n4 +  SLUG_REGEX = /^[a-z0-9]+(-[a-z0-9]+)*$/\n5 +\n6 +  def validate_email(email)\n7 +    return false if email.nil? || email.empty?\n8 +    email.match?(EMAIL_REGEX)\n9 +  end\n10 +\n11 +  def validate_url(url)\n12 +    return false if url.nil? || url.empty?\n13 +    url.match?(URL_REGEX)\n14 +  end\n15 +\n16 +  def validate_slug(slug)\n17 +    return false if slug.nil? || slug.empty?\n18 +    slug.match?(SLUG_REGEX)\n19 +  end\n20 +\n21 +  def extract_domain(email)\n22 +    match = email.match(/@(.+)$/)\n23 +    match[1] if match\n24 +  end\n25 +\n26 +  def validate_phone(phone)\n27 +    phone =~ /^\\+?[0-9]{10,14}$/\n28 +  end\n29 +\n30 +  def validate_input(input, pattern_string)\n31 +    regex = Regexp.new(pattern_string)\n32 +    input.match?(regex)\n33 +  end\n34 +\n35 +  def sanitize_for_regex(input)\n36 +    input.gsub(/[^a-zA-Z0-9]/, '')\n37 +  end\n38 +\n39 +  def find_matches(text, pattern)\n40 +    regex = /#{pattern}/\n41 +    text.scan(regex)\n42 +  end\n43 +end\n44 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/validators/input_validator.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "EMAIL_REGEX = /^([a-zA-Z0-9_\\\\-\\\\.]+)+@(([a-zA-Z0-9\\\\-])+\\\\.)+([a-zA-Z]{2,})+$/", "improvedCode": "EMAIL_REGEX = /^[a-zA-Z0-9_\\\\-\\\\.]+@[a-zA-Z0-9\\\\-]+(\\\\.[a-zA-Z0-9\\\\-]+)*\\\\.[a-zA-Z]{2,}$/", "relevantFile": "app/validators/input_validator.rb", "relevantLinesEnd": 2, "suggestionContent": "The `EMAIL_REGEX` has nested quantifiers `([a-zA-Z0-9_\\-\\.]+)+` which causes catastrophic backtracking (ReDoS). A malicious input like 'aaaaaaaaaaaaaaaaaaaaa@' can cause the regex engine to hang for minutes, enabling denial-of-service attacks.", "oneSentenceSummary": "ReDoS vulnerability - nested quantifiers cause exponential backtracking", "relevantLinesStart": 2}, {"label": "bug", "language": "Ruby", "existingCode": "def find_matches(text, pattern)\n    regex = /\\#{pattern}/\n    text.scan(regex)\n  end", "improvedCode": "def find_matches(text, pattern)\n    regex = /\\#{Regexp.escape(pattern)}/\n    text.scan(regex)\n  end", "relevantFile": "app/validators/input_validator.rb", "relevantLinesEnd": 43, "suggestionContent": "The `find_matches` method interpolates user input directly into a regex pattern. An attacker can inject regex metacharacters or cause ReDoS with patterns like `(a+)+$`. Use `Regexp.escape` to sanitize the input.", "oneSentenceSummary": "Regex injection via unescaped user input enables ReDoS attacks", "relevantLinesStart": 40}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/report_generator.rb", "language": "Ruby", "fileContent": "class ReportGenerator\n  def generate_user_report\n    users = User.all\n    users.map do |user|\n      {\n        name: user.name,\n        email: user.email,\n        orders_count: user.orders.count,\n        total_spent: user.orders.sum(:total),\n        last_order: user.orders.last&.created_at\n      }\n    end\n  end\n\n  def generate_order_report\n    orders = Order.where(status: 'completed')\n    orders.map do |order|\n      {\n        id: order.id,\n        user_name: order.user.name,\n        user_email: order.user.email,\n        items: order.line_items.map { |li| li.product.name },\n        total: order.total\n      }\n    end\n  end\n\n  def list_posts_with_comments\n    posts = Post.recent\n    posts.map do |post|\n      {\n        title: post.title,\n        author: post.author.name,\n        comments_count: post.comments.count,\n        recent_comments: post.comments.limit(5).map do |comment|\n          { body: comment.body, author: comment.user.name }\n        end\n      }\n    end\n  end\n\n  def calculate_department_stats\n    departments = Department.all\n    departments.map do |dept|\n      employees = dept.employees\n      {\n        name: dept.name,\n        employee_count: employees.count,\n        total_salary: employees.sum(:salary),\n        avg_tenure: employees.average(:years_employed),\n        managers: employees.where(role: 'manager').pluck(:name)\n      }\n    end\n  end\n\n  def efficient_user_report\n    users = User.includes(:orders).all\n    users.map do |user|\n      {\n        name: user.name,\n        orders_count: user.orders.size\n      }\n    end\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/report_generator.rb'\n\n@@ -0,0 +1,66 @@\n__new hunk__\n1 +class ReportGenerator\n2 +  def generate_user_report\n3 +    users = User.all\n4 +    users.map do |user|\n5 +      {\n6 +        name: user.name,\n7 +        email: user.email,\n8 +        orders_count: user.orders.count,\n9 +        total_spent: user.orders.sum(:total),\n10 +        last_order: user.orders.last&.created_at\n11 +      }\n12 +    end\n13 +  end\n14 +\n15 +  def generate_order_report\n16 +    orders = Order.where(status: 'completed')\n17 +    orders.map do |order|\n18 +      {\n19 +        id: order.id,\n20 +        user_name: order.user.name,\n21 +        user_email: order.user.email,\n22 +        items: order.line_items.map { |li| li.product.name },\n23 +        total: order.total\n24 +      }\n25 +    end\n26 +  end\n27 +\n28 +  def list_posts_with_comments\n29 +    posts = Post.recent\n30 +    posts.map do |post|\n31 +      {\n32 +        title: post.title,\n33 +        author: post.author.name,\n34 +        comments_count: post.comments.count,\n35 +        recent_comments: post.comments.limit(5).map do |comment|\n36 +          { body: comment.body, author: comment.user.name }\n37 +        end\n38 +      }\n39 +    end\n40 +  end\n41 +\n42 +  def calculate_department_stats\n43 +    departments = Department.all\n44 +    departments.map do |dept|\n45 +      employees = dept.employees\n46 +      {\n47 +        name: dept.name,\n48 +        employee_count: employees.count,\n49 +        total_salary: employees.sum(:salary),\n50 +        avg_tenure: employees.average(:years_employed),\n51 +        managers: employees.where(role: 'manager').pluck(:name)\n52 +      }\n53 +    end\n54 +  end\n55 +\n56 +  def efficient_user_report\n57 +    users = User.includes(:orders).all\n58 +    users.map do |user|\n59 +      {\n60 +        name: user.name,\n61 +        orders_count: user.orders.size\n62 +      }\n63 +    end\n64 +  end\n65 +end\n66 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/services/report_generator.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "users = User.all\n    users.map do |user|\n      {\n        name: user.name,\n        email: user.email,\n        orders_count: user.orders.count,", "improvedCode": "users = User.left_joins(:orders)\n              .select('users.*, COUNT(orders.id) as orders_count, SUM(orders.total) as total_spent')\n              .group('users.id')\n    users.map do |user|\n      {\n        name: user.name,\n        email: user.email,\n        orders_count: user.orders_count,", "relevantFile": "app/services/report_generator.rb", "relevantLinesEnd": 8, "suggestionContent": "The `generate_user_report` method has an N+1 query problem. For each user, it makes 3 separate queries: `orders.count`, `orders.sum`, and `orders.last`. With 100 users, this results in 301 queries instead of 2. Use `includes` or aggregate in a single query.", "oneSentenceSummary": "N+1 query - 3 queries per user for orders data", "relevantLinesStart": 3}, {"label": "bug", "language": "Ruby", "existingCode": "orders = Order.where(status: 'completed')\n    orders.map do |order|\n      {\n        id: order.id,\n        user_name: order.user.name,\n        user_email: order.user.email,\n        items: order.line_items.map { |li| li.product.name },", "improvedCode": "orders = Order.where(status: 'completed')\n              .includes(:user, line_items: :product)\n    orders.map do |order|\n      {\n        id: order.id,\n        user_name: order.user.name,\n        user_email: order.user.email,\n        items: order.line_items.map { |li| li.product.name },", "relevantFile": "app/services/report_generator.rb", "relevantLinesEnd": 21, "suggestionContent": "The `generate_order_report` method has multiple N+1 issues: `order.user` (N queries), `order.line_items` (N queries), and `li.product` (N*M queries for each line item). This can result in thousands of queries for a moderate dataset.", "oneSentenceSummary": "Triple N+1 query - user, line_items, and products all queried separately", "relevantLinesStart": 15}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/controllers/downloads_controller.rb", "language": "Ruby", "fileContent": "class DownloadsController < ApplicationController\n  DOWNLOADS_DIR = Rails.root.join('public', 'downloads')\n\n  def show\n    filename = params[:filename]\n    filepath = File.join(DOWNLOADS_DIR, filename)\n\n    if File.exist?(filepath)\n      send_file filepath, disposition: 'attachment'\n    else\n      render plain: 'File not found', status: :not_found\n    end\n  end\n\n  def preview\n    filename = params[:filename]\n    filepath = \"#{DOWNLOADS_DIR}/#{filename}\"\n\n    render plain: File.read(filepath)\n  end\n\n  def delete\n    filename = params[:filename]\n    filepath = File.join(DOWNLOADS_DIR, filename)\n\n    File.delete(filepath) if File.exist?(filepath)\n    redirect_to downloads_path, notice: 'File deleted'\n  end\n\n  def upload\n    uploaded_file = params[:file]\n    filename = params[:filename] || uploaded_file.original_filename\n    filepath = File.join(DOWNLOADS_DIR, filename)\n\n    File.open(filepath, 'wb') do |file|\n      file.write(uploaded_file.read)\n    end\n\n    redirect_to downloads_path, notice: 'File uploaded'\n  end\n\n  def list\n    @files = Dir.glob(File.join(DOWNLOADS_DIR, '*')).map do |f|\n      File.basename(f)\n    end\n  end\n\n  def safe_download\n    filename = File.basename(params[:filename])\n    filepath = DOWNLOADS_DIR.join(filename)\n\n    if filepath.to_s.start_with?(DOWNLOADS_DIR.to_s) && File.exist?(filepath)\n      send_file filepath\n    else\n      head :not_found\n    end\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/controllers/downloads_controller.rb'\n\n@@ -0,0 +1,59 @@\n__new hunk__\n1 +class DownloadsController < ApplicationController\n2 +  DOWNLOADS_DIR = Rails.root.join('public', 'downloads')\n3 +\n4 +  def show\n5 +    filename = params[:filename]\n6 +    filepath = File.join(DOWNLOADS_DIR, filename)\n7 +\n8 +    if File.exist?(filepath)\n9 +      send_file filepath, disposition: 'attachment'\n10 +    else\n11 +      render plain: 'File not found', status: :not_found\n12 +    end\n13 +  end\n14 +\n15 +  def preview\n16 +    filename = params[:filename]\n17 +    filepath = \"#{DOWNLOADS_DIR}/#{filename}\"\n18 +\n19 +    render plain: File.read(filepath)\n20 +  end\n21 +\n22 +  def delete\n23 +    filename = params[:filename]\n24 +    filepath = File.join(DOWNLOADS_DIR, filename)\n25 +\n26 +    File.delete(filepath) if File.exist?(filepath)\n27 +    redirect_to downloads_path, notice: 'File deleted'\n28 +  end\n29 +\n30 +  def upload\n31 +    uploaded_file = params[:file]\n32 +    filename = params[:filename] || uploaded_file.original_filename\n33 +    filepath = File.join(DOWNLOADS_DIR, filename)\n34 +\n35 +    File.open(filepath, 'wb') do |file|\n36 +      file.write(uploaded_file.read)\n37 +    end\n38 +\n39 +    redirect_to downloads_path, notice: 'File uploaded'\n40 +  end\n41 +\n42 +  def list\n43 +    @files = Dir.glob(File.join(DOWNLOADS_DIR, '*')).map do |f|\n44 +      File.basename(f)\n45 +    end\n46 +  end\n47 +\n48 +  def safe_download\n49 +    filename = File.basename(params[:filename])\n50 +    filepath = DOWNLOADS_DIR.join(filename)\n51 +\n52 +    if filepath.to_s.start_with?(DOWNLOADS_DIR.to_s) && File.exist?(filepath)\n53 +      send_file filepath\n54 +    else\n55 +      head :not_found\n56 +    end\n57 +  end\n58 +end\n59 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/controllers/downloads_controller.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "filename = params[:filename]\n    filepath = File.join(DOWNLOADS_DIR, filename)\n\n    if File.exist?(filepath)\n      send_file filepath", "improvedCode": "filename = params[:filename]\n    filepath = File.expand_path(File.join(DOWNLOADS_DIR, filename))\n\n    unless filepath.start_with?(DOWNLOADS_DIR.to_s)\n      return head :forbidden\n    end\n\n    if File.exist?(filepath)\n      send_file filepath", "relevantFile": "app/controllers/downloads_controller.rb", "relevantLinesEnd": 9, "suggestionContent": "The `show` method is vulnerable to path traversal. An attacker can request `filename=../../../etc/passwd` to read any file on the system. `File.join` doesn't sanitize `..` sequences. Validate that the resolved path is within the allowed directory.", "oneSentenceSummary": "Path traversal allows reading arbitrary system files", "relevantLinesStart": 5}, {"label": "bug", "language": "Ruby", "existingCode": "filepath = File.join(DOWNLOADS_DIR, filename)\n\n    File.delete(filepath) if File.exist?(filepath)", "improvedCode": "filepath = File.expand_path(File.join(DOWNLOADS_DIR, filename))\n    return head :forbidden unless filepath.start_with?(DOWNLOADS_DIR.to_s)\n\n    File.delete(filepath) if File.exist?(filepath)", "relevantFile": "app/controllers/downloads_controller.rb", "relevantLinesEnd": 25, "suggestionContent": "The `delete` method has the same path traversal vulnerability, allowing deletion of arbitrary files. An attacker can delete critical system or application files.", "oneSentenceSummary": "Path traversal allows deleting arbitrary system files", "relevantLinesStart": 23}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/repositories/user_repository.rb", "language": "Ruby", "fileContent": "class UserRepository\n  def initialize(connection)\n    @connection = connection\n  end\n\n  def find_by_id(id)\n    result = @connection.execute(\"SELECT * FROM users WHERE id = $1\", [id])\n    result.first\n  end\n\n  def find_by_email(email)\n    query = \"SELECT * FROM users WHERE email = '#{email}'\"\n    result = @connection.execute(query)\n    result.first\n  end\n\n  def find_by_username(username)\n    query = \"SELECT * FROM users WHERE username = '#{username}'\"\n    result = @connection.execute(query)\n    result.first\n  end\n\n  def search_users(term, sort_by: 'created_at')\n    query = \"SELECT * FROM users WHERE name LIKE '%#{term}%' ORDER BY #{sort_by}\"\n    @connection.execute(query)\n  end\n\n  def authenticate(username, password)\n    query = \"SELECT * FROM users WHERE username = '#{username}' AND password_hash = '#{password}'\"\n    result = @connection.execute(query)\n    result.first\n  end\n\n  def delete_by_status(status)\n    query = \"DELETE FROM users WHERE status = '#{status}'\"\n    @connection.execute(query)\n  end\n\n  def update_role(user_id, role)\n    @connection.execute(\n      \"UPDATE users SET role = $1 WHERE id = $2\",\n      [role, user_id]\n    )\n  end\n\n  def count_by_role(role)\n    result = @connection.execute(\n      \"SELECT COUNT(*) FROM users WHERE role = $1\",\n      [role]\n    )\n    result.first['count'].to_i\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/repositories/user_repository.rb'\n\n@@ -0,0 +1,54 @@\n__new hunk__\n1 +class UserRepository\n2 +  def initialize(connection)\n3 +    @connection = connection\n4 +  end\n5 +\n6 +  def find_by_id(id)\n7 +    result = @connection.execute(\"SELECT * FROM users WHERE id = $1\", [id])\n8 +    result.first\n9 +  end\n10 +\n11 +  def find_by_email(email)\n12 +    query = \"SELECT * FROM users WHERE email = '#{email}'\"\n13 +    result = @connection.execute(query)\n14 +    result.first\n15 +  end\n16 +\n17 +  def find_by_username(username)\n18 +    query = \"SELECT * FROM users WHERE username = '#{username}'\"\n19 +    result = @connection.execute(query)\n20 +    result.first\n21 +  end\n22 +\n23 +  def search_users(term, sort_by: 'created_at')\n24 +    query = \"SELECT * FROM users WHERE name LIKE '%#{term}%' ORDER BY #{sort_by}\"\n25 +    @connection.execute(query)\n26 +  end\n27 +\n28 +  def authenticate(username, password)\n29 +    query = \"SELECT * FROM users WHERE username = '#{username}' AND password_hash = '#{password}'\"\n30 +    result = @connection.execute(query)\n31 +    result.first\n32 +  end\n33 +\n34 +  def delete_by_status(status)\n35 +    query = \"DELETE FROM users WHERE status = '#{status}'\"\n36 +    @connection.execute(query)\n37 +  end\n38 +\n39 +  def update_role(user_id, role)\n40 +    @connection.execute(\n41 +      \"UPDATE users SET role = $1 WHERE id = $2\",\n42 +      [role, user_id]\n43 +    )\n44 +  end\n45 +\n46 +  def count_by_role(role)\n47 +    result = @connection.execute(\n48 +      \"SELECT COUNT(*) FROM users WHERE role = $1\",\n49 +      [role]\n50 +    )\n51 +    result.first['count'].to_i\n52 +  end\n53 +end\n54 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/repositories/user_repository.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "query = \"SELECT * FROM users WHERE email = '\\#{email}'\"", "improvedCode": "result = @connection.execute(\"SELECT * FROM users WHERE email = $1\", [email])", "relevantFile": "app/repositories/user_repository.rb", "relevantLinesEnd": 12, "suggestionContent": "The `find_by_email` method uses string interpolation to build SQL query. An attacker can input `' OR '1'='1` to retrieve all users or `'; DROP TABLE users; --` to delete data. Use parameterized queries with placeholders.", "oneSentenceSummary": "SQL injection via string interpolation in email lookup", "relevantLinesStart": 12}, {"label": "bug", "language": "Ruby", "existingCode": "query = \"SELECT * FROM users WHERE name LIKE '%\\#{term}%' ORDER BY \\#{sort_by}\"", "improvedCode": "allowed_sorts = %w[created_at name email]\nraise ArgumentError unless allowed_sorts.include?(sort_by)\nquery = \"SELECT * FROM users WHERE name LIKE $1 ORDER BY \\#{sort_by}\"\n@connection.execute(query, [\"%\\#{term}%\"])", "relevantFile": "app/repositories/user_repository.rb", "relevantLinesEnd": 24, "suggestionContent": "The `search_users` method has two SQL injection vulnerabilities: `term` and `sort_by` are both interpolated. The `sort_by` parameter is particularly dangerous as ORDER BY cannot be parameterized and needs allowlist validation.", "oneSentenceSummary": "SQL injection in search - both term and sort_by are injectable", "relevantLinesStart": 24}, {"label": "bug", "language": "Ruby", "existingCode": "query = \"SELECT * FROM users WHERE username = '\\#{username}' AND password_hash = '\\#{password}'\"", "improvedCode": "result = @connection.execute(\n  \"SELECT * FROM users WHERE username = $1 AND password_hash = $2\",\n  [username, password]\n)", "relevantFile": "app/repositories/user_repository.rb", "relevantLinesEnd": 28, "suggestionContent": "The `authenticate` method interpolates both username and password into SQL, enabling authentication bypass. An attacker can login as any user with `admin' --` as username.", "oneSentenceSummary": "SQL injection in authentication allows login bypass", "relevantLinesStart": 28}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/scheduler_service.rb", "language": "Ruby", "fileContent": "class SchedulerService\n  def initialize\n    @scheduled_tasks = []\n  end\n\n  def schedule_at(task, datetime_string)\n    scheduled_time = Time.parse(datetime_string)\n    @scheduled_tasks << { task: task, time: scheduled_time }\n  end\n\n  def schedule_for_tomorrow(task)\n    tomorrow = Date.today + 1\n    scheduled_time = Time.new(tomorrow.year, tomorrow.month, tomorrow.day, 9, 0, 0)\n    @scheduled_tasks << { task: task, time: scheduled_time }\n  end\n\n  def is_past_due?(scheduled_time)\n    scheduled_time < Time.now\n  end\n\n  def tasks_for_today\n    today = Date.today\n    @scheduled_tasks.select do |task|\n      task[:time].to_date == today\n    end\n  end\n\n  def calculate_duration(start_time, end_time)\n    (end_time - start_time) / 3600.0 # hours\n  end\n\n  def next_weekday(from_date = Date.today)\n    date = from_date + 1\n    date += 1 while date.saturday? || date.sunday?\n    date\n  end\n\n  def format_time(time)\n    time.strftime('%Y-%m-%d %H:%M:%S')\n  end\n\n  def parse_user_time(time_string, user_timezone)\n    Time.parse(time_string)\n  end\n\n  def utc_to_local(utc_time, timezone)\n    utc_time + timezone_offset(timezone)\n  end\n\n  private\n\n  def timezone_offset(timezone)\n    # Simplified offset calculation\n    offsets = { 'EST' => -5, 'PST' => -8, 'UTC' => 0 }\n    (offsets[timezone] || 0) * 3600\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/scheduler_service.rb'\n\n@@ -0,0 +1,58 @@\n__new hunk__\n1 +class SchedulerService\n2 +  def initialize\n3 +    @scheduled_tasks = []\n4 +  end\n5 +\n6 +  def schedule_at(task, datetime_string)\n7 +    scheduled_time = Time.parse(datetime_string)\n8 +    @scheduled_tasks << { task: task, time: scheduled_time }\n9 +  end\n10 +\n11 +  def schedule_for_tomorrow(task)\n12 +    tomorrow = Date.today + 1\n13 +    scheduled_time = Time.new(tomorrow.year, tomorrow.month, tomorrow.day, 9, 0, 0)\n14 +    @scheduled_tasks << { task: task, time: scheduled_time }\n15 +  end\n16 +\n17 +  def is_past_due?(scheduled_time)\n18 +    scheduled_time < Time.now\n19 +  end\n20 +\n21 +  def tasks_for_today\n22 +    today = Date.today\n23 +    @scheduled_tasks.select do |task|\n24 +      task[:time].to_date == today\n25 +    end\n26 +  end\n27 +\n28 +  def calculate_duration(start_time, end_time)\n29 +    (end_time - start_time) / 3600.0 # hours\n30 +  end\n31 +\n32 +  def next_weekday(from_date = Date.today)\n33 +    date = from_date + 1\n34 +    date += 1 while date.saturday? || date.sunday?\n35 +    date\n36 +  end\n37 +\n38 +  def format_time(time)\n39 +    time.strftime('%Y-%m-%d %H:%M:%S')\n40 +  end\n41 +\n42 +  def parse_user_time(time_string, user_timezone)\n43 +    Time.parse(time_string)\n44 +  end\n45 +\n46 +  def utc_to_local(utc_time, timezone)\n47 +    utc_time + timezone_offset(timezone)\n48 +  end\n49 +\n50 +  private\n51 +\n52 +  def timezone_offset(timezone)\n53 +    # Simplified offset calculation\n54 +    offsets = { 'EST' => -5, 'PST' => -8, 'UTC' => 0 }\n55 +    (offsets[timezone] || 0) * 3600\n56 +  end\n57 +end\n58 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/scheduler_service.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "scheduled_time = Time.parse(datetime_string)", "improvedCode": "scheduled_time = Time.zone.parse(datetime_string)", "relevantFile": "app/services/scheduler_service.rb", "relevantLinesEnd": 7, "suggestionContent": "The `schedule_at` method uses `Time.parse` which parses in the local timezone without explicit zone handling. If the server timezone differs from user timezone, tasks will be scheduled at wrong times. Use `Time.zone.parse` in Rails or explicitly handle timezones.", "oneSentenceSummary": "Time.parse ignores timezone - schedules tasks at wrong times", "relevantLinesStart": 7}, {"label": "bug", "language": "Ruby", "existingCode": "def is_past_due?(scheduled_time)\n    scheduled_time < Time.now\n  end", "improvedCode": "def is_past_due?(scheduled_time)\n    scheduled_time < Time.current  # Rails timezone-aware\n  end", "relevantFile": "app/services/scheduler_service.rb", "relevantLinesEnd": 18, "suggestionContent": "The `is_past_due?` method compares times but mixes `Time.now` (local time) with potentially UTC times. If `scheduled_time` is in UTC and `Time.now` is in local time, comparisons will be incorrect by the timezone offset.", "oneSentenceSummary": "Comparing times without timezone awareness gives wrong results", "relevantLinesStart": 16}, {"label": "bug", "language": "Ruby", "existingCode": "def parse_user_time(time_string, user_timezone)\n    Time.parse(time_string)\n  end", "improvedCode": "def parse_user_time(time_string, user_timezone)\n    Time.use_zone(user_timezone) { Time.zone.parse(time_string) }\n  end", "relevantFile": "app/services/scheduler_service.rb", "relevantLinesEnd": 42, "suggestionContent": "The `parse_user_time` method ignores the `user_timezone` parameter entirely and parses in local time. User times will be interpreted in server timezone instead of user's timezone.", "oneSentenceSummary": "User timezone parameter ignored - times parsed in server timezone", "relevantLinesStart": 40}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/payment_processor.rb", "language": "Ruby", "fileContent": "class PaymentProcessor\n  class PaymentError < StandardError; end\n  class InsufficientFundsError < PaymentError; end\n  class InvalidCardError < PaymentError; end\n\n  def initialize(gateway)\n    @gateway = gateway\n    @logger = Rails.logger\n  end\n\n  def process_payment(amount, card_details)\n    validate_card(card_details)\n\n    begin\n      result = @gateway.charge(amount, card_details)\n      @logger.info(\"Payment processed: #{amount}\")\n      result\n    rescue\n      @logger.error(\"Payment failed\")\n      nil\n    end\n  end\n\n  def refund(transaction_id, amount)\n    begin\n      @gateway.refund(transaction_id, amount)\n    rescue => e\n      @logger.error(\"Refund failed: #{e.message}\")\n      raise\n    end\n  end\n\n  def batch_process(payments)\n    results = []\n    payments.each do |payment|\n      begin\n        result = process_payment(payment[:amount], payment[:card])\n        results << { status: 'success', result: result }\n      rescue Exception => e\n        results << { status: 'failed', error: e.message }\n      end\n    end\n    results\n  end\n\n  def validate_card(card_details)\n    raise InvalidCardError, \"Card number required\" if card_details[:number].nil?\n    raise InvalidCardError, \"Invalid card number\" unless valid_card_number?(card_details[:number])\n  end\n\n  def check_balance(account_id)\n    begin\n      @gateway.get_balance(account_id)\n    rescue\n      0\n    end\n  end\n\n  private\n\n  def valid_card_number?(number)\n    number.to_s.length >= 13 && number.to_s.length <= 19\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/payment_processor.rb'\n\n@@ -0,0 +1,65 @@\n__new hunk__\n1 +class PaymentProcessor\n2 +  class PaymentError < StandardError; end\n3 +  class InsufficientFundsError < PaymentError; end\n4 +  class InvalidCardError < PaymentError; end\n5 +\n6 +  def initialize(gateway)\n7 +    @gateway = gateway\n8 +    @logger = Rails.logger\n9 +  end\n10 +\n11 +  def process_payment(amount, card_details)\n12 +    validate_card(card_details)\n13 +\n14 +    begin\n15 +      result = @gateway.charge(amount, card_details)\n16 +      @logger.info(\"Payment processed: #{amount}\")\n17 +      result\n18 +    rescue\n19 +      @logger.error(\"Payment failed\")\n20 +      nil\n21 +    end\n22 +  end\n23 +\n24 +  def refund(transaction_id, amount)\n25 +    begin\n26 +      @gateway.refund(transaction_id, amount)\n27 +    rescue => e\n28 +      @logger.error(\"Refund failed: #{e.message}\")\n29 +      raise\n30 +    end\n31 +  end\n32 +\n33 +  def batch_process(payments)\n34 +    results = []\n35 +    payments.each do |payment|\n36 +      begin\n37 +        result = process_payment(payment[:amount], payment[:card])\n38 +        results << { status: 'success', result: result }\n39 +      rescue Exception => e\n40 +        results << { status: 'failed', error: e.message }\n41 +      end\n42 +    end\n43 +    results\n44 +  end\n45 +\n46 +  def validate_card(card_details)\n47 +    raise InvalidCardError, \"Card number required\" if card_details[:number].nil?\n48 +    raise InvalidCardError, \"Invalid card number\" unless valid_card_number?(card_details[:number])\n49 +  end\n50 +\n51 +  def check_balance(account_id)\n52 +    begin\n53 +      @gateway.get_balance(account_id)\n54 +    rescue\n55 +      0\n56 +    end\n57 +  end\n58 +\n59 +  private\n60 +\n61 +  def valid_card_number?(number)\n62 +    number.to_s.length >= 13 && number.to_s.length <= 19\n63 +  end\n64 +end\n65 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/payment_processor.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "rescue\n      @logger.error(\"Payment failed\")\n      nil", "improvedCode": "rescue PaymentError => e\n      @logger.error(\"Payment failed: \\#{e.message}\")\n      raise", "relevantFile": "app/services/payment_processor.rb", "relevantLinesEnd": 20, "suggestionContent": "The `process_payment` method uses bare `rescue` without specifying an exception type. This catches `StandardError` by default but the intention is unclear, and it silently returns nil, hiding all errors. Always specify the exception type and handle appropriately.", "oneSentenceSummary": "Bare rescue catches all StandardErrors and silently returns nil", "relevantLinesStart": 18}, {"label": "bug", "language": "Ruby", "existingCode": "rescue Exception => e\n        results << { status: 'failed', error: e.message }", "improvedCode": "rescue StandardError => e\n        results << { status: 'failed', error: e.message }", "relevantFile": "app/services/payment_processor.rb", "relevantLinesEnd": 40, "suggestionContent": "The `batch_process` method rescues `Exception` which is too broad - it catches system exceptions like `SignalException`, `NoMemoryError`, and `SystemExit`. This prevents graceful shutdown and can hide critical errors. Rescue `StandardError` instead.", "oneSentenceSummary": "Rescuing Exception catches system signals and prevents graceful shutdown", "relevantLinesStart": 39}, {"label": "bug", "language": "Ruby", "existingCode": "rescue\n      0", "improvedCode": "rescue StandardError => e\n      @logger.error(\"Balance check failed: \\#{e.message}\")\n      raise", "relevantFile": "app/services/payment_processor.rb", "relevantLinesEnd": 54, "suggestionContent": "The `check_balance` method has bare `rescue` that returns 0 on any error. This silently hides connection errors, authentication failures, and other issues. Returning 0 for a failed balance check could lead to incorrect business decisions.", "oneSentenceSummary": "Bare rescue returns 0 hiding connection and auth errors", "relevantLinesStart": 53}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/data_pipeline.rb", "language": "Ruby", "fileContent": "class DataPipeline\n  def initialize(data_source)\n    @data_source = data_source\n  end\n\n  def process_records\n    records = @data_source.each\n    processed = records.map { |r| transform(r) }\n    processed.select { |r| r[:valid] }\n  end\n\n  def filter_large_dataset\n    @data_source.lazy.select { |r| r[:active] }\n  end\n\n  def get_first_valid(records)\n    filtered = records.lazy.select { |r| valid?(r) }\n    filtered.first\n  end\n\n  def process_in_batches(records, batch_size: 100)\n    batches = records.each_slice(batch_size)\n\n    batches.map do |batch|\n      process_batch(batch)\n    end\n  end\n\n  def chain_operations(records)\n    result = records.lazy\n      .map { |r| enrich(r) }\n      .select { |r| r[:score] > 50 }\n      .take(10)\n\n    result\n  end\n\n  def count_matches(records)\n    records.lazy\n      .select { |r| r[:type] == 'premium' }\n      .count\n  end\n\n  def to_hash_map(records)\n    records.lazy\n      .map { |r| [r[:id], r] }\n      .to_h\n  end\n\n  def force_evaluation(records)\n    records.lazy\n      .map { |r| expensive_transform(r) }\n      .to_a\n  end\n\n  private\n\n  def transform(record)\n    record.merge(transformed: true, valid: record[:data].present?)\n  end\n\n  def valid?(record)\n    record[:status] == 'active' && record[:data].present?\n  end\n\n  def process_batch(batch)\n    batch.map { |r| transform(r) }\n  end\n\n  def enrich(record)\n    record.merge(score: calculate_score(record))\n  end\n\n  def calculate_score(record)\n    record[:value].to_i * 10\n  end\n\n  def expensive_transform(record)\n    sleep(0.01) # Simulate expensive operation\n    record.merge(processed: true)\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/data_pipeline.rb'\n\n@@ -0,0 +1,83 @@\n__new hunk__\n1 +class DataPipeline\n2 +  def initialize(data_source)\n3 +    @data_source = data_source\n4 +  end\n5 +\n6 +  def process_records\n7 +    records = @data_source.each\n8 +    processed = records.map { |r| transform(r) }\n9 +    processed.select { |r| r[:valid] }\n10 +  end\n11 +\n12 +  def filter_large_dataset\n13 +    @data_source.lazy.select { |r| r[:active] }\n14 +  end\n15 +\n16 +  def get_first_valid(records)\n17 +    filtered = records.lazy.select { |r| valid?(r) }\n18 +    filtered.first\n19 +  end\n20 +\n21 +  def process_in_batches(records, batch_size: 100)\n22 +    batches = records.each_slice(batch_size)\n23 +\n24 +    batches.map do |batch|\n25 +      process_batch(batch)\n26 +    end\n27 +  end\n28 +\n29 +  def chain_operations(records)\n30 +    result = records.lazy\n31 +      .map { |r| enrich(r) }\n32 +      .select { |r| r[:score] > 50 }\n33 +      .take(10)\n34 +\n35 +    result\n36 +  end\n37 +\n38 +  def count_matches(records)\n39 +    records.lazy\n40 +      .select { |r| r[:type] == 'premium' }\n41 +      .count\n42 +  end\n43 +\n44 +  def to_hash_map(records)\n45 +    records.lazy\n46 +      .map { |r| [r[:id], r] }\n47 +      .to_h\n48 +  end\n49 +\n50 +  def force_evaluation(records)\n51 +    records.lazy\n52 +      .map { |r| expensive_transform(r) }\n53 +      .to_a\n54 +  end\n55 +\n56 +  private\n57 +\n58 +  def transform(record)\n59 +    record.merge(transformed: true, valid: record[:data].present?)\n60 +  end\n61 +\n62 +  def valid?(record)\n63 +    record[:status] == 'active' && record[:data].present?\n64 +  end\n65 +\n66 +  def process_batch(batch)\n67 +    batch.map { |r| transform(r) }\n68 +  end\n69 +\n70 +  def enrich(record)\n71 +    record.merge(score: calculate_score(record))\n72 +  end\n73 +\n74 +  def calculate_score(record)\n75 +    record[:value].to_i * 10\n76 +  end\n77 +\n78 +  def expensive_transform(record)\n79 +    sleep(0.01) # Simulate expensive operation\n80 +    record.merge(processed: true)\n81 +  end\n82 +end\n83 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/data_pipeline.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def filter_large_dataset\n    @data_source.lazy.select { |r| r[:active] }\n  end", "improvedCode": "def filter_large_dataset\n    @data_source.lazy.select { |r| r[:active] }.to_a\n  end\n  # Or document: # @return [Enumerator::Lazy] lazy enumerator, caller must force evaluation", "relevantFile": "app/services/data_pipeline.rb", "relevantLinesEnd": 14, "suggestionContent": "The `filter_large_dataset` method returns a lazy enumerator without forcing evaluation. The caller receives an unevaluated lazy enumerator, and if `@data_source` is a database cursor or file handle that gets closed, iterating will fail. Either force with `.to_a` or document that it returns a lazy enumerator.", "oneSentenceSummary": "Lazy enumerator returned without evaluation - data source may close", "relevantLinesStart": 12}, {"label": "bug", "language": "Ruby", "existingCode": "result = records.lazy\n      .map { |r| enrich(r) }\n      .select { |r| r[:score] > 50 }\n      .take(10)\n\n    result\n  end", "improvedCode": "result = records.lazy\n      .map { |r| enrich(r) }\n      .select { |r| r[:score] > 50 }\n      .take(10)\n      .to_a  # Force evaluation\n\n    result\n  end", "relevantFile": "app/services/data_pipeline.rb", "relevantLinesEnd": 34, "suggestionContent": "The `chain_operations` method returns an unevaluated lazy enumerator. The `take(10)` doesn't force evaluation - it returns another lazy enumerator. If the result is used multiple times, each use re-executes the entire chain from the beginning.", "oneSentenceSummary": "Lazy chain returns unevaluated - recomputes on each access", "relevantLinesStart": 28}, {"label": "bug", "language": "Ruby", "existingCode": "def count_matches(records)\n    records.lazy\n      .select { |r| r[:type] == 'premium' }\n      .count\n  end", "improvedCode": "def count_matches(records)\n    records.count { |r| r[:type] == 'premium' }\n  end", "relevantFile": "app/services/data_pipeline.rb", "relevantLinesEnd": 40, "suggestionContent": "The `count_matches` method calls `.count` on a lazy enumerator. While this works, it forces full iteration and defeats the purpose of lazy evaluation. If the intent was lazy, use `.size` with caution or reconsider the approach. If eager count is intended, don't use `.lazy`.", "oneSentenceSummary": "Lazy enumeration with count is inefficient - forces full iteration anyway", "relevantLinesStart": 36}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/dynamic_executor.rb", "language": "Ruby", "fileContent": "class DynamicExecutor\n  ALLOWED_METHODS = %w[process transform validate].freeze\n\n  def initialize(context = {})\n    @context = context\n  end\n\n  def execute_expression(expression)\n    eval(expression)\n  end\n\n  def execute_with_binding(expression, local_vars = {})\n    b = binding\n    local_vars.each do |name, value|\n      b.local_variable_set(name, value)\n    end\n    eval(expression, b)\n  end\n\n  def call_method(object, method_name, *args)\n    object.send(method_name, *args)\n  end\n\n  def call_method_safe(object, method_name, *args)\n    if ALLOWED_METHODS.include?(method_name.to_s)\n      object.send(method_name, *args)\n    else\n      raise \"Method not allowed: #{method_name}\"\n    end\n  end\n\n  def process_template(template, data)\n    result = template.dup\n    data.each do |key, value|\n      result.gsub!(\"\\#{#{key}}\", value.to_s)\n    end\n    eval(%Q{\"#{result}\"})\n  end\n\n  def build_query(params)\n    conditions = params.map do |key, value|\n      \"#{key} = '#{value}'\"\n    end\n    conditions.join(' AND ')\n  end\n\n  def instantiate_class(class_name, *args)\n    klass = Object.const_get(class_name)\n    klass.new(*args)\n  end\n\n  def execute_callback(callback_name, *args)\n    method(callback_name).call(*args)\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/dynamic_executor.rb'\n\n@@ -0,0 +1,56 @@\n__new hunk__\n1 +class DynamicExecutor\n2 +  ALLOWED_METHODS = %w[process transform validate].freeze\n3 +\n4 +  def initialize(context = {})\n5 +    @context = context\n6 +  end\n7 +\n8 +  def execute_expression(expression)\n9 +    eval(expression)\n10 +  end\n11 +\n12 +  def execute_with_binding(expression, local_vars = {})\n13 +    b = binding\n14 +    local_vars.each do |name, value|\n15 +      b.local_variable_set(name, value)\n16 +    end\n17 +    eval(expression, b)\n18 +  end\n19 +\n20 +  def call_method(object, method_name, *args)\n21 +    object.send(method_name, *args)\n22 +  end\n23 +\n24 +  def call_method_safe(object, method_name, *args)\n25 +    if ALLOWED_METHODS.include?(method_name.to_s)\n26 +      object.send(method_name, *args)\n27 +    else\n28 +      raise \"Method not allowed: #{method_name}\"\n29 +    end\n30 +  end\n31 +\n32 +  def process_template(template, data)\n33 +    result = template.dup\n34 +    data.each do |key, value|\n35 +      result.gsub!(\"\\#{#{key}}\", value.to_s)\n36 +    end\n37 +    eval(%Q{\"#{result}\"})\n38 +  end\n39 +\n40 +  def build_query(params)\n41 +    conditions = params.map do |key, value|\n42 +      \"#{key} = '#{value}'\"\n43 +    end\n44 +    conditions.join(' AND ')\n45 +  end\n46 +\n47 +  def instantiate_class(class_name, *args)\n48 +    klass = Object.const_get(class_name)\n49 +    klass.new(*args)\n50 +  end\n51 +\n52 +  def execute_callback(callback_name, *args)\n53 +    method(callback_name).call(*args)\n54 +  end\n55 +end\n56 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in app/services/dynamic_executor.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "def execute_expression(expression)\n    eval(expression)\n  end", "improvedCode": "# Remove this method entirely - eval on user input is never safe\n  # Use a proper expression parser or DSL instead", "relevantFile": "app/services/dynamic_executor.rb", "relevantLinesEnd": 10, "suggestionContent": "The `execute_expression` method uses `eval` on arbitrary input. An attacker can execute any Ruby code, including `system('rm -rf /')` or accessing sensitive data. Never use `eval` on user input.", "oneSentenceSummary": "eval on user input allows arbitrary code execution", "relevantLinesStart": 8}, {"label": "bug", "language": "Ruby", "existingCode": "def call_method(object, method_name, *args)\n    object.send(method_name, *args)\n  end", "improvedCode": "def call_method(object, method_name, *args)\n    raise \"Method not allowed\" unless ALLOWED_METHODS.include?(method_name.to_s)\n    object.public_send(method_name, *args)\n  end", "relevantFile": "app/services/dynamic_executor.rb", "relevantLinesEnd": 22, "suggestionContent": "The `call_method` method uses `send` which can call any method including private methods and dangerous ones like `instance_eval`, `system`, or `exit`. Use `public_send` and validate against an allowlist.", "oneSentenceSummary": "send can call private methods and dangerous system methods", "relevantLinesStart": 20}, {"label": "bug", "language": "Ruby", "existingCode": "def instantiate_class(class_name, *args)\n    klass = Object.const_get(class_name)\n    klass.new(*args)\n  end", "improvedCode": "ALLOWED_CLASSES = %w[User Order Product].freeze\n\n  def instantiate_class(class_name, *args)\n    raise \"Class not allowed\" unless ALLOWED_CLASSES.include?(class_name)\n    klass = Object.const_get(class_name)\n    klass.new(*args)\n  end", "relevantFile": "app/services/dynamic_executor.rb", "relevantLinesEnd": 49, "suggestionContent": "The `instantiate_class` method uses `Object.const_get` with user input, allowing instantiation of any class. An attacker can instantiate `File`, `Dir`, or other dangerous classes to access the filesystem.", "oneSentenceSummary": "const_get allows instantiating arbitrary classes for filesystem access", "relevantLinesStart": 46}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "app/services/task_manager.rb", "language": "Ruby", "fileContent": "class TaskManager\n  def initialize\n    @tasks = []\n    @completed = []\n  end\n\n  def add_task(task)\n    @tasks << task\n  end\n\n  def remove_completed_tasks\n    @tasks.each do |task|\n      if task[:status] == 'completed'\n        @tasks.delete(task)\n        @completed << task\n      end\n    end\n  end\n\n  def process_and_remove\n    @tasks.each do |task|\n      result = process_task(task)\n      if result[:success]\n        @tasks.delete(task)\n      end\n    end\n  end\n\n  def filter_by_priority(min_priority)\n    @tasks.each do |task|\n      @tasks.delete(task) if task[:priority] < min_priority\n    end\n  end\n\n  def cleanup_old_tasks(max_age)\n    cutoff = Time.current - max_age\n    @tasks.each_with_index do |task, index|\n      if task[:created_at] < cutoff\n        @tasks.delete_at(index)\n      end\n    end\n  end\n\n  def get_pending_tasks\n    @tasks.select { |t| t[:status] == 'pending' }\n  end\n\n  def mark_complete(task_id)\n    task = @tasks.find { |t| t[:id] == task_id }\n    task[:status] = 'completed' if task\n  end\n\n  def safe_cleanup\n    @tasks.reject! { |task| task[:status] == 'completed' }\n  end\n\n  private\n\n  def process_task(task)\n    # Processing logic\n    { success: rand > 0.5 }\n  end\nend\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'app/services/task_manager.rb'\n\n@@ -0,0 +1,64 @@\n__new hunk__\n1 +class TaskManager\n2 +  def initialize\n3 +    @tasks = []\n4 +    @completed = []\n5 +  end\n6 +\n7 +  def add_task(task)\n8 +    @tasks << task\n9 +  end\n10 +\n11 +  def remove_completed_tasks\n12 +    @tasks.each do |task|\n13 +      if task[:status] == 'completed'\n14 +        @tasks.delete(task)\n15 +        @completed << task\n16 +      end\n17 +    end\n18 +  end\n19 +\n20 +  def process_and_remove\n21 +    @tasks.each do |task|\n22 +      result = process_task(task)\n23 +      if result[:success]\n24 +        @tasks.delete(task)\n25 +      end\n26 +    end\n27 +  end\n28 +\n29 +  def filter_by_priority(min_priority)\n30 +    @tasks.each do |task|\n31 +      @tasks.delete(task) if task[:priority] < min_priority\n32 +    end\n33 +  end\n34 +\n35 +  def cleanup_old_tasks(max_age)\n36 +    cutoff = Time.current - max_age\n37 +    @tasks.each_with_index do |task, index|\n38 +      if task[:created_at] < cutoff\n39 +        @tasks.delete_at(index)\n40 +      end\n41 +    end\n42 +  end\n43 +\n44 +  def get_pending_tasks\n45 +    @tasks.select { |t| t[:status] == 'pending' }\n46 +  end\n47 +\n48 +  def mark_complete(task_id)\n49 +    task = @tasks.find { |t| t[:id] == task_id }\n50 +    task[:status] = 'completed' if task\n51 +  end\n52 +\n53 +  def safe_cleanup\n54 +    @tasks.reject! { |task| task[:status] == 'completed' }\n55 +  end\n56 +\n57 +  private\n58 +\n59 +  def process_task(task)\n60 +    # Processing logic\n61 +    { success: rand > 0.5 }\n62 +  end\n63 +end\n64 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in app/services/task_manager.rb", "codeSuggestions": [{"label": "bug", "language": "Ruby", "existingCode": "@tasks.each do |task|\n      if task[:status] == 'completed'\n        @tasks.delete(task)\n        @completed << task\n      end\n    end", "improvedCode": "completed_tasks, @tasks = @tasks.partition { |task| task[:status] == 'completed' }\n    @completed.concat(completed_tasks)", "relevantFile": "app/services/task_manager.rb", "relevantLinesEnd": 17, "suggestionContent": "The `remove_completed_tasks` method modifies `@tasks` array while iterating over it with `each`. In Ruby, this causes elements to be skipped because indices shift after deletion. For example, if tasks[0] is deleted, tasks[1] becomes tasks[0], but the iterator moves to index 1, skipping the element.", "oneSentenceSummary": "Array modification during each iteration skips elements", "relevantLinesStart": 12}, {"label": "bug", "language": "Ruby", "existingCode": "@tasks.each_with_index do |task, index|\n      if task[:created_at] < cutoff\n        @tasks.delete_at(index)\n      end\n    end", "improvedCode": "@tasks.reject! { |task| task[:created_at] < cutoff }", "relevantFile": "app/services/task_manager.rb", "relevantLinesEnd": 39, "suggestionContent": "The `cleanup_old_tasks` method uses `delete_at(index)` while iterating with `each_with_index`. After deleting at index 0, all subsequent indices are off by one, causing elements to be skipped or wrong elements to be deleted.", "oneSentenceSummary": "delete_at during each_with_index corrupts iteration indices", "relevantLinesStart": 35}]}}, "metadata" : {}}
