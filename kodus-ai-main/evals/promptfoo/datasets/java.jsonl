{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/analytics/MetricsCalculator.java", "language": "Java", "fileContent": "package com.app.analytics;\n\nimport java.util.*;\n\npublic class MetricsCalculator {\n\n    public Long sumValues(List<Long> values) {\n        Long sum = 0L;\n        for (Long value : values) {\n            sum += value;\n        }\n        return sum;\n    }\n\n    public Double calculateAverage(List<Integer> numbers) {\n        if (numbers.isEmpty()) {\n            return 0.0;\n        }\n\n        Integer sum = 0;\n        for (Integer num : numbers) {\n            sum += num;\n        }\n\n        return sum.doubleValue() / numbers.size();\n    }\n\n    public Integer findMax(int[] values) {\n        Integer max = Integer.MIN_VALUE;\n        for (int i = 0; i < values.length; i++) {\n            if (values[i] > max) {\n                max = values[i];\n            }\n        }\n        return max;\n    }\n\n    public Map<String, Long> countOccurrences(List<String> items) {\n        Map<String, Long> counts = new HashMap<>();\n        for (String item : items) {\n            Long current = counts.getOrDefault(item, 0L);\n            counts.put(item, current + 1);\n        }\n        return counts;\n    }\n\n    public Double calculatePercentile(List<Double> values, int percentile) {\n        if (values.isEmpty()) {\n            return 0.0;\n        }\n\n        Collections.sort(values);\n        Integer index = (int) Math.ceil(percentile / 100.0 * values.size()) - 1;\n        return values.get(Math.max(0, index));\n    }\n\n    public List<Integer> filterAboveThreshold(List<Integer> values, Integer threshold) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer value : values) {\n            if (value > threshold) {\n                result.add(value);\n            }\n        }\n        return result;\n    }\n\n    public Double standardDeviation(List<Double> values) {\n        Double avg = values.stream().mapToDouble(d -> d).average().orElse(0.0);\n        Double sumSquares = 0.0;\n\n        for (Double value : values) {\n            Double diff = value - avg;\n            sumSquares += diff * diff;\n        }\n\n        return Math.sqrt(sumSquares / values.size());\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/analytics/MetricsCalculator.java'\n\n@@ -0,0 +1,79 @@\n__new hunk__\n1 +package com.app.analytics;\n2 +\n3 +import java.util.*;\n4 +\n5 +public class MetricsCalculator {\n6 +\n7 +    public Long sumValues(List<Long> values) {\n8 +        Long sum = 0L;\n9 +        for (Long value : values) {\n10 +            sum += value;\n11 +        }\n12 +        return sum;\n13 +    }\n14 +\n15 +    public Double calculateAverage(List<Integer> numbers) {\n16 +        if (numbers.isEmpty()) {\n17 +            return 0.0;\n18 +        }\n19 +\n20 +        Integer sum = 0;\n21 +        for (Integer num : numbers) {\n22 +            sum += num;\n23 +        }\n24 +\n25 +        return sum.doubleValue() / numbers.size();\n26 +    }\n27 +\n28 +    public Integer findMax(int[] values) {\n29 +        Integer max = Integer.MIN_VALUE;\n30 +        for (int i = 0; i < values.length; i++) {\n31 +            if (values[i] > max) {\n32 +                max = values[i];\n33 +            }\n34 +        }\n35 +        return max;\n36 +    }\n37 +\n38 +    public Map<String, Long> countOccurrences(List<String> items) {\n39 +        Map<String, Long> counts = new HashMap<>();\n40 +        for (String item : items) {\n41 +            Long current = counts.getOrDefault(item, 0L);\n42 +            counts.put(item, current + 1);\n43 +        }\n44 +        return counts;\n45 +    }\n46 +\n47 +    public Double calculatePercentile(List<Double> values, int percentile) {\n48 +        if (values.isEmpty()) {\n49 +            return 0.0;\n50 +        }\n51 +\n52 +        Collections.sort(values);\n53 +        Integer index = (int) Math.ceil(percentile / 100.0 * values.size()) - 1;\n54 +        return values.get(Math.max(0, index));\n55 +    }\n56 +\n57 +    public List<Integer> filterAboveThreshold(List<Integer> values, Integer threshold) {\n58 +        List<Integer> result = new ArrayList<>();\n59 +        for (Integer value : values) {\n60 +            if (value > threshold) {\n61 +                result.add(value);\n62 +            }\n63 +        }\n64 +        return result;\n65 +    }\n66 +\n67 +    public Double standardDeviation(List<Double> values) {\n68 +        Double avg = values.stream().mapToDouble(d -> d).average().orElse(0.0);\n69 +        Double sumSquares = 0.0;\n70 +\n71 +        for (Double value : values) {\n72 +            Double diff = value - avg;\n73 +            sumSquares += diff * diff;\n74 +        }\n75 +\n76 +        return Math.sqrt(sumSquares / values.size());\n77 +    }\n78 +}\n79 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in src/main/java/com/app/analytics/MetricsCalculator.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "public Long sumValues(List<Long> values) {\n        Long sum = 0L;\n        for (Long value : values) {\n            sum += value;\n        }\n        return sum;\n    }", "improvedCode": "public Long sumValues(List<Long> values) {\n        long sum = 0L;\n        for (Long value : values) {\n            sum += value;  // Only one unboxing per iteration\n        }\n        return sum;  // One boxing at return\n    }", "relevantFile": "src/main/java/com/app/analytics/MetricsCalculator.java", "relevantLinesEnd": 12, "suggestionContent": "Multiple methods use boxed types (`Long`, `Integer`, `Double`) for loop counters and accumulators. Each arithmetic operation causes auto-unboxing, computation, then auto-boxing back to objects, creating garbage. In `sumValues`, processing 1 million items creates 1 million temporary Long objects. Use primitive types (`long`, `int`, `double`) for local calculations.", "oneSentenceSummary": "Auto-boxing in loops creates millions of temporary objects - use primitive types", "relevantLinesStart": 7}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/SessionManager.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport com.app.model.Session;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Instant;\nimport java.util.*;\n\npublic class SessionManager {\n    private static final Logger logger = LoggerFactory.getLogger(SessionManager.class);\n\n    private final Map<String, Session> sessions = new HashMap<>();\n    private final long sessionTimeoutMs;\n\n    public SessionManager(long sessionTimeoutMs) {\n        this.sessionTimeoutMs = sessionTimeoutMs;\n    }\n\n    public Session createSession(String userId) {\n        String sessionId = UUID.randomUUID().toString();\n        Session session = new Session(sessionId, userId, Instant.now());\n        sessions.put(sessionId, session);\n        logger.info(\"Created session {} for user {}\", sessionId, userId);\n        return session;\n    }\n\n    public Optional<Session> getSession(String sessionId) {\n        Session session = sessions.get(sessionId);\n        if (session != null && !isExpired(session)) {\n            session.setLastAccessed(Instant.now());\n            return Optional.of(session);\n        }\n        return Optional.empty();\n    }\n\n    public void invalidateSession(String sessionId) {\n        sessions.remove(sessionId);\n        logger.info(\"Invalidated session {}\", sessionId);\n    }\n\n    public void cleanupExpiredSessions() {\n        for (String sessionId : sessions.keySet()) {\n            Session session = sessions.get(sessionId);\n            if (isExpired(session)) {\n                sessions.remove(sessionId);\n                logger.info(\"Removed expired session {}\", sessionId);\n            }\n        }\n    }\n\n    public void invalidateUserSessions(String userId) {\n        for (Map.Entry<String, Session> entry : sessions.entrySet()) {\n            if (entry.getValue().getUserId().equals(userId)) {\n                sessions.remove(entry.getKey());\n                logger.info(\"Invalidated session {} for user {}\", entry.getKey(), userId);\n            }\n        }\n    }\n\n    public List<Session> getActiveSessions() {\n        List<Session> active = new ArrayList<>();\n        for (Session session : sessions.values()) {\n            if (!isExpired(session)) {\n                active.add(session);\n            }\n        }\n        return active;\n    }\n\n    public int getActiveSessionCount() {\n        int count = 0;\n        for (Session session : sessions.values()) {\n            if (!isExpired(session)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isExpired(Session session) {\n        long elapsed = Instant.now().toEpochMilli() - session.getLastAccessed().toEpochMilli();\n        return elapsed > sessionTimeoutMs;\n    }\n\n    public Map<String, Integer> getSessionCountByUser() {\n        Map<String, Integer> counts = new HashMap<>();\n        for (Session session : sessions.values()) {\n            String userId = session.getUserId();\n            counts.put(userId, counts.getOrDefault(userId, 0) + 1);\n        }\n        return counts;\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/SessionManager.java'\n\n@@ -0,0 +1,95 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import com.app.model.Session;\n4 +import org.slf4j.Logger;\n5 +import org.slf4j.LoggerFactory;\n6 +\n7 +import java.time.Instant;\n8 +import java.util.*;\n9 +\n10 +public class SessionManager {\n11 +    private static final Logger logger = LoggerFactory.getLogger(SessionManager.class);\n12 +\n13 +    private final Map<String, Session> sessions = new HashMap<>();\n14 +    private final long sessionTimeoutMs;\n15 +\n16 +    public SessionManager(long sessionTimeoutMs) {\n17 +        this.sessionTimeoutMs = sessionTimeoutMs;\n18 +    }\n19 +\n20 +    public Session createSession(String userId) {\n21 +        String sessionId = UUID.randomUUID().toString();\n22 +        Session session = new Session(sessionId, userId, Instant.now());\n23 +        sessions.put(sessionId, session);\n24 +        logger.info(\"Created session {} for user {}\", sessionId, userId);\n25 +        return session;\n26 +    }\n27 +\n28 +    public Optional<Session> getSession(String sessionId) {\n29 +        Session session = sessions.get(sessionId);\n30 +        if (session != null && !isExpired(session)) {\n31 +            session.setLastAccessed(Instant.now());\n32 +            return Optional.of(session);\n33 +        }\n34 +        return Optional.empty();\n35 +    }\n36 +\n37 +    public void invalidateSession(String sessionId) {\n38 +        sessions.remove(sessionId);\n39 +        logger.info(\"Invalidated session {}\", sessionId);\n40 +    }\n41 +\n42 +    public void cleanupExpiredSessions() {\n43 +        for (String sessionId : sessions.keySet()) {\n44 +            Session session = sessions.get(sessionId);\n45 +            if (isExpired(session)) {\n46 +                sessions.remove(sessionId);\n47 +                logger.info(\"Removed expired session {}\", sessionId);\n48 +            }\n49 +        }\n50 +    }\n51 +\n52 +    public void invalidateUserSessions(String userId) {\n53 +        for (Map.Entry<String, Session> entry : sessions.entrySet()) {\n54 +            if (entry.getValue().getUserId().equals(userId)) {\n55 +                sessions.remove(entry.getKey());\n56 +                logger.info(\"Invalidated session {} for user {}\", entry.getKey(), userId);\n57 +            }\n58 +        }\n59 +    }\n60 +\n61 +    public List<Session> getActiveSessions() {\n62 +        List<Session> active = new ArrayList<>();\n63 +        for (Session session : sessions.values()) {\n64 +            if (!isExpired(session)) {\n65 +                active.add(session);\n66 +            }\n67 +        }\n68 +        return active;\n69 +    }\n70 +\n71 +    public int getActiveSessionCount() {\n72 +        int count = 0;\n73 +        for (Session session : sessions.values()) {\n74 +            if (!isExpired(session)) {\n75 +                count++;\n76 +            }\n77 +        }\n78 +        return count;\n79 +    }\n80 +\n81 +    private boolean isExpired(Session session) {\n82 +        long elapsed = Instant.now().toEpochMilli() - session.getLastAccessed().toEpochMilli();\n83 +        return elapsed > sessionTimeoutMs;\n84 +    }\n85 +\n86 +    public Map<String, Integer> getSessionCountByUser() {\n87 +        Map<String, Integer> counts = new HashMap<>();\n88 +        for (Session session : sessions.values()) {\n89 +            String userId = session.getUserId();\n90 +            counts.put(userId, counts.getOrDefault(userId, 0) + 1);\n91 +        }\n92 +        return counts;\n93 +    }\n94 +}\n95 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in src/main/java/com/app/service/SessionManager.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "for (String sessionId : sessions.keySet()) {\n            Session session = sessions.get(sessionId);\n            if (isExpired(session)) {\n                sessions.remove(sessionId);", "improvedCode": "Iterator<Map.Entry<String, Session>> iterator = sessions.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String, Session> entry = iterator.next();\n            if (isExpired(entry.getValue())) {\n                iterator.remove();", "relevantFile": "src/main/java/com/app/service/SessionManager.java", "relevantLinesEnd": 48, "suggestionContent": "The `cleanupExpiredSessions` method iterates over `sessions.keySet()` and calls `sessions.remove()` inside the loop. This throws `ConcurrentModificationException` because you cannot modify a HashMap while iterating over it. Use an Iterator with `iterator.remove()` or collect keys to remove first.", "oneSentenceSummary": "ConcurrentModificationException - removing from HashMap while iterating over keySet", "relevantLinesStart": 42}, {"label": "bug", "language": "Java", "existingCode": "for (Map.Entry<String, Session> entry : sessions.entrySet()) {\n            if (entry.getValue().getUserId().equals(userId)) {\n                sessions.remove(entry.getKey());", "improvedCode": "sessions.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));", "relevantFile": "src/main/java/com/app/service/SessionManager.java", "relevantLinesEnd": 55, "suggestionContent": "The `invalidateUserSessions` method has the same issue - it iterates over `sessions.entrySet()` and calls `sessions.remove()` inside the loop, causing `ConcurrentModificationException`.", "oneSentenceSummary": "ConcurrentModificationException - removing from HashMap while iterating over entrySet", "relevantLinesStart": 51}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/controller/FileController.java", "language": "Java", "fileContent": "package com.app.controller;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.nio.file.*;\n\npublic class FileController {\n    private static final Logger logger = LoggerFactory.getLogger(FileController.class);\n\n    private final String uploadDirectory;\n    private final String documentsDirectory;\n\n    public FileController(String uploadDirectory, String documentsDirectory) {\n        this.uploadDirectory = uploadDirectory;\n        this.documentsDirectory = documentsDirectory;\n    }\n\n    public byte[] downloadFile(String filename) throws IOException {\n        Path filePath = Paths.get(uploadDirectory, filename);\n        logger.info(\"Downloading file: {}\", filePath);\n\n        return Files.readAllBytes(filePath);\n    }\n\n    public void uploadFile(String filename, byte[] content) throws IOException {\n        Path filePath = Paths.get(uploadDirectory, filename);\n        Files.createDirectories(filePath.getParent());\n        Files.write(filePath, content);\n\n        logger.info(\"Uploaded file: {}\", filePath);\n    }\n\n    public void deleteFile(String filename) throws IOException {\n        Path filePath = Paths.get(uploadDirectory, filename);\n        Files.deleteIfExists(filePath);\n\n        logger.info(\"Deleted file: {}\", filePath);\n    }\n\n    public String readDocument(String docName) throws IOException {\n        String filePath = documentsDirectory + \"/\" + docName;\n        return new String(Files.readAllBytes(Paths.get(filePath)));\n    }\n\n    public boolean fileExists(String filename) {\n        Path filePath = Paths.get(uploadDirectory, filename);\n        return Files.exists(filePath);\n    }\n\n    public void moveFile(String source, String destination) throws IOException {\n        Path sourcePath = Paths.get(uploadDirectory, source);\n        Path destPath = Paths.get(uploadDirectory, destination);\n\n        Files.createDirectories(destPath.getParent());\n        Files.move(sourcePath, destPath);\n    }\n\n    public String[] listFiles(String directory) throws IOException {\n        Path dirPath = Paths.get(uploadDirectory, directory);\n\n        return Files.list(dirPath)\n            .map(path -> path.getFileName().toString())\n            .toArray(String[]::new);\n    }\n\n    public void copyToDocuments(String uploadedFile, String docName) throws IOException {\n        Path source = Paths.get(uploadDirectory, uploadedFile);\n        Path dest = Paths.get(documentsDirectory, docName);\n\n        Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/controller/FileController.java'\n\n@@ -0,0 +1,75 @@\n__new hunk__\n1 +package com.app.controller;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import java.io.*;\n7 +import java.nio.file.*;\n8 +\n9 +public class FileController {\n10 +    private static final Logger logger = LoggerFactory.getLogger(FileController.class);\n11 +\n12 +    private final String uploadDirectory;\n13 +    private final String documentsDirectory;\n14 +\n15 +    public FileController(String uploadDirectory, String documentsDirectory) {\n16 +        this.uploadDirectory = uploadDirectory;\n17 +        this.documentsDirectory = documentsDirectory;\n18 +    }\n19 +\n20 +    public byte[] downloadFile(String filename) throws IOException {\n21 +        Path filePath = Paths.get(uploadDirectory, filename);\n22 +        logger.info(\"Downloading file: {}\", filePath);\n23 +\n24 +        return Files.readAllBytes(filePath);\n25 +    }\n26 +\n27 +    public void uploadFile(String filename, byte[] content) throws IOException {\n28 +        Path filePath = Paths.get(uploadDirectory, filename);\n29 +        Files.createDirectories(filePath.getParent());\n30 +        Files.write(filePath, content);\n31 +\n32 +        logger.info(\"Uploaded file: {}\", filePath);\n33 +    }\n34 +\n35 +    public void deleteFile(String filename) throws IOException {\n36 +        Path filePath = Paths.get(uploadDirectory, filename);\n37 +        Files.deleteIfExists(filePath);\n38 +\n39 +        logger.info(\"Deleted file: {}\", filePath);\n40 +    }\n41 +\n42 +    public String readDocument(String docName) throws IOException {\n43 +        String filePath = documentsDirectory + \"/\" + docName;\n44 +        return new String(Files.readAllBytes(Paths.get(filePath)));\n45 +    }\n46 +\n47 +    public boolean fileExists(String filename) {\n48 +        Path filePath = Paths.get(uploadDirectory, filename);\n49 +        return Files.exists(filePath);\n50 +    }\n51 +\n52 +    public void moveFile(String source, String destination) throws IOException {\n53 +        Path sourcePath = Paths.get(uploadDirectory, source);\n54 +        Path destPath = Paths.get(uploadDirectory, destination);\n55 +\n56 +        Files.createDirectories(destPath.getParent());\n57 +        Files.move(sourcePath, destPath);\n58 +    }\n59 +\n60 +    public String[] listFiles(String directory) throws IOException {\n61 +        Path dirPath = Paths.get(uploadDirectory, directory);\n62 +\n63 +        return Files.list(dirPath)\n64 +            .map(path -> path.getFileName().toString())\n65 +            .toArray(String[]::new);\n66 +    }\n67 +\n68 +    public void copyToDocuments(String uploadedFile, String docName) throws IOException {\n69 +        Path source = Paths.get(uploadDirectory, uploadedFile);\n70 +        Path dest = Paths.get(documentsDirectory, docName);\n71 +\n72 +        Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);\n73 +    }\n74 +}\n75 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in src/main/java/com/app/controller/FileController.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "public byte[] downloadFile(String filename) throws IOException {\n        Path filePath = Paths.get(uploadDirectory, filename);\n        logger.info(\"Downloading file: {}\", filePath);\n        \n        return Files.readAllBytes(filePath);\n    }", "improvedCode": "public byte[] downloadFile(String filename) throws IOException {\n        Path basePath = Paths.get(uploadDirectory).toAbsolutePath().normalize();\n        Path filePath = basePath.resolve(filename).normalize();\n        \n        if (!filePath.startsWith(basePath)) {\n            throw new SecurityException(\"Invalid file path\");\n        }\n        \n        logger.info(\"Downloading file: {}\", filePath);\n        return Files.readAllBytes(filePath);\n    }", "relevantFile": "src/main/java/com/app/controller/FileController.java", "relevantLinesEnd": 25, "suggestionContent": "The `downloadFile` method concatenates user input `filename` to the upload directory without validation. An attacker can use `../../../etc/passwd` to read arbitrary files outside the upload directory. Validate that the resolved path is within the allowed directory.", "oneSentenceSummary": "Path traversal in downloadFile allows reading arbitrary system files", "relevantLinesStart": 20}, {"label": "bug", "language": "Java", "existingCode": "public void deleteFile(String filename) throws IOException {\n        Path filePath = Paths.get(uploadDirectory, filename);\n        Files.deleteIfExists(filePath);", "improvedCode": "public void deleteFile(String filename) throws IOException {\n        Path basePath = Paths.get(uploadDirectory).toAbsolutePath().normalize();\n        Path filePath = basePath.resolve(filename).normalize();\n        \n        if (!filePath.startsWith(basePath)) {\n            throw new SecurityException(\"Invalid file path\");\n        }\n        \n        Files.deleteIfExists(filePath);", "relevantFile": "src/main/java/com/app/controller/FileController.java", "relevantLinesEnd": 37, "suggestionContent": "The `deleteFile` method is also vulnerable to path traversal. An attacker can delete arbitrary files on the system by providing `../../../important/file` as the filename.", "oneSentenceSummary": "Path traversal in deleteFile allows deleting arbitrary system files", "relevantLinesStart": 35}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/UserService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport com.app.model.User;\nimport com.app.repository.UserRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n\n    private final UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public Optional<User> findByEmail(String email) {\n        return userRepository.findByEmail(email);\n    }\n\n    public boolean isAdmin(String userId) {\n        Optional<User> user = userRepository.findById(userId);\n        if (user.isPresent()) {\n            String role = user.get().getRole();\n            return role == \"ADMIN\";\n        }\n        return false;\n    }\n\n    public boolean validateUserStatus(User user, String expectedStatus) {\n        String currentStatus = user.getStatus();\n        if (currentStatus == expectedStatus) {\n            logger.info(\"User {} has expected status: {}\", user.getId(), expectedStatus);\n            return true;\n        }\n        return false;\n    }\n\n    public List<User> findUsersByRole(String role) {\n        return userRepository.findAll().stream()\n            .filter(user -> user.getRole().equals(role))\n            .toList();\n    }\n\n    public void updateUserRole(String userId, String newRole) {\n        Optional<User> user = userRepository.findById(userId);\n        if (user.isPresent()) {\n            User u = user.get();\n            String oldRole = u.getRole();\n            u.setRole(newRole);\n            userRepository.save(u);\n            logger.info(\"Updated user {} role from {} to {}\", userId, oldRole, newRole);\n        }\n    }\n\n    public boolean hasPermission(User user, String permission) {\n        List<String> permissions = user.getPermissions();\n        for (String p : permissions) {\n            if (p == permission) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int countActiveUsers() {\n        return (int) userRepository.findAll().stream()\n            .filter(user -> \"ACTIVE\".equals(user.getStatus()))\n            .count();\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/UserService.java'\n\n@@ -0,0 +1,75 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import com.app.model.User;\n4 +import com.app.repository.UserRepository;\n5 +import org.slf4j.Logger;\n6 +import org.slf4j.LoggerFactory;\n7 +\n8 +import java.util.List;\n9 +import java.util.Optional;\n10 +\n11 +public class UserService {\n12 +    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n13 +\n14 +    private final UserRepository userRepository;\n15 +\n16 +    public UserService(UserRepository userRepository) {\n17 +        this.userRepository = userRepository;\n18 +    }\n19 +\n20 +    public Optional<User> findByEmail(String email) {\n21 +        return userRepository.findByEmail(email);\n22 +    }\n23 +\n24 +    public boolean isAdmin(String userId) {\n25 +        Optional<User> user = userRepository.findById(userId);\n26 +        if (user.isPresent()) {\n27 +            String role = user.get().getRole();\n28 +            return role == \"ADMIN\";\n29 +        }\n30 +        return false;\n31 +    }\n32 +\n33 +    public boolean validateUserStatus(User user, String expectedStatus) {\n34 +        String currentStatus = user.getStatus();\n35 +        if (currentStatus == expectedStatus) {\n36 +            logger.info(\"User {} has expected status: {}\", user.getId(), expectedStatus);\n37 +            return true;\n38 +        }\n39 +        return false;\n40 +    }\n41 +\n42 +    public List<User> findUsersByRole(String role) {\n43 +        return userRepository.findAll().stream()\n44 +            .filter(user -> user.getRole().equals(role))\n45 +            .toList();\n46 +    }\n47 +\n48 +    public void updateUserRole(String userId, String newRole) {\n49 +        Optional<User> user = userRepository.findById(userId);\n50 +        if (user.isPresent()) {\n51 +            User u = user.get();\n52 +            String oldRole = u.getRole();\n53 +            u.setRole(newRole);\n54 +            userRepository.save(u);\n55 +            logger.info(\"Updated user {} role from {} to {}\", userId, oldRole, newRole);\n56 +        }\n57 +    }\n58 +\n59 +    public boolean hasPermission(User user, String permission) {\n60 +        List<String> permissions = user.getPermissions();\n61 +        for (String p : permissions) {\n62 +            if (p == permission) {\n63 +                return true;\n64 +            }\n65 +        }\n66 +        return false;\n67 +    }\n68 +\n69 +    public int countActiveUsers() {\n70 +        return (int) userRepository.findAll().stream()\n71 +            .filter(user -> \"ACTIVE\".equals(user.getStatus()))\n72 +            .count();\n73 +    }\n74 +}\n75 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/service/UserService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "return role == \"ADMIN\";", "improvedCode": "return \"ADMIN\".equals(role);", "relevantFile": "src/main/java/com/app/service/UserService.java", "relevantLinesEnd": 26, "suggestionContent": "The `isAdmin` method compares strings using `==` operator (`role == \"ADMIN\"`). In Java, `==` compares object references, not content. Since `role` comes from the database/user object and `\"ADMIN\"` is a string literal, they are different objects in memory. This comparison will almost always return false even when the role is \"ADMIN\". Use `.equals()` for string content comparison.", "oneSentenceSummary": "String comparison with == instead of .equals() - admin check always fails", "relevantLinesStart": 26}, {"label": "bug", "language": "Java", "existingCode": "if (currentStatus == expectedStatus) {", "improvedCode": "if (expectedStatus.equals(currentStatus)) {", "relevantFile": "src/main/java/com/app/service/UserService.java", "relevantLinesEnd": 32, "suggestionContent": "The `validateUserStatus` method uses `==` to compare `currentStatus` with `expectedStatus`. Both are String parameters that may come from different sources, so they won't be the same object reference. This will return false even when the strings have the same content.", "oneSentenceSummary": "String parameter comparison with == fails for equal string values", "relevantLinesStart": 32}, {"label": "bug", "language": "Java", "existingCode": "if (p == permission) {", "improvedCode": "if (permission.equals(p)) {", "relevantFile": "src/main/java/com/app/service/UserService.java", "relevantLinesEnd": 57, "suggestionContent": "The `hasPermission` method uses `==` to compare permission strings in a loop. This will fail to match permissions even when the string content is identical, causing the method to incorrectly deny permissions.", "oneSentenceSummary": "Permission check uses == for strings - always denies valid permissions", "relevantLinesStart": 57}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/finance/TaxCalculator.java", "language": "Java", "fileContent": "package com.app.finance;\n\nimport java.util.*;\n\npublic class TaxCalculator {\n\n    private static final double TAX_RATE_LOW = 0.10;\n    private static final double TAX_RATE_MED = 0.20;\n    private static final double TAX_RATE_HIGH = 0.30;\n\n    private static final double BRACKET_LOW = 10000.0;\n    private static final double BRACKET_MED = 50000.0;\n\n    public double calculateTax(double income) {\n        if (income <= BRACKET_LOW) {\n            return income * TAX_RATE_LOW;\n        } else if (income <= BRACKET_MED) {\n            return BRACKET_LOW * TAX_RATE_LOW + (income - BRACKET_LOW) * TAX_RATE_MED;\n        } else {\n            return BRACKET_LOW * TAX_RATE_LOW +\n                   (BRACKET_MED - BRACKET_LOW) * TAX_RATE_MED +\n                   (income - BRACKET_MED) * TAX_RATE_HIGH;\n        }\n    }\n\n    public boolean isEligibleForRefund(double paid, double owed) {\n        double difference = paid - owed;\n        if (difference == 0.0) {\n            return false;\n        }\n        return difference > 0;\n    }\n\n    public boolean verifyCalculation(double expected, double actual) {\n        return expected == actual;\n    }\n\n    public double roundToTwoDecimals(double value) {\n        return Math.round(value * 100.0) / 100.0;\n    }\n\n    public boolean hasZeroBalance(double balance) {\n        return balance == 0.0;\n    }\n\n    public List<Double> applyDiscounts(List<Double> prices, double discountPercent) {\n        List<Double> discounted = new ArrayList<>();\n        for (double price : prices) {\n            double discount = price * (discountPercent / 100.0);\n            double finalPrice = price - discount;\n            discounted.add(finalPrice);\n        }\n        return discounted;\n    }\n\n    public boolean isPriceMatch(double price1, double price2) {\n        double diff = price1 - price2;\n        return diff == 0.0;\n    }\n\n    public double calculateTotal(double[] amounts) {\n        double total = 0.0;\n        for (double amount : amounts) {\n            total += amount;\n        }\n        return total;\n    }\n\n    public boolean isWithinBudget(double spent, double budget) {\n        return spent <= budget || spent == budget;\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/finance/TaxCalculator.java'\n\n@@ -0,0 +1,73 @@\n__new hunk__\n1 +package com.app.finance;\n2 +\n3 +import java.util.*;\n4 +\n5 +public class TaxCalculator {\n6 +\n7 +    private static final double TAX_RATE_LOW = 0.10;\n8 +    private static final double TAX_RATE_MED = 0.20;\n9 +    private static final double TAX_RATE_HIGH = 0.30;\n10 +\n11 +    private static final double BRACKET_LOW = 10000.0;\n12 +    private static final double BRACKET_MED = 50000.0;\n13 +\n14 +    public double calculateTax(double income) {\n15 +        if (income <= BRACKET_LOW) {\n16 +            return income * TAX_RATE_LOW;\n17 +        } else if (income <= BRACKET_MED) {\n18 +            return BRACKET_LOW * TAX_RATE_LOW + (income - BRACKET_LOW) * TAX_RATE_MED;\n19 +        } else {\n20 +            return BRACKET_LOW * TAX_RATE_LOW +\n21 +                   (BRACKET_MED - BRACKET_LOW) * TAX_RATE_MED +\n22 +                   (income - BRACKET_MED) * TAX_RATE_HIGH;\n23 +        }\n24 +    }\n25 +\n26 +    public boolean isEligibleForRefund(double paid, double owed) {\n27 +        double difference = paid - owed;\n28 +        if (difference == 0.0) {\n29 +            return false;\n30 +        }\n31 +        return difference > 0;\n32 +    }\n33 +\n34 +    public boolean verifyCalculation(double expected, double actual) {\n35 +        return expected == actual;\n36 +    }\n37 +\n38 +    public double roundToTwoDecimals(double value) {\n39 +        return Math.round(value * 100.0) / 100.0;\n40 +    }\n41 +\n42 +    public boolean hasZeroBalance(double balance) {\n43 +        return balance == 0.0;\n44 +    }\n45 +\n46 +    public List<Double> applyDiscounts(List<Double> prices, double discountPercent) {\n47 +        List<Double> discounted = new ArrayList<>();\n48 +        for (double price : prices) {\n49 +            double discount = price * (discountPercent / 100.0);\n50 +            double finalPrice = price - discount;\n51 +            discounted.add(finalPrice);\n52 +        }\n53 +        return discounted;\n54 +    }\n55 +\n56 +    public boolean isPriceMatch(double price1, double price2) {\n57 +        double diff = price1 - price2;\n58 +        return diff == 0.0;\n59 +    }\n60 +\n61 +    public double calculateTotal(double[] amounts) {\n62 +        double total = 0.0;\n63 +        for (double amount : amounts) {\n64 +            total += amount;\n65 +        }\n66 +        return total;\n67 +    }\n68 +\n69 +    public boolean isWithinBudget(double spent, double budget) {\n70 +        return spent <= budget || spent == budget;\n71 +    }\n72 +}\n73 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in src/main/java/com/app/finance/TaxCalculator.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "public boolean verifyCalculation(double expected, double actual) {\n        return expected == actual;\n    }", "improvedCode": "private static final double EPSILON = 0.0001;\n\npublic boolean verifyCalculation(double expected, double actual) {\n        return Math.abs(expected - actual) < EPSILON;\n    }", "relevantFile": "src/main/java/com/app/finance/TaxCalculator.java", "relevantLinesEnd": 37, "suggestionContent": "Multiple methods compare floating point numbers using `==` (`verifyCalculation`, `hasZeroBalance`, `isPriceMatch`). Due to floating point representation, `0.1 + 0.2 != 0.3` in Java. Financial calculations accumulate rounding errors, so two numbers that should be equal may differ by tiny amounts like 0.0000001. Use epsilon comparison or BigDecimal.", "oneSentenceSummary": "Floating point == comparison fails due to precision errors - use epsilon", "relevantLinesStart": 35}, {"label": "bug", "language": "Java", "existingCode": "double difference = paid - owed;\n        if (difference == 0.0) {\n            return false;\n        }", "improvedCode": "double difference = paid - owed;\n        if (Math.abs(difference) < 0.0001) {\n            return false;\n        }", "relevantFile": "src/main/java/com/app/finance/TaxCalculator.java", "relevantLinesEnd": 31, "suggestionContent": "The `isEligibleForRefund` method compares `difference == 0.0` which may incorrectly pass when the difference is a tiny non-zero value like 1e-15 due to floating point arithmetic. It should use epsilon comparison.", "oneSentenceSummary": "Zero comparison with floating point fails for near-zero differences", "relevantLinesStart": 28}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/SchedulerService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.text.SimpleDateFormat;\nimport java.time.*;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\n\npublic class SchedulerService {\n    private static final Logger logger = LoggerFactory.getLogger(SchedulerService.class);\n\n    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n\n    public String formatDate(Date date) {\n        return dateFormat.format(date);\n    }\n\n    public Date parseDate(String dateStr) throws Exception {\n        return dateFormat.parse(dateStr);\n    }\n\n    public boolean isBusinessHours(LocalDateTime dateTime) {\n        int hour = dateTime.getHour();\n        DayOfWeek day = dateTime.getDayOfWeek();\n\n        if (day == DayOfWeek.SATURDAY || day == DayOfWeek.SUNDAY) {\n            return false;\n        }\n\n        return hour >= 9 && hour < 17;\n    }\n\n    public long calculateDaysBetween(Date start, Date end) {\n        long diffMs = end.getTime() - start.getTime();\n        return diffMs / (1000 * 60 * 60 * 24);\n    }\n\n    public LocalDate addBusinessDays(LocalDate date, int days) {\n        LocalDate result = date;\n        int addedDays = 0;\n\n        while (addedDays < days) {\n            result = result.plusDays(1);\n            if (result.getDayOfWeek() != DayOfWeek.SATURDAY &&\n                result.getDayOfWeek() != DayOfWeek.SUNDAY) {\n                addedDays++;\n            }\n        }\n\n        return result;\n    }\n\n    public boolean isSameDay(Date date1, Date date2) {\n        Calendar cal1 = Calendar.getInstance();\n        Calendar cal2 = Calendar.getInstance();\n        cal1.setTime(date1);\n        cal2.setTime(date2);\n\n        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n               cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);\n    }\n\n    public List<String> generateDailySlots(LocalDate date) {\n        List<String> slots = new ArrayList<>();\n        LocalDateTime startOfDay = date.atStartOfDay();\n\n        for (int hour = 9; hour < 17; hour++) {\n            LocalDateTime slotTime = startOfDay.plusHours(hour);\n            slots.add(formatter.format(slotTime));\n        }\n\n        return slots;\n    }\n\n    public Date getNextMonday(Date from) {\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(from);\n\n        while (cal.get(Calendar.DAY_OF_WEEK) != Calendar.MONDAY) {\n            cal.add(Calendar.DAY_OF_MONTH, 1);\n        }\n\n        return cal.getTime();\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/SchedulerService.java'\n\n@@ -0,0 +1,89 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import java.text.SimpleDateFormat;\n7 +import java.time.*;\n8 +import java.time.format.DateTimeFormatter;\n9 +import java.util.*;\n10 +\n11 +public class SchedulerService {\n12 +    private static final Logger logger = LoggerFactory.getLogger(SchedulerService.class);\n13 +\n14 +    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n15 +    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n16 +\n17 +    public String formatDate(Date date) {\n18 +        return dateFormat.format(date);\n19 +    }\n20 +\n21 +    public Date parseDate(String dateStr) throws Exception {\n22 +        return dateFormat.parse(dateStr);\n23 +    }\n24 +\n25 +    public boolean isBusinessHours(LocalDateTime dateTime) {\n26 +        int hour = dateTime.getHour();\n27 +        DayOfWeek day = dateTime.getDayOfWeek();\n28 +\n29 +        if (day == DayOfWeek.SATURDAY || day == DayOfWeek.SUNDAY) {\n30 +            return false;\n31 +        }\n32 +\n33 +        return hour >= 9 && hour < 17;\n34 +    }\n35 +\n36 +    public long calculateDaysBetween(Date start, Date end) {\n37 +        long diffMs = end.getTime() - start.getTime();\n38 +        return diffMs / (1000 * 60 * 60 * 24);\n39 +    }\n40 +\n41 +    public LocalDate addBusinessDays(LocalDate date, int days) {\n42 +        LocalDate result = date;\n43 +        int addedDays = 0;\n44 +\n45 +        while (addedDays < days) {\n46 +            result = result.plusDays(1);\n47 +            if (result.getDayOfWeek() != DayOfWeek.SATURDAY &&\n48 +                result.getDayOfWeek() != DayOfWeek.SUNDAY) {\n49 +                addedDays++;\n50 +            }\n51 +        }\n52 +\n53 +        return result;\n54 +    }\n55 +\n56 +    public boolean isSameDay(Date date1, Date date2) {\n57 +        Calendar cal1 = Calendar.getInstance();\n58 +        Calendar cal2 = Calendar.getInstance();\n59 +        cal1.setTime(date1);\n60 +        cal2.setTime(date2);\n61 +\n62 +        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n63 +               cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);\n64 +    }\n65 +\n66 +    public List<String> generateDailySlots(LocalDate date) {\n67 +        List<String> slots = new ArrayList<>();\n68 +        LocalDateTime startOfDay = date.atStartOfDay();\n69 +\n70 +        for (int hour = 9; hour < 17; hour++) {\n71 +            LocalDateTime slotTime = startOfDay.plusHours(hour);\n72 +            slots.add(formatter.format(slotTime));\n73 +        }\n74 +\n75 +        return slots;\n76 +    }\n77 +\n78 +    public Date getNextMonday(Date from) {\n79 +        Calendar cal = Calendar.getInstance();\n80 +        cal.setTime(from);\n81 +\n82 +        while (cal.get(Calendar.DAY_OF_WEEK) != Calendar.MONDAY) {\n83 +            cal.add(Calendar.DAY_OF_MONTH, 1);\n84 +        }\n85 +\n86 +        return cal.getTime();\n87 +    }\n88 +}\n89 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in src/main/java/com/app/service/SchedulerService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");", "improvedCode": "private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\npublic String formatDate(Date date) {\n    return dateTimeFormatter.format(date.toInstant().atZone(ZoneId.systemDefault()));\n}", "relevantFile": "src/main/java/com/app/service/SchedulerService.java", "relevantLinesEnd": 14, "suggestionContent": "The `SimpleDateFormat` instance is stored as a static field but `SimpleDateFormat` is not thread-safe. Multiple threads calling `formatDate` or `parseDate` concurrently will corrupt internal state, causing wrong dates or exceptions. Create a new instance per call or use `DateTimeFormatter` which is thread-safe.", "oneSentenceSummary": "SimpleDateFormat is not thread-safe - concurrent access corrupts dates", "relevantLinesStart": 14}, {"label": "bug", "language": "Java", "existingCode": "public long calculateDaysBetween(Date start, Date end) {\n        long diffMs = end.getTime() - start.getTime();\n        return diffMs / (1000 * 60 * 60 * 24);\n    }", "improvedCode": "public long calculateDaysBetween(Date start, Date end) {\n        LocalDate startDate = start.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\n        LocalDate endDate = end.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\n        return ChronoUnit.DAYS.between(startDate, endDate);\n    }", "relevantFile": "src/main/java/com/app/service/SchedulerService.java", "relevantLinesEnd": 38, "suggestionContent": "The `calculateDaysBetween` method divides milliseconds by a fixed day length, but this doesn't account for daylight saving time transitions. A day with DST change is 23 or 25 hours, causing off-by-one errors. Use `java.time` classes like `ChronoUnit.DAYS.between()`.", "oneSentenceSummary": "Days calculation ignores DST - returns wrong count across timezone transitions", "relevantLinesStart": 35}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/security/CryptoService.java", "language": "Java", "fileContent": "package com.app.security;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.security.*;\nimport java.util.Base64;\n\npublic class CryptoService {\n    private static final Logger logger = LoggerFactory.getLogger(CryptoService.class);\n\n    private static final String ALGORITHM = \"DES\";\n    private static final String TRANSFORMATION = \"DES/ECB/PKCS5Padding\";\n    private static final byte[] KEY_BYTES = \"12345678\".getBytes();\n\n    public String encrypt(String plaintext) throws Exception {\n        SecretKeySpec keySpec = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n\n        byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n\n    public String decrypt(String ciphertext) throws Exception {\n        SecretKeySpec keySpec = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n\n        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(ciphertext));\n        return new String(decrypted);\n    }\n\n    public String hashPassword(String password) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = md.digest(password.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        for (byte b : hash) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    public String generateToken() {\n        return String.valueOf(System.currentTimeMillis());\n    }\n\n    public boolean verifyPassword(String password, String hash) throws Exception {\n        String computed = hashPassword(password);\n        return computed.equals(hash);\n    }\n\n    public String sign(String data) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] hash = md.digest((data + KEY_BYTES).getBytes());\n        return Base64.getEncoder().encodeToString(hash);\n    }\n\n    public SecureRandom getSecureRandom() {\n        return new SecureRandom();\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/security/CryptoService.java'\n\n@@ -0,0 +1,66 @@\n__new hunk__\n1 +package com.app.security;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import javax.crypto.*;\n7 +import javax.crypto.spec.*;\n8 +import java.security.*;\n9 +import java.util.Base64;\n10 +\n11 +public class CryptoService {\n12 +    private static final Logger logger = LoggerFactory.getLogger(CryptoService.class);\n13 +\n14 +    private static final String ALGORITHM = \"DES\";\n15 +    private static final String TRANSFORMATION = \"DES/ECB/PKCS5Padding\";\n16 +    private static final byte[] KEY_BYTES = \"12345678\".getBytes();\n17 +\n18 +    public String encrypt(String plaintext) throws Exception {\n19 +        SecretKeySpec keySpec = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n20 +        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n21 +        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n22 +\n23 +        byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n24 +        return Base64.getEncoder().encodeToString(encrypted);\n25 +    }\n26 +\n27 +    public String decrypt(String ciphertext) throws Exception {\n28 +        SecretKeySpec keySpec = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n29 +        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n30 +        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n31 +\n32 +        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(ciphertext));\n33 +        return new String(decrypted);\n34 +    }\n35 +\n36 +    public String hashPassword(String password) throws Exception {\n37 +        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n38 +        byte[] hash = md.digest(password.getBytes());\n39 +\n40 +        StringBuilder sb = new StringBuilder();\n41 +        for (byte b : hash) {\n42 +            sb.append(String.format(\"%02x\", b));\n43 +        }\n44 +        return sb.toString();\n45 +    }\n46 +\n47 +    public String generateToken() {\n48 +        return String.valueOf(System.currentTimeMillis());\n49 +    }\n50 +\n51 +    public boolean verifyPassword(String password, String hash) throws Exception {\n52 +        String computed = hashPassword(password);\n53 +        return computed.equals(hash);\n54 +    }\n55 +\n56 +    public String sign(String data) throws Exception {\n57 +        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n58 +        byte[] hash = md.digest((data + KEY_BYTES).getBytes());\n59 +        return Base64.getEncoder().encodeToString(hash);\n60 +    }\n61 +\n62 +    public SecureRandom getSecureRandom() {\n63 +        return new SecureRandom();\n64 +    }\n65 +}\n66 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/security/CryptoService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "private static final String ALGORITHM = \"DES\";\n    private static final String TRANSFORMATION = \"DES/ECB/PKCS5Padding\";", "improvedCode": "private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/GCM/NoPadding\";", "relevantFile": "src/main/java/com/app/security/CryptoService.java", "relevantLinesEnd": 15, "suggestionContent": "The encryption uses DES algorithm which is deprecated and cryptographically broken. DES has a 56-bit key that can be brute-forced in hours. Also uses ECB mode which reveals patterns in encrypted data. Use AES with GCM mode instead.", "oneSentenceSummary": "DES encryption is broken and ECB mode reveals data patterns", "relevantLinesStart": 14}, {"label": "bug", "language": "Java", "existingCode": "MessageDigest md = MessageDigest.getInstance(\"MD5\");", "improvedCode": "// Use BCrypt or Argon2 for password hashing\n// String hash = BCrypt.hashpw(password, BCrypt.gensalt(12));", "relevantFile": "src/main/java/com/app/security/CryptoService.java", "relevantLinesEnd": 37, "suggestionContent": "The `hashPassword` method uses MD5 which is cryptographically broken and too fast for password hashing. Attackers can compute billions of MD5 hashes per second. Use bcrypt, scrypt, or Argon2 for password hashing.", "oneSentenceSummary": "MD5 for passwords is insecure - too fast and cryptographically broken", "relevantLinesStart": 37}, {"label": "bug", "language": "Java", "existingCode": "public String generateToken() {\n        return String.valueOf(System.currentTimeMillis());\n    }", "improvedCode": "public String generateToken() {\n        byte[] bytes = new byte[32];\n        new SecureRandom().nextBytes(bytes);\n        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);\n    }", "relevantFile": "src/main/java/com/app/security/CryptoService.java", "relevantLinesEnd": 48, "suggestionContent": "The `generateToken` method uses `System.currentTimeMillis()` which is predictable. An attacker who knows approximately when a token was generated can guess it. Use `SecureRandom` to generate tokens.", "oneSentenceSummary": "Token generation using timestamp is predictable and insecure", "relevantLinesStart": 46}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/XmlParserService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.*;\nimport java.util.*;\n\npublic class XmlParserService {\n    private static final Logger logger = LoggerFactory.getLogger(XmlParserService.class);\n\n    public Document parseXml(String xmlContent) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputSource inputSource = new InputSource(new StringReader(xmlContent));\n        return builder.parse(inputSource);\n    }\n\n    public Document parseXmlFile(String filePath) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        return builder.parse(new File(filePath));\n    }\n\n    public Map<String, String> extractData(Document doc) {\n        Map<String, String> data = new HashMap<>();\n\n        NodeList nodes = doc.getElementsByTagName(\"*\");\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getChildNodes().getLength() == 1 &&\n                    element.getFirstChild().getNodeType() == Node.TEXT_NODE) {\n                    data.put(element.getTagName(), element.getTextContent());\n                }\n            }\n        }\n\n        return data;\n    }\n\n    public String extractValue(Document doc, String tagName) {\n        NodeList nodes = doc.getElementsByTagName(tagName);\n        if (nodes.getLength() > 0) {\n            return nodes.item(0).getTextContent();\n        }\n        return null;\n    }\n\n    public List<String> extractAllValues(Document doc, String tagName) {\n        List<String> values = new ArrayList<>();\n        NodeList nodes = doc.getElementsByTagName(tagName);\n\n        for (int i = 0; i < nodes.getLength(); i++) {\n            values.add(nodes.item(i).getTextContent());\n        }\n\n        return values;\n    }\n\n    public String documentToString(Document doc) throws Exception {\n        TransformerFactory tf = TransformerFactory.newInstance();\n        Transformer transformer = tf.newTransformer();\n        StringWriter writer = new StringWriter();\n        transformer.transform(new DOMSource(doc), new StreamResult(writer));\n        return writer.toString();\n    }\n\n    public Document createDocument(String rootElement) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.newDocument();\n\n        Element root = doc.createElement(rootElement);\n        doc.appendChild(root);\n\n        return doc;\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/XmlParserService.java'\n\n@@ -0,0 +1,89 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +import org.w3c.dom.*;\n6 +import org.xml.sax.InputSource;\n7 +\n8 +import javax.xml.parsers.*;\n9 +import javax.xml.transform.*;\n10 +import javax.xml.transform.dom.DOMSource;\n11 +import javax.xml.transform.stream.StreamResult;\n12 +import java.io.*;\n13 +import java.util.*;\n14 +\n15 +public class XmlParserService {\n16 +    private static final Logger logger = LoggerFactory.getLogger(XmlParserService.class);\n17 +\n18 +    public Document parseXml(String xmlContent) throws Exception {\n19 +        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n20 +        DocumentBuilder builder = factory.newDocumentBuilder();\n21 +\n22 +        InputSource inputSource = new InputSource(new StringReader(xmlContent));\n23 +        return builder.parse(inputSource);\n24 +    }\n25 +\n26 +    public Document parseXmlFile(String filePath) throws Exception {\n27 +        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n28 +        DocumentBuilder builder = factory.newDocumentBuilder();\n29 +\n30 +        return builder.parse(new File(filePath));\n31 +    }\n32 +\n33 +    public Map<String, String> extractData(Document doc) {\n34 +        Map<String, String> data = new HashMap<>();\n35 +\n36 +        NodeList nodes = doc.getElementsByTagName(\"*\");\n37 +        for (int i = 0; i < nodes.getLength(); i++) {\n38 +            Node node = nodes.item(i);\n39 +            if (node.getNodeType() == Node.ELEMENT_NODE) {\n40 +                Element element = (Element) node;\n41 +                if (element.getChildNodes().getLength() == 1 &&\n42 +                    element.getFirstChild().getNodeType() == Node.TEXT_NODE) {\n43 +                    data.put(element.getTagName(), element.getTextContent());\n44 +                }\n45 +            }\n46 +        }\n47 +\n48 +        return data;\n49 +    }\n50 +\n51 +    public String extractValue(Document doc, String tagName) {\n52 +        NodeList nodes = doc.getElementsByTagName(tagName);\n53 +        if (nodes.getLength() > 0) {\n54 +            return nodes.item(0).getTextContent();\n55 +        }\n56 +        return null;\n57 +    }\n58 +\n59 +    public List<String> extractAllValues(Document doc, String tagName) {\n60 +        List<String> values = new ArrayList<>();\n61 +        NodeList nodes = doc.getElementsByTagName(tagName);\n62 +\n63 +        for (int i = 0; i < nodes.getLength(); i++) {\n64 +            values.add(nodes.item(i).getTextContent());\n65 +        }\n66 +\n67 +        return values;\n68 +    }\n69 +\n70 +    public String documentToString(Document doc) throws Exception {\n71 +        TransformerFactory tf = TransformerFactory.newInstance();\n72 +        Transformer transformer = tf.newTransformer();\n73 +        StringWriter writer = new StringWriter();\n74 +        transformer.transform(new DOMSource(doc), new StreamResult(writer));\n75 +        return writer.toString();\n76 +    }\n77 +\n78 +    public Document createDocument(String rootElement) throws Exception {\n79 +        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n80 +        DocumentBuilder builder = factory.newDocumentBuilder();\n81 +        Document doc = builder.newDocument();\n82 +\n83 +        Element root = doc.createElement(rootElement);\n84 +        doc.appendChild(root);\n85 +\n86 +        return doc;\n87 +    }\n88 +}\n89 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in src/main/java/com/app/service/XmlParserService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();", "improvedCode": "DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        DocumentBuilder builder = factory.newDocumentBuilder();", "relevantFile": "src/main/java/com/app/service/XmlParserService.java", "relevantLinesEnd": 20, "suggestionContent": "The `parseXml` and `parseXmlFile` methods create `DocumentBuilderFactory` without disabling external entity processing. This allows XXE attacks where malicious XML like `<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>` can read local files or make network requests. Disable DTDs and external entities.", "oneSentenceSummary": "XXE vulnerability - external entities not disabled allows file disclosure", "relevantLinesStart": 19}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/config/ConfigurationManager.java", "language": "Java", "fileContent": "package com.app.config;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class ConfigurationManager {\n    private static final Logger logger = LoggerFactory.getLogger(ConfigurationManager.class);\n\n    private static ConfigurationManager instance;\n    private Properties config;\n    private long lastLoadTime;\n    private final String configPath;\n\n    private ConfigurationManager(String configPath) {\n        this.configPath = configPath;\n        this.config = new Properties();\n        loadConfig();\n    }\n\n    public static ConfigurationManager getInstance(String configPath) {\n        if (instance == null) {\n            synchronized (ConfigurationManager.class) {\n                if (instance == null) {\n                    instance = new ConfigurationManager(configPath);\n                }\n            }\n        }\n        return instance;\n    }\n\n    private void loadConfig() {\n        try (FileInputStream fis = new FileInputStream(configPath)) {\n            config.load(fis);\n            lastLoadTime = System.currentTimeMillis();\n            logger.info(\"Configuration loaded from {}\", configPath);\n        } catch (IOException e) {\n            logger.error(\"Failed to load configuration\", e);\n        }\n    }\n\n    public String get(String key) {\n        return config.getProperty(key);\n    }\n\n    public String get(String key, String defaultValue) {\n        return config.getProperty(key, defaultValue);\n    }\n\n    public int getInt(String key, int defaultValue) {\n        String value = config.getProperty(key);\n        if (value != null) {\n            try {\n                return Integer.parseInt(value);\n            } catch (NumberFormatException e) {\n                logger.warn(\"Invalid integer value for key {}: {}\", key, value);\n            }\n        }\n        return defaultValue;\n    }\n\n    public boolean getBoolean(String key, boolean defaultValue) {\n        String value = config.getProperty(key);\n        if (value != null) {\n            return Boolean.parseBoolean(value);\n        }\n        return defaultValue;\n    }\n\n    public void reload() {\n        loadConfig();\n    }\n\n    public long getLastLoadTime() {\n        return lastLoadTime;\n    }\n\n    public Set<String> getKeys() {\n        return config.stringPropertyNames();\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/config/ConfigurationManager.java'\n\n@@ -0,0 +1,84 @@\n__new hunk__\n1 +package com.app.config;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import java.io.*;\n7 +import java.util.*;\n8 +\n9 +public class ConfigurationManager {\n10 +    private static final Logger logger = LoggerFactory.getLogger(ConfigurationManager.class);\n11 +\n12 +    private static ConfigurationManager instance;\n13 +    private Properties config;\n14 +    private long lastLoadTime;\n15 +    private final String configPath;\n16 +\n17 +    private ConfigurationManager(String configPath) {\n18 +        this.configPath = configPath;\n19 +        this.config = new Properties();\n20 +        loadConfig();\n21 +    }\n22 +\n23 +    public static ConfigurationManager getInstance(String configPath) {\n24 +        if (instance == null) {\n25 +            synchronized (ConfigurationManager.class) {\n26 +                if (instance == null) {\n27 +                    instance = new ConfigurationManager(configPath);\n28 +                }\n29 +            }\n30 +        }\n31 +        return instance;\n32 +    }\n33 +\n34 +    private void loadConfig() {\n35 +        try (FileInputStream fis = new FileInputStream(configPath)) {\n36 +            config.load(fis);\n37 +            lastLoadTime = System.currentTimeMillis();\n38 +            logger.info(\"Configuration loaded from {}\", configPath);\n39 +        } catch (IOException e) {\n40 +            logger.error(\"Failed to load configuration\", e);\n41 +        }\n42 +    }\n43 +\n44 +    public String get(String key) {\n45 +        return config.getProperty(key);\n46 +    }\n47 +\n48 +    public String get(String key, String defaultValue) {\n49 +        return config.getProperty(key, defaultValue);\n50 +    }\n51 +\n52 +    public int getInt(String key, int defaultValue) {\n53 +        String value = config.getProperty(key);\n54 +        if (value != null) {\n55 +            try {\n56 +                return Integer.parseInt(value);\n57 +            } catch (NumberFormatException e) {\n58 +                logger.warn(\"Invalid integer value for key {}: {}\", key, value);\n59 +            }\n60 +        }\n61 +        return defaultValue;\n62 +    }\n63 +\n64 +    public boolean getBoolean(String key, boolean defaultValue) {\n65 +        String value = config.getProperty(key);\n66 +        if (value != null) {\n67 +            return Boolean.parseBoolean(value);\n68 +        }\n69 +        return defaultValue;\n70 +    }\n71 +\n72 +    public void reload() {\n73 +        loadConfig();\n74 +    }\n75 +\n76 +    public long getLastLoadTime() {\n77 +        return lastLoadTime;\n78 +    }\n79 +\n80 +    public Set<String> getKeys() {\n81 +        return config.stringPropertyNames();\n82 +    }\n83 +}\n84 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in src/main/java/com/app/config/ConfigurationManager.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "private static ConfigurationManager instance;", "improvedCode": "private static volatile ConfigurationManager instance;", "relevantFile": "src/main/java/com/app/config/ConfigurationManager.java", "relevantLinesEnd": 12, "suggestionContent": "The double-checked locking pattern is broken without `volatile` keyword on the `instance` field. Without volatile, a thread may see a partially constructed object due to instruction reordering. Thread A may publish the reference before the constructor finishes, and Thread B may use an incompletely initialized object. Add `volatile` to the instance field.", "oneSentenceSummary": "Double-checked locking without volatile - threads may see partially constructed object", "relevantLinesStart": 12}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/FileService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class FileService {\n    private static final Logger logger = LoggerFactory.getLogger(FileService.class);\n\n    private final Path baseDirectory;\n\n    public FileService(String baseDirectory) {\n        this.baseDirectory = Paths.get(baseDirectory);\n    }\n\n    public String readFile(String filename) throws IOException {\n        Path filePath = baseDirectory.resolve(filename);\n        FileInputStream fis = new FileInputStream(filePath.toFile());\n        InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);\n        BufferedReader reader = new BufferedReader(isr);\n\n        StringBuilder content = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            content.append(line).append(\"\\n\");\n        }\n\n        return content.toString();\n    }\n\n    public void writeFile(String filename, String content) throws IOException {\n        Path filePath = baseDirectory.resolve(filename);\n        FileOutputStream fos = new FileOutputStream(filePath.toFile());\n        OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\n        BufferedWriter writer = new BufferedWriter(osw);\n\n        writer.write(content);\n        writer.flush();\n    }\n\n    public Properties loadProperties(String filename) throws IOException {\n        Path filePath = baseDirectory.resolve(filename);\n        FileInputStream fis = new FileInputStream(filePath.toFile());\n\n        Properties props = new Properties();\n        props.load(fis);\n\n        return props;\n    }\n\n    public List<String> readLines(String filename) throws IOException {\n        Path filePath = baseDirectory.resolve(filename);\n        BufferedReader reader = Files.newBufferedReader(filePath);\n\n        List<String> lines = new ArrayList<>();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            lines.add(line);\n        }\n\n        return lines;\n    }\n\n    public void copyFile(String source, String destination) throws IOException {\n        Path sourcePath = baseDirectory.resolve(source);\n        Path destPath = baseDirectory.resolve(destination);\n\n        FileInputStream fis = new FileInputStream(sourcePath.toFile());\n        FileOutputStream fos = new FileOutputStream(destPath.toFile());\n\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            fos.write(buffer, 0, bytesRead);\n        }\n\n        fos.flush();\n    }\n\n    public byte[] readBinaryFile(String filename) throws IOException {\n        Path filePath = baseDirectory.resolve(filename);\n        return Files.readAllBytes(filePath);\n    }\n\n    public long getFileSize(String filename) throws IOException {\n        Path filePath = baseDirectory.resolve(filename);\n        return Files.size(filePath);\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/FileService.java'\n\n@@ -0,0 +1,96 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import java.io.*;\n7 +import java.nio.charset.StandardCharsets;\n8 +import java.nio.file.*;\n9 +import java.util.ArrayList;\n10 +import java.util.List;\n11 +import java.util.Properties;\n12 +\n13 +public class FileService {\n14 +    private static final Logger logger = LoggerFactory.getLogger(FileService.class);\n15 +\n16 +    private final Path baseDirectory;\n17 +\n18 +    public FileService(String baseDirectory) {\n19 +        this.baseDirectory = Paths.get(baseDirectory);\n20 +    }\n21 +\n22 +    public String readFile(String filename) throws IOException {\n23 +        Path filePath = baseDirectory.resolve(filename);\n24 +        FileInputStream fis = new FileInputStream(filePath.toFile());\n25 +        InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);\n26 +        BufferedReader reader = new BufferedReader(isr);\n27 +\n28 +        StringBuilder content = new StringBuilder();\n29 +        String line;\n30 +        while ((line = reader.readLine()) != null) {\n31 +            content.append(line).append(\"\\n\");\n32 +        }\n33 +\n34 +        return content.toString();\n35 +    }\n36 +\n37 +    public void writeFile(String filename, String content) throws IOException {\n38 +        Path filePath = baseDirectory.resolve(filename);\n39 +        FileOutputStream fos = new FileOutputStream(filePath.toFile());\n40 +        OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\n41 +        BufferedWriter writer = new BufferedWriter(osw);\n42 +\n43 +        writer.write(content);\n44 +        writer.flush();\n45 +    }\n46 +\n47 +    public Properties loadProperties(String filename) throws IOException {\n48 +        Path filePath = baseDirectory.resolve(filename);\n49 +        FileInputStream fis = new FileInputStream(filePath.toFile());\n50 +\n51 +        Properties props = new Properties();\n52 +        props.load(fis);\n53 +\n54 +        return props;\n55 +    }\n56 +\n57 +    public List<String> readLines(String filename) throws IOException {\n58 +        Path filePath = baseDirectory.resolve(filename);\n59 +        BufferedReader reader = Files.newBufferedReader(filePath);\n60 +\n61 +        List<String> lines = new ArrayList<>();\n62 +        String line;\n63 +        while ((line = reader.readLine()) != null) {\n64 +            lines.add(line);\n65 +        }\n66 +\n67 +        return lines;\n68 +    }\n69 +\n70 +    public void copyFile(String source, String destination) throws IOException {\n71 +        Path sourcePath = baseDirectory.resolve(source);\n72 +        Path destPath = baseDirectory.resolve(destination);\n73 +\n74 +        FileInputStream fis = new FileInputStream(sourcePath.toFile());\n75 +        FileOutputStream fos = new FileOutputStream(destPath.toFile());\n76 +\n77 +        byte[] buffer = new byte[8192];\n78 +        int bytesRead;\n79 +        while ((bytesRead = fis.read(buffer)) != -1) {\n80 +            fos.write(buffer, 0, bytesRead);\n81 +        }\n82 +\n83 +        fos.flush();\n84 +    }\n85 +\n86 +    public byte[] readBinaryFile(String filename) throws IOException {\n87 +        Path filePath = baseDirectory.resolve(filename);\n88 +        return Files.readAllBytes(filePath);\n89 +    }\n90 +\n91 +    public long getFileSize(String filename) throws IOException {\n92 +        Path filePath = baseDirectory.resolve(filename);\n93 +        return Files.size(filePath);\n94 +    }\n95 +}\n96 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/service/FileService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "FileInputStream fis = new FileInputStream(filePath.toFile());\n        InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);\n        BufferedReader reader = new BufferedReader(isr);", "improvedCode": "try (FileInputStream fis = new FileInputStream(filePath.toFile());\n             InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);\n             BufferedReader reader = new BufferedReader(isr)) {", "relevantFile": "src/main/java/com/app/service/FileService.java", "relevantLinesEnd": 25, "suggestionContent": "The `readFile` method opens `FileInputStream`, `InputStreamReader`, and `BufferedReader` but never closes them. If an exception occurs or even in normal execution, these resources leak. Use try-with-resources to ensure streams are closed.", "oneSentenceSummary": "Resource leak - FileInputStream and readers never closed in readFile", "relevantLinesStart": 23}, {"label": "bug", "language": "Java", "existingCode": "FileOutputStream fos = new FileOutputStream(filePath.toFile());\n        OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\n        BufferedWriter writer = new BufferedWriter(osw);\n        \n        writer.write(content);\n        writer.flush();", "improvedCode": "try (FileOutputStream fos = new FileOutputStream(filePath.toFile());\n             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\n             BufferedWriter writer = new BufferedWriter(osw)) {\n            writer.write(content);\n        }", "relevantFile": "src/main/java/com/app/service/FileService.java", "relevantLinesEnd": 43, "suggestionContent": "The `writeFile` method creates streams but never closes them. The `flush()` is called but not `close()`. This leaks file handles and data may not be fully written to disk.", "oneSentenceSummary": "Resource leak - output streams never closed in writeFile", "relevantLinesStart": 38}, {"label": "bug", "language": "Java", "existingCode": "FileInputStream fis = new FileInputStream(sourcePath.toFile());\n        FileOutputStream fos = new FileOutputStream(destPath.toFile());", "improvedCode": "try (FileInputStream fis = new FileInputStream(sourcePath.toFile());\n             FileOutputStream fos = new FileOutputStream(destPath.toFile())) {", "relevantFile": "src/main/java/com/app/service/FileService.java", "relevantLinesEnd": 72, "suggestionContent": "The `copyFile` method opens both input and output streams but never closes them. This causes file handle leaks and the destination file may not be fully written.", "oneSentenceSummary": "Resource leak - streams never closed in copyFile method", "relevantLinesStart": 71}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/auth/LdapAuthService.java", "language": "Java", "fileContent": "package com.app.auth;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.naming.*;\nimport javax.naming.directory.*;\nimport java.util.*;\n\npublic class LdapAuthService {\n    private static final Logger logger = LoggerFactory.getLogger(LdapAuthService.class);\n\n    private final String ldapUrl;\n    private final String baseDn;\n    private final String adminDn;\n    private final String adminPassword;\n\n    public LdapAuthService(String ldapUrl, String baseDn, String adminDn, String adminPassword) {\n        this.ldapUrl = ldapUrl;\n        this.baseDn = baseDn;\n        this.adminDn = adminDn;\n        this.adminPassword = adminPassword;\n    }\n\n    public boolean authenticate(String username, String password) {\n        try {\n            DirContext ctx = getAdminContext();\n            String filter = \"(uid=\" + username + \")\";\n\n            SearchControls controls = new SearchControls();\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n            NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, controls);\n\n            if (results.hasMore()) {\n                SearchResult result = results.next();\n                String userDn = result.getNameInNamespace();\n\n                try {\n                    DirContext userCtx = getUserContext(userDn, password);\n                    userCtx.close();\n                    return true;\n                } catch (AuthenticationException e) {\n                    logger.warn(\"Authentication failed for user: {}\", username);\n                    return false;\n                }\n            }\n\n            ctx.close();\n            return false;\n        } catch (NamingException e) {\n            logger.error(\"LDAP error during authentication\", e);\n            return false;\n        }\n    }\n\n    public Map<String, String> getUserAttributes(String username) {\n        Map<String, String> attributes = new HashMap<>();\n\n        try {\n            DirContext ctx = getAdminContext();\n            String filter = \"(&(objectClass=person)(uid=\" + username + \"))\";\n\n            SearchControls controls = new SearchControls();\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n            NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, controls);\n\n            if (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n\n                NamingEnumeration<? extends Attribute> allAttrs = attrs.getAll();\n                while (allAttrs.hasMore()) {\n                    Attribute attr = allAttrs.next();\n                    attributes.put(attr.getID(), attr.get().toString());\n                }\n            }\n\n            ctx.close();\n        } catch (NamingException e) {\n            logger.error(\"Error fetching user attributes\", e);\n        }\n\n        return attributes;\n    }\n\n    public List<String> searchUsers(String searchTerm) {\n        List<String> users = new ArrayList<>();\n\n        try {\n            DirContext ctx = getAdminContext();\n            String filter = \"(|(uid=*\" + searchTerm + \"*)(cn=*\" + searchTerm + \"*))\";\n\n            SearchControls controls = new SearchControls();\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            controls.setReturningAttributes(new String[]{\"uid\"});\n\n            NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, controls);\n\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                users.add(result.getAttributes().get(\"uid\").get().toString());\n            }\n\n            ctx.close();\n        } catch (NamingException e) {\n            logger.error(\"Error searching users\", e);\n        }\n\n        return users;\n    }\n\n    private DirContext getAdminContext() throws NamingException {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, ldapUrl);\n        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        env.put(Context.SECURITY_PRINCIPAL, adminDn);\n        env.put(Context.SECURITY_CREDENTIALS, adminPassword);\n        return new InitialDirContext(env);\n    }\n\n    private DirContext getUserContext(String userDn, String password) throws NamingException {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, ldapUrl);\n        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        env.put(Context.SECURITY_PRINCIPAL, userDn);\n        env.put(Context.SECURITY_CREDENTIALS, password);\n        return new InitialDirContext(env);\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/auth/LdapAuthService.java'\n\n@@ -0,0 +1,134 @@\n__new hunk__\n1 +package com.app.auth;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import javax.naming.*;\n7 +import javax.naming.directory.*;\n8 +import java.util.*;\n9 +\n10 +public class LdapAuthService {\n11 +    private static final Logger logger = LoggerFactory.getLogger(LdapAuthService.class);\n12 +\n13 +    private final String ldapUrl;\n14 +    private final String baseDn;\n15 +    private final String adminDn;\n16 +    private final String adminPassword;\n17 +\n18 +    public LdapAuthService(String ldapUrl, String baseDn, String adminDn, String adminPassword) {\n19 +        this.ldapUrl = ldapUrl;\n20 +        this.baseDn = baseDn;\n21 +        this.adminDn = adminDn;\n22 +        this.adminPassword = adminPassword;\n23 +    }\n24 +\n25 +    public boolean authenticate(String username, String password) {\n26 +        try {\n27 +            DirContext ctx = getAdminContext();\n28 +            String filter = \"(uid=\" + username + \")\";\n29 +\n30 +            SearchControls controls = new SearchControls();\n31 +            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n32 +\n33 +            NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, controls);\n34 +\n35 +            if (results.hasMore()) {\n36 +                SearchResult result = results.next();\n37 +                String userDn = result.getNameInNamespace();\n38 +\n39 +                try {\n40 +                    DirContext userCtx = getUserContext(userDn, password);\n41 +                    userCtx.close();\n42 +                    return true;\n43 +                } catch (AuthenticationException e) {\n44 +                    logger.warn(\"Authentication failed for user: {}\", username);\n45 +                    return false;\n46 +                }\n47 +            }\n48 +\n49 +            ctx.close();\n50 +            return false;\n51 +        } catch (NamingException e) {\n52 +            logger.error(\"LDAP error during authentication\", e);\n53 +            return false;\n54 +        }\n55 +    }\n56 +\n57 +    public Map<String, String> getUserAttributes(String username) {\n58 +        Map<String, String> attributes = new HashMap<>();\n59 +\n60 +        try {\n61 +            DirContext ctx = getAdminContext();\n62 +            String filter = \"(&(objectClass=person)(uid=\" + username + \"))\";\n63 +\n64 +            SearchControls controls = new SearchControls();\n65 +            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n66 +\n67 +            NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, controls);\n68 +\n69 +            if (results.hasMore()) {\n70 +                SearchResult result = results.next();\n71 +                Attributes attrs = result.getAttributes();\n72 +\n73 +                NamingEnumeration<? extends Attribute> allAttrs = attrs.getAll();\n74 +                while (allAttrs.hasMore()) {\n75 +                    Attribute attr = allAttrs.next();\n76 +                    attributes.put(attr.getID(), attr.get().toString());\n77 +                }\n78 +            }\n79 +\n80 +            ctx.close();\n81 +        } catch (NamingException e) {\n82 +            logger.error(\"Error fetching user attributes\", e);\n83 +        }\n84 +\n85 +        return attributes;\n86 +    }\n87 +\n88 +    public List<String> searchUsers(String searchTerm) {\n89 +        List<String> users = new ArrayList<>();\n90 +\n91 +        try {\n92 +            DirContext ctx = getAdminContext();\n93 +            String filter = \"(|(uid=*\" + searchTerm + \"*)(cn=*\" + searchTerm + \"*))\";\n94 +\n95 +            SearchControls controls = new SearchControls();\n96 +            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n97 +            controls.setReturningAttributes(new String[]{\"uid\"});\n98 +\n99 +            NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, controls);\n100 +\n101 +            while (results.hasMore()) {\n102 +                SearchResult result = results.next();\n103 +                users.add(result.getAttributes().get(\"uid\").get().toString());\n104 +            }\n105 +\n106 +            ctx.close();\n107 +        } catch (NamingException e) {\n108 +            logger.error(\"Error searching users\", e);\n109 +        }\n110 +\n111 +        return users;\n112 +    }\n113 +\n114 +    private DirContext getAdminContext() throws NamingException {\n115 +        Hashtable<String, String> env = new Hashtable<>();\n116 +        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n117 +        env.put(Context.PROVIDER_URL, ldapUrl);\n118 +        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n119 +        env.put(Context.SECURITY_PRINCIPAL, adminDn);\n120 +        env.put(Context.SECURITY_CREDENTIALS, adminPassword);\n121 +        return new InitialDirContext(env);\n122 +    }\n123 +\n124 +    private DirContext getUserContext(String userDn, String password) throws NamingException {\n125 +        Hashtable<String, String> env = new Hashtable<>();\n126 +        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n127 +        env.put(Context.PROVIDER_URL, ldapUrl);\n128 +        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n129 +        env.put(Context.SECURITY_PRINCIPAL, userDn);\n130 +        env.put(Context.SECURITY_CREDENTIALS, password);\n131 +        return new InitialDirContext(env);\n132 +    }\n133 +}\n134 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in src/main/java/com/app/auth/LdapAuthService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "String filter = \"(uid=\" + username + \")\";", "improvedCode": "String sanitizedUsername = sanitizeLdapInput(username);\nString filter = \"(uid=\" + sanitizedUsername + \")\";\n\n// Add helper method:\nprivate String sanitizeLdapInput(String input) {\n    return input.replace(\"\\\\\", \"\\\\5c\")\n                .replace(\"*\", \"\\\\2a\")\n                .replace(\"(\", \"\\\\28\")\n                .replace(\")\", \"\\\\29\")\n                .replace(\"\\0\", \"\\\\00\");\n}", "relevantFile": "src/main/java/com/app/auth/LdapAuthService.java", "relevantLinesEnd": 27, "suggestionContent": "The `authenticate` method concatenates `username` directly into the LDAP filter string without sanitization. An attacker can input `*)(uid=*))(|(uid=*` to modify the filter logic, potentially bypassing authentication or extracting data. Escape special LDAP characters or use parameterized searches.", "oneSentenceSummary": "LDAP injection in authentication - user input in filter allows authentication bypass", "relevantLinesStart": 27}, {"label": "bug", "language": "Java", "existingCode": "String filter = \"(|(uid=*\" + searchTerm + \"*)(cn=*\" + searchTerm + \"*))\";", "improvedCode": "String sanitized = sanitizeLdapInput(searchTerm);\nString filter = \"(|(uid=*\" + sanitized + \"*)(cn=*\" + sanitized + \"*))\";", "relevantFile": "src/main/java/com/app/auth/LdapAuthService.java", "relevantLinesEnd": 88, "suggestionContent": "The `searchUsers` method has the same LDAP injection vulnerability. An attacker can inject `*)(objectClass=*` to retrieve all objects in the directory, potentially exposing sensitive information.", "oneSentenceSummary": "LDAP injection in search allows extracting entire directory contents", "relevantLinesStart": 88}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/InventoryService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport com.app.model.Product;\nimport com.app.model.InventoryItem;\nimport com.app.repository.InventoryRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class InventoryService {\n    private static final Logger logger = LoggerFactory.getLogger(InventoryService.class);\n\n    private final InventoryRepository repository;\n    private final Map<Integer, InventoryItem> cache = new HashMap<>();\n\n    public InventoryService(InventoryRepository repository) {\n        this.repository = repository;\n    }\n\n    public void addStock(Integer productId, Integer quantity) {\n        InventoryItem item = cache.get(productId);\n        if (item == null) {\n            item = repository.findByProductId(productId)\n                .orElse(new InventoryItem(productId, 0));\n        }\n        item.setQuantity(item.getQuantity() + quantity);\n        cache.put(productId, item);\n        repository.save(item);\n    }\n\n    public boolean checkQuantityMatch(Integer requested, Integer available) {\n        if (requested == available) {\n            return true;\n        }\n        return requested <= available;\n    }\n\n    public boolean isLowStock(Integer productId, Integer threshold) {\n        InventoryItem item = cache.get(productId);\n        if (item == null) {\n            return false;\n        }\n        Integer currentStock = item.getQuantity();\n        return currentStock == threshold || currentStock < threshold;\n    }\n\n    public Map<Integer, String> categorizeStock(Map<Integer, Integer> stockLevels) {\n        Map<Integer, String> categories = new HashMap<>();\n        Integer lowThreshold = 10;\n        Integer mediumThreshold = 50;\n        Integer highThreshold = 200;\n\n        for (Map.Entry<Integer, Integer> entry : stockLevels.entrySet()) {\n            Integer level = entry.getValue();\n            String category;\n\n            if (level == lowThreshold) {\n                category = \"LOW_BOUNDARY\";\n            } else if (level < lowThreshold) {\n                category = \"CRITICAL\";\n            } else if (level == mediumThreshold) {\n                category = \"MEDIUM_BOUNDARY\";\n            } else if (level < mediumThreshold) {\n                category = \"LOW\";\n            } else if (level == highThreshold) {\n                category = \"HIGH_BOUNDARY\";\n            } else if (level < highThreshold) {\n                category = \"MEDIUM\";\n            } else {\n                category = \"HIGH\";\n            }\n\n            categories.put(entry.getKey(), category);\n        }\n\n        return categories;\n    }\n\n    public void processReorder(Integer productId, Integer reorderPoint) {\n        InventoryItem item = cache.get(productId);\n        if (item != null && item.getQuantity() == reorderPoint) {\n            logger.info(\"Triggering reorder for product {}\", productId);\n            triggerReorder(productId);\n        }\n    }\n\n    private void triggerReorder(Integer productId) {\n        // Reorder logic\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/InventoryService.java'\n\n@@ -0,0 +1,94 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import com.app.model.Product;\n4 +import com.app.model.InventoryItem;\n5 +import com.app.repository.InventoryRepository;\n6 +import org.slf4j.Logger;\n7 +import org.slf4j.LoggerFactory;\n8 +\n9 +import java.util.HashMap;\n10 +import java.util.Map;\n11 +import java.util.Optional;\n12 +\n13 +public class InventoryService {\n14 +    private static final Logger logger = LoggerFactory.getLogger(InventoryService.class);\n15 +\n16 +    private final InventoryRepository repository;\n17 +    private final Map<Integer, InventoryItem> cache = new HashMap<>();\n18 +\n19 +    public InventoryService(InventoryRepository repository) {\n20 +        this.repository = repository;\n21 +    }\n22 +\n23 +    public void addStock(Integer productId, Integer quantity) {\n24 +        InventoryItem item = cache.get(productId);\n25 +        if (item == null) {\n26 +            item = repository.findByProductId(productId)\n27 +                .orElse(new InventoryItem(productId, 0));\n28 +        }\n29 +        item.setQuantity(item.getQuantity() + quantity);\n30 +        cache.put(productId, item);\n31 +        repository.save(item);\n32 +    }\n33 +\n34 +    public boolean checkQuantityMatch(Integer requested, Integer available) {\n35 +        if (requested == available) {\n36 +            return true;\n37 +        }\n38 +        return requested <= available;\n39 +    }\n40 +\n41 +    public boolean isLowStock(Integer productId, Integer threshold) {\n42 +        InventoryItem item = cache.get(productId);\n43 +        if (item == null) {\n44 +            return false;\n45 +        }\n46 +        Integer currentStock = item.getQuantity();\n47 +        return currentStock == threshold || currentStock < threshold;\n48 +    }\n49 +\n50 +    public Map<Integer, String> categorizeStock(Map<Integer, Integer> stockLevels) {\n51 +        Map<Integer, String> categories = new HashMap<>();\n52 +        Integer lowThreshold = 10;\n53 +        Integer mediumThreshold = 50;\n54 +        Integer highThreshold = 200;\n55 +\n56 +        for (Map.Entry<Integer, Integer> entry : stockLevels.entrySet()) {\n57 +            Integer level = entry.getValue();\n58 +            String category;\n59 +\n60 +            if (level == lowThreshold) {\n61 +                category = \"LOW_BOUNDARY\";\n62 +            } else if (level < lowThreshold) {\n63 +                category = \"CRITICAL\";\n64 +            } else if (level == mediumThreshold) {\n65 +                category = \"MEDIUM_BOUNDARY\";\n66 +            } else if (level < mediumThreshold) {\n67 +                category = \"LOW\";\n68 +            } else if (level == highThreshold) {\n69 +                category = \"HIGH_BOUNDARY\";\n70 +            } else if (level < highThreshold) {\n71 +                category = \"MEDIUM\";\n72 +            } else {\n73 +                category = \"HIGH\";\n74 +            }\n75 +\n76 +            categories.put(entry.getKey(), category);\n77 +        }\n78 +\n79 +        return categories;\n80 +    }\n81 +\n82 +    public void processReorder(Integer productId, Integer reorderPoint) {\n83 +        InventoryItem item = cache.get(productId);\n84 +        if (item != null && item.getQuantity() == reorderPoint) {\n85 +            logger.info(\"Triggering reorder for product {}\", productId);\n86 +            triggerReorder(productId);\n87 +        }\n88 +    }\n89 +\n90 +    private void triggerReorder(Integer productId) {\n91 +        // Reorder logic\n92 +    }\n93 +}\n94 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in src/main/java/com/app/service/InventoryService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "if (requested == available) {", "improvedCode": "if (requested.equals(available)) {", "relevantFile": "src/main/java/com/app/service/InventoryService.java", "relevantLinesEnd": 34, "suggestionContent": "Multiple methods compare `Integer` objects using `==` operator. Java caches Integer values from -128 to 127, so `==` works for small numbers but fails for larger values. For example, `Integer a = 200; Integer b = 200; a == b` is `false` because they're different objects. The `checkQuantityMatch`, `isLowStock`, `categorizeStock`, and `processReorder` methods all have this bug. Use `.equals()` or unbox to primitive `int` for comparison.", "oneSentenceSummary": "Integer comparison with == fails for values outside -128 to 127 cache range", "relevantLinesStart": 34}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/PaymentService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport com.app.model.Payment;\nimport com.app.model.Order;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.List;\n\npublic class PaymentService {\n    private static final Logger logger = LoggerFactory.getLogger(PaymentService.class);\n\n    private static final BigDecimal TAX_RATE = new BigDecimal(\"0.08\");\n    private static final BigDecimal DISCOUNT_THRESHOLD = new BigDecimal(\"100.00\");\n    private static final BigDecimal DISCOUNT_RATE = new BigDecimal(\"0.10\");\n\n    public BigDecimal calculateTotal(List<BigDecimal> itemPrices) {\n        BigDecimal total = BigDecimal.ZERO;\n        for (BigDecimal price : itemPrices) {\n            total = total.add(price);\n        }\n        return total;\n    }\n\n    public BigDecimal applyDiscount(BigDecimal total) {\n        if (total.equals(DISCOUNT_THRESHOLD) || total.compareTo(DISCOUNT_THRESHOLD) > 0) {\n            BigDecimal discount = total.multiply(DISCOUNT_RATE);\n            return total.subtract(discount);\n        }\n        return total;\n    }\n\n    public BigDecimal calculateTax(BigDecimal amount) {\n        return amount.multiply(TAX_RATE).setScale(2, RoundingMode.HALF_UP);\n    }\n\n    public boolean isRefundEligible(BigDecimal paidAmount, BigDecimal refundAmount) {\n        return refundAmount.compareTo(paidAmount) <= 0;\n    }\n\n    public boolean verifyPayment(BigDecimal expected, BigDecimal actual) {\n        if (expected.equals(actual)) {\n            return true;\n        }\n        logger.warn(\"Payment mismatch: expected {}, actual {}\", expected, actual);\n        return false;\n    }\n\n    public BigDecimal splitPayment(BigDecimal total, int numberOfPeople) {\n        return total.divide(new BigDecimal(numberOfPeople), 2, RoundingMode.HALF_UP);\n    }\n\n    public boolean isZeroBalance(BigDecimal balance) {\n        return balance.equals(BigDecimal.ZERO);\n    }\n\n    public BigDecimal calculateChange(BigDecimal paid, BigDecimal owed) {\n        BigDecimal change = paid.subtract(owed);\n        if (change.equals(new BigDecimal(\"0.00\"))) {\n            return BigDecimal.ZERO;\n        }\n        return change;\n    }\n\n    public int compareAmounts(BigDecimal a, BigDecimal b) {\n        if (a.equals(b)) {\n            return 0;\n        }\n        return a.compareTo(b);\n    }\n\n    public void processPayment(Order order, BigDecimal paymentAmount) {\n        BigDecimal orderTotal = order.getTotal();\n\n        if (paymentAmount.equals(orderTotal)) {\n            logger.info(\"Exact payment received\");\n            order.setStatus(\"PAID\");\n        } else if (paymentAmount.compareTo(orderTotal) > 0) {\n            BigDecimal change = paymentAmount.subtract(orderTotal);\n            logger.info(\"Change due: {}\", change);\n            order.setStatus(\"PAID\");\n        } else {\n            logger.warn(\"Insufficient payment\");\n        }\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/PaymentService.java'\n\n@@ -0,0 +1,89 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import com.app.model.Payment;\n4 +import com.app.model.Order;\n5 +import org.slf4j.Logger;\n6 +import org.slf4j.LoggerFactory;\n7 +\n8 +import java.math.BigDecimal;\n9 +import java.math.RoundingMode;\n10 +import java.util.List;\n11 +\n12 +public class PaymentService {\n13 +    private static final Logger logger = LoggerFactory.getLogger(PaymentService.class);\n14 +\n15 +    private static final BigDecimal TAX_RATE = new BigDecimal(\"0.08\");\n16 +    private static final BigDecimal DISCOUNT_THRESHOLD = new BigDecimal(\"100.00\");\n17 +    private static final BigDecimal DISCOUNT_RATE = new BigDecimal(\"0.10\");\n18 +\n19 +    public BigDecimal calculateTotal(List<BigDecimal> itemPrices) {\n20 +        BigDecimal total = BigDecimal.ZERO;\n21 +        for (BigDecimal price : itemPrices) {\n22 +            total = total.add(price);\n23 +        }\n24 +        return total;\n25 +    }\n26 +\n27 +    public BigDecimal applyDiscount(BigDecimal total) {\n28 +        if (total.equals(DISCOUNT_THRESHOLD) || total.compareTo(DISCOUNT_THRESHOLD) > 0) {\n29 +            BigDecimal discount = total.multiply(DISCOUNT_RATE);\n30 +            return total.subtract(discount);\n31 +        }\n32 +        return total;\n33 +    }\n34 +\n35 +    public BigDecimal calculateTax(BigDecimal amount) {\n36 +        return amount.multiply(TAX_RATE).setScale(2, RoundingMode.HALF_UP);\n37 +    }\n38 +\n39 +    public boolean isRefundEligible(BigDecimal paidAmount, BigDecimal refundAmount) {\n40 +        return refundAmount.compareTo(paidAmount) <= 0;\n41 +    }\n42 +\n43 +    public boolean verifyPayment(BigDecimal expected, BigDecimal actual) {\n44 +        if (expected.equals(actual)) {\n45 +            return true;\n46 +        }\n47 +        logger.warn(\"Payment mismatch: expected {}, actual {}\", expected, actual);\n48 +        return false;\n49 +    }\n50 +\n51 +    public BigDecimal splitPayment(BigDecimal total, int numberOfPeople) {\n52 +        return total.divide(new BigDecimal(numberOfPeople), 2, RoundingMode.HALF_UP);\n53 +    }\n54 +\n55 +    public boolean isZeroBalance(BigDecimal balance) {\n56 +        return balance.equals(BigDecimal.ZERO);\n57 +    }\n58 +\n59 +    public BigDecimal calculateChange(BigDecimal paid, BigDecimal owed) {\n60 +        BigDecimal change = paid.subtract(owed);\n61 +        if (change.equals(new BigDecimal(\"0.00\"))) {\n62 +            return BigDecimal.ZERO;\n63 +        }\n64 +        return change;\n65 +    }\n66 +\n67 +    public int compareAmounts(BigDecimal a, BigDecimal b) {\n68 +        if (a.equals(b)) {\n69 +            return 0;\n70 +        }\n71 +        return a.compareTo(b);\n72 +    }\n73 +\n74 +    public void processPayment(Order order, BigDecimal paymentAmount) {\n75 +        BigDecimal orderTotal = order.getTotal();\n76 +\n77 +        if (paymentAmount.equals(orderTotal)) {\n78 +            logger.info(\"Exact payment received\");\n79 +            order.setStatus(\"PAID\");\n80 +        } else if (paymentAmount.compareTo(orderTotal) > 0) {\n81 +            BigDecimal change = paymentAmount.subtract(orderTotal);\n82 +            logger.info(\"Change due: {}\", change);\n83 +            order.setStatus(\"PAID\");\n84 +        } else {\n85 +            logger.warn(\"Insufficient payment\");\n86 +        }\n87 +    }\n88 +}\n89 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/service/PaymentService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "if (expected.equals(actual)) {\n            return true;\n        }", "improvedCode": "if (expected.compareTo(actual) == 0) {\n            return true;\n        }", "relevantFile": "src/main/java/com/app/service/PaymentService.java", "relevantLinesEnd": 45, "suggestionContent": "The `verifyPayment` method uses `equals()` to compare BigDecimal values. However, BigDecimal's `equals()` considers scale, so `new BigDecimal(\"10.0\").equals(new BigDecimal(\"10.00\"))` is `false`. Use `compareTo() == 0` for numeric equality.", "oneSentenceSummary": "BigDecimal.equals() compares scale - 10.0 and 10.00 are considered not equal", "relevantLinesStart": 43}, {"label": "bug", "language": "Java", "existingCode": "return balance.equals(BigDecimal.ZERO);", "improvedCode": "return balance.compareTo(BigDecimal.ZERO) == 0;", "relevantFile": "src/main/java/com/app/service/PaymentService.java", "relevantLinesEnd": 54, "suggestionContent": "The `isZeroBalance` method uses `equals(BigDecimal.ZERO)` which fails for zero values with different scales like `0.00`. A balance of `new BigDecimal(\"0.00\")` would incorrectly be considered non-zero.", "oneSentenceSummary": "Zero check fails for BigDecimal with scale - 0.00 not equal to ZERO", "relevantLinesStart": 54}, {"label": "bug", "language": "Java", "existingCode": "if (paymentAmount.equals(orderTotal)) {", "improvedCode": "if (paymentAmount.compareTo(orderTotal) == 0) {", "relevantFile": "src/main/java/com/app/service/PaymentService.java", "relevantLinesEnd": 73, "suggestionContent": "The `processPayment` method uses `equals()` to compare payment amount with order total. If one has scale 2 (e.g., 100.00) and other has scale 1 (e.g., 100.0), exact payments will be rejected as insufficient.", "oneSentenceSummary": "Payment verification fails due to BigDecimal scale mismatch", "relevantLinesStart": 73}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/DataService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport com.app.model.DataRecord;\nimport com.app.repository.DataRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\n\npublic class DataService {\n    private static final Logger logger = LoggerFactory.getLogger(DataService.class);\n\n    private final DataRepository repository;\n\n    public DataService(DataRepository repository) {\n        this.repository = repository;\n    }\n\n    public DataRecord findById(String id) {\n        try {\n            return repository.findById(id).orElse(null);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public List<DataRecord> findAll() {\n        try {\n            return repository.findAll();\n        } catch (Throwable t) {\n            logger.error(\"Error fetching data\");\n            return Collections.emptyList();\n        }\n    }\n\n    public void saveRecord(DataRecord record) {\n        try {\n            validateRecord(record);\n            repository.save(record);\n        } catch (Exception e) {\n            // Log and continue\n            e.printStackTrace();\n        }\n    }\n\n    public void deleteRecord(String id) {\n        try {\n            repository.deleteById(id);\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage());\n        }\n    }\n\n    public void processRecords(List<DataRecord> records) {\n        for (DataRecord record : records) {\n            try {\n                repository.save(record);\n            } catch (Exception e) {\n                // Ignore and continue with next record\n            }\n        }\n    }\n\n    public boolean updateRecord(DataRecord record) {\n        try {\n            repository.save(record);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private void validateRecord(DataRecord record) throws Exception {\n        if (record.getId() == null) {\n            throw new Exception(\"ID is required\");\n        }\n        if (record.getName() == null || record.getName().isEmpty()) {\n            throw new Exception(\"Name is required\");\n        }\n    }\n\n    public DataRecord findOrCreate(String id, DataRecord defaultRecord) {\n        try {\n            Optional<DataRecord> existing = repository.findById(id);\n            if (existing.isPresent()) {\n                return existing.get();\n            }\n            return repository.save(defaultRecord);\n        } catch (Exception e) {\n            logger.error(\"Error in findOrCreate\", e);\n            return defaultRecord;\n        }\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/DataService.java'\n\n@@ -0,0 +1,95 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import com.app.model.DataRecord;\n4 +import com.app.repository.DataRepository;\n5 +import org.slf4j.Logger;\n6 +import org.slf4j.LoggerFactory;\n7 +\n8 +import java.util.*;\n9 +\n10 +public class DataService {\n11 +    private static final Logger logger = LoggerFactory.getLogger(DataService.class);\n12 +\n13 +    private final DataRepository repository;\n14 +\n15 +    public DataService(DataRepository repository) {\n16 +        this.repository = repository;\n17 +    }\n18 +\n19 +    public DataRecord findById(String id) {\n20 +        try {\n21 +            return repository.findById(id).orElse(null);\n22 +        } catch (Exception e) {\n23 +            return null;\n24 +        }\n25 +    }\n26 +\n27 +    public List<DataRecord> findAll() {\n28 +        try {\n29 +            return repository.findAll();\n30 +        } catch (Throwable t) {\n31 +            logger.error(\"Error fetching data\");\n32 +            return Collections.emptyList();\n33 +        }\n34 +    }\n35 +\n36 +    public void saveRecord(DataRecord record) {\n37 +        try {\n38 +            validateRecord(record);\n39 +            repository.save(record);\n40 +        } catch (Exception e) {\n41 +            // Log and continue\n42 +            e.printStackTrace();\n43 +        }\n44 +    }\n45 +\n46 +    public void deleteRecord(String id) {\n47 +        try {\n48 +            repository.deleteById(id);\n49 +        } catch (Exception e) {\n50 +            throw new RuntimeException(e.getMessage());\n51 +        }\n52 +    }\n53 +\n54 +    public void processRecords(List<DataRecord> records) {\n55 +        for (DataRecord record : records) {\n56 +            try {\n57 +                repository.save(record);\n58 +            } catch (Exception e) {\n59 +                // Ignore and continue with next record\n60 +            }\n61 +        }\n62 +    }\n63 +\n64 +    public boolean updateRecord(DataRecord record) {\n65 +        try {\n66 +            repository.save(record);\n67 +            return true;\n68 +        } catch (Exception e) {\n69 +            return false;\n70 +        }\n71 +    }\n72 +\n73 +    private void validateRecord(DataRecord record) throws Exception {\n74 +        if (record.getId() == null) {\n75 +            throw new Exception(\"ID is required\");\n76 +        }\n77 +        if (record.getName() == null || record.getName().isEmpty()) {\n78 +            throw new Exception(\"Name is required\");\n79 +        }\n80 +    }\n81 +\n82 +    public DataRecord findOrCreate(String id, DataRecord defaultRecord) {\n83 +        try {\n84 +            Optional<DataRecord> existing = repository.findById(id);\n85 +            if (existing.isPresent()) {\n86 +                return existing.get();\n87 +            }\n88 +            return repository.save(defaultRecord);\n89 +        } catch (Exception e) {\n90 +            logger.error(\"Error in findOrCreate\", e);\n91 +            return defaultRecord;\n92 +        }\n93 +    }\n94 +}\n95 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/service/DataService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "} catch (Throwable t) {\n            logger.error(\"Error fetching data\");\n            return Collections.emptyList();\n        }", "improvedCode": "} catch (Exception e) {\n            logger.error(\"Error fetching data\", e);\n            return Collections.emptyList();\n        }", "relevantFile": "src/main/java/com/app/service/DataService.java", "relevantLinesEnd": 32, "suggestionContent": "The `findAll` method catches `Throwable` which includes `Error` types like `OutOfMemoryError` and `StackOverflowError`. These should not be caught as they indicate serious JVM problems. Also, the error message doesn't include the exception details. Catch `Exception` and include the cause in logs.", "oneSentenceSummary": "Catching Throwable swallows critical JVM errors - should only catch Exception", "relevantLinesStart": 30}, {"label": "bug", "language": "Java", "existingCode": "} catch (Exception e) {\n            // Log and continue\n            e.printStackTrace();\n        }", "improvedCode": "} catch (Exception e) {\n            logger.error(\"Failed to save record: {}\", record.getId(), e);\n            throw new ServiceException(\"Failed to save record\", e);\n        }", "relevantFile": "src/main/java/com/app/service/DataService.java", "relevantLinesEnd": 43, "suggestionContent": "The `saveRecord` method uses `e.printStackTrace()` which writes to stderr without any context and isn't captured by logging frameworks. Silent failures make debugging impossible. Also catches generic Exception and swallows it.", "oneSentenceSummary": "printStackTrace() instead of logging and swallowing exception hides failures", "relevantLinesStart": 40}, {"label": "bug", "language": "Java", "existingCode": "throw new RuntimeException(e.getMessage());", "improvedCode": "throw new RuntimeException(\"Failed to delete record: \" + id, e);", "relevantFile": "src/main/java/com/app/service/DataService.java", "relevantLinesEnd": 49, "suggestionContent": "The `deleteRecord` method creates a new `RuntimeException` with only the message, losing the original exception's stack trace. This makes debugging the root cause impossible. Use exception chaining: `new RuntimeException(message, cause)`.", "oneSentenceSummary": "Exception wrapping loses original stack trace - root cause untraceable", "relevantLinesStart": 49}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/CounterService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class CounterService {\n    private static final Logger logger = LoggerFactory.getLogger(CounterService.class);\n\n    private int globalCounter = 0;\n    private final Map<String, Integer> namedCounters = new HashMap<>();\n    private final Map<String, Long> timestamps = new ConcurrentHashMap<>();\n\n    private static CounterService instance;\n\n    private CounterService() {}\n\n    public static CounterService getInstance() {\n        if (instance == null) {\n            instance = new CounterService();\n        }\n        return instance;\n    }\n\n    public int incrementGlobal() {\n        globalCounter++;\n        return globalCounter;\n    }\n\n    public int getGlobalCount() {\n        return globalCounter;\n    }\n\n    public void increment(String name) {\n        Integer current = namedCounters.get(name);\n        if (current == null) {\n            current = 0;\n        }\n        namedCounters.put(name, current + 1);\n        timestamps.put(name, System.currentTimeMillis());\n    }\n\n    public int getCount(String name) {\n        Integer count = namedCounters.get(name);\n        return count != null ? count : 0;\n    }\n\n    public void reset(String name) {\n        namedCounters.remove(name);\n        timestamps.remove(name);\n    }\n\n    public void resetAll() {\n        namedCounters.clear();\n        timestamps.clear();\n        globalCounter = 0;\n    }\n\n    public Map<String, Integer> getAllCounts() {\n        return new HashMap<>(namedCounters);\n    }\n\n    public boolean checkAndIncrement(String name, int threshold) {\n        int current = getCount(name);\n        if (current < threshold) {\n            increment(name);\n            return true;\n        }\n        return false;\n    }\n\n    public void transferCount(String from, String to) {\n        int fromCount = getCount(from);\n        int toCount = getCount(to);\n\n        namedCounters.put(to, toCount + fromCount);\n        namedCounters.remove(from);\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/CounterService.java'\n\n@@ -0,0 +1,83 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import java.util.HashMap;\n7 +import java.util.Map;\n8 +import java.util.concurrent.ConcurrentHashMap;\n9 +\n10 +public class CounterService {\n11 +    private static final Logger logger = LoggerFactory.getLogger(CounterService.class);\n12 +\n13 +    private int globalCounter = 0;\n14 +    private final Map<String, Integer> namedCounters = new HashMap<>();\n15 +    private final Map<String, Long> timestamps = new ConcurrentHashMap<>();\n16 +\n17 +    private static CounterService instance;\n18 +\n19 +    private CounterService() {}\n20 +\n21 +    public static CounterService getInstance() {\n22 +        if (instance == null) {\n23 +            instance = new CounterService();\n24 +        }\n25 +        return instance;\n26 +    }\n27 +\n28 +    public int incrementGlobal() {\n29 +        globalCounter++;\n30 +        return globalCounter;\n31 +    }\n32 +\n33 +    public int getGlobalCount() {\n34 +        return globalCounter;\n35 +    }\n36 +\n37 +    public void increment(String name) {\n38 +        Integer current = namedCounters.get(name);\n39 +        if (current == null) {\n40 +            current = 0;\n41 +        }\n42 +        namedCounters.put(name, current + 1);\n43 +        timestamps.put(name, System.currentTimeMillis());\n44 +    }\n45 +\n46 +    public int getCount(String name) {\n47 +        Integer count = namedCounters.get(name);\n48 +        return count != null ? count : 0;\n49 +    }\n50 +\n51 +    public void reset(String name) {\n52 +        namedCounters.remove(name);\n53 +        timestamps.remove(name);\n54 +    }\n55 +\n56 +    public void resetAll() {\n57 +        namedCounters.clear();\n58 +        timestamps.clear();\n59 +        globalCounter = 0;\n60 +    }\n61 +\n62 +    public Map<String, Integer> getAllCounts() {\n63 +        return new HashMap<>(namedCounters);\n64 +    }\n65 +\n66 +    public boolean checkAndIncrement(String name, int threshold) {\n67 +        int current = getCount(name);\n68 +        if (current < threshold) {\n69 +            increment(name);\n70 +            return true;\n71 +        }\n72 +        return false;\n73 +    }\n74 +\n75 +    public void transferCount(String from, String to) {\n76 +        int fromCount = getCount(from);\n77 +        int toCount = getCount(to);\n78 +\n79 +        namedCounters.put(to, toCount + fromCount);\n80 +        namedCounters.remove(from);\n81 +    }\n82 +}\n83 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/service/CounterService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "public static CounterService getInstance() {\n        if (instance == null) {\n            instance = new CounterService();\n        }\n        return instance;\n    }", "improvedCode": "public static synchronized CounterService getInstance() {\n        if (instance == null) {\n            instance = new CounterService();\n        }\n        return instance;\n    }", "relevantFile": "src/main/java/com/app/service/CounterService.java", "relevantLinesEnd": 26, "suggestionContent": "The `getInstance` method has a race condition (broken double-checked locking). Two threads can both see `instance == null`, both create instances, and one instance is lost. Either use synchronized, volatile with proper double-checked locking, or an enum singleton.", "oneSentenceSummary": "Race condition in singleton - multiple instances can be created", "relevantLinesStart": 21}, {"label": "bug", "language": "Java", "existingCode": "public int incrementGlobal() {\n        globalCounter++;\n        return globalCounter;\n    }", "improvedCode": "private final AtomicInteger globalCounter = new AtomicInteger(0);\n\npublic int incrementGlobal() {\n        return globalCounter.incrementAndGet();\n    }", "relevantFile": "src/main/java/com/app/service/CounterService.java", "relevantLinesEnd": 31, "suggestionContent": "The `incrementGlobal` method performs non-atomic `globalCounter++`. With multiple threads, increments can be lost due to read-modify-write race condition. Use `AtomicInteger` or synchronization.", "oneSentenceSummary": "Race condition in counter increment - increments can be lost", "relevantLinesStart": 28}, {"label": "bug", "language": "Java", "existingCode": "private final Map<String, Integer> namedCounters = new HashMap<>();", "improvedCode": "private final ConcurrentHashMap<String, Integer> namedCounters = new ConcurrentHashMap<>();\n\npublic void increment(String name) {\n    namedCounters.merge(name, 1, Integer::sum);\n    timestamps.put(name, System.currentTimeMillis());\n}", "relevantFile": "src/main/java/com/app/service/CounterService.java", "relevantLinesEnd": 14, "suggestionContent": "The `namedCounters` HashMap is not thread-safe, but methods like `increment` and `checkAndIncrement` can be called from multiple threads. The read-then-write pattern in `increment` is also not atomic. Use `ConcurrentHashMap` with `compute` or `merge`.", "oneSentenceSummary": "HashMap not thread-safe - concurrent access causes data corruption", "relevantLinesStart": 14}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/model/CacheKey.java", "language": "Java", "fileContent": "package com.app.model;\n\nimport java.util.Objects;\n\npublic class CacheKey {\n    private String namespace;\n    private String key;\n    private long version;\n    private boolean caseSensitive;\n\n    public CacheKey(String namespace, String key) {\n        this.namespace = namespace;\n        this.key = key;\n        this.version = 1;\n        this.caseSensitive = true;\n    }\n\n    public CacheKey(String namespace, String key, long version) {\n        this.namespace = namespace;\n        this.key = key;\n        this.version = version;\n        this.caseSensitive = true;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public long getVersion() {\n        return version;\n    }\n\n    public void setVersion(long version) {\n        this.version = version;\n    }\n\n    public boolean isCaseSensitive() {\n        return caseSensitive;\n    }\n\n    public void setCaseSensitive(boolean caseSensitive) {\n        this.caseSensitive = caseSensitive;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        CacheKey cacheKey = (CacheKey) o;\n        return Objects.equals(namespace, cacheKey.namespace) &&\n               Objects.equals(key, cacheKey.key);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(namespace, key, version);\n    }\n\n    public String toKeyString() {\n        return namespace + \":\" + key + \":\" + version;\n    }\n\n    public static CacheKey parse(String keyString) {\n        String[] parts = keyString.split(\":\");\n        if (parts.length >= 2) {\n            CacheKey cacheKey = new CacheKey(parts[0], parts[1]);\n            if (parts.length >= 3) {\n                cacheKey.setVersion(Long.parseLong(parts[2]));\n            }\n            return cacheKey;\n        }\n        throw new IllegalArgumentException(\"Invalid key string: \" + keyString);\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/model/CacheKey.java'\n\n@@ -0,0 +1,87 @@\n__new hunk__\n1 +package com.app.model;\n2 +\n3 +import java.util.Objects;\n4 +\n5 +public class CacheKey {\n6 +    private String namespace;\n7 +    private String key;\n8 +    private long version;\n9 +    private boolean caseSensitive;\n10 +\n11 +    public CacheKey(String namespace, String key) {\n12 +        this.namespace = namespace;\n13 +        this.key = key;\n14 +        this.version = 1;\n15 +        this.caseSensitive = true;\n16 +    }\n17 +\n18 +    public CacheKey(String namespace, String key, long version) {\n19 +        this.namespace = namespace;\n20 +        this.key = key;\n21 +        this.version = version;\n22 +        this.caseSensitive = true;\n23 +    }\n24 +\n25 +    public String getNamespace() {\n26 +        return namespace;\n27 +    }\n28 +\n29 +    public void setNamespace(String namespace) {\n30 +        this.namespace = namespace;\n31 +    }\n32 +\n33 +    public String getKey() {\n34 +        return key;\n35 +    }\n36 +\n37 +    public void setKey(String key) {\n38 +        this.key = key;\n39 +    }\n40 +\n41 +    public long getVersion() {\n42 +        return version;\n43 +    }\n44 +\n45 +    public void setVersion(long version) {\n46 +        this.version = version;\n47 +    }\n48 +\n49 +    public boolean isCaseSensitive() {\n50 +        return caseSensitive;\n51 +    }\n52 +\n53 +    public void setCaseSensitive(boolean caseSensitive) {\n54 +        this.caseSensitive = caseSensitive;\n55 +    }\n56 +\n57 +    @Override\n58 +    public boolean equals(Object o) {\n59 +        if (this == o) return true;\n60 +        if (o == null || getClass() != o.getClass()) return false;\n61 +        CacheKey cacheKey = (CacheKey) o;\n62 +        return Objects.equals(namespace, cacheKey.namespace) &&\n63 +               Objects.equals(key, cacheKey.key);\n64 +    }\n65 +\n66 +    @Override\n67 +    public int hashCode() {\n68 +        return Objects.hash(namespace, key, version);\n69 +    }\n70 +\n71 +    public String toKeyString() {\n72 +        return namespace + \":\" + key + \":\" + version;\n73 +    }\n74 +\n75 +    public static CacheKey parse(String keyString) {\n76 +        String[] parts = keyString.split(\":\");\n77 +        if (parts.length >= 2) {\n78 +            CacheKey cacheKey = new CacheKey(parts[0], parts[1]);\n79 +            if (parts.length >= 3) {\n80 +                cacheKey.setVersion(Long.parseLong(parts[2]));\n81 +            }\n82 +            return cacheKey;\n83 +        }\n84 +        throw new IllegalArgumentException(\"Invalid key string: \" + keyString);\n85 +    }\n86 +}\n87 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in src/main/java/com/app/model/CacheKey.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        CacheKey cacheKey = (CacheKey) o;\n        return Objects.equals(namespace, cacheKey.namespace) &&\n               Objects.equals(key, cacheKey.key);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(namespace, key, version);\n    }", "improvedCode": "@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        CacheKey cacheKey = (CacheKey) o;\n        return Objects.equals(namespace, cacheKey.namespace) &&\n               Objects.equals(key, cacheKey.key);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(namespace, key);  // Must match fields used in equals\n    }", "relevantFile": "src/main/java/com/app/model/CacheKey.java", "relevantLinesEnd": 68, "suggestionContent": "The `equals` and `hashCode` methods violate their contract. `equals` compares only `namespace` and `key`, but `hashCode` includes `version`. Two CacheKey objects can be equal (same namespace/key) but have different hash codes (different version). This breaks HashMap/HashSet: objects may not be found even when they exist in the collection.", "oneSentenceSummary": "equals/hashCode contract violation - equal objects have different hash codes", "relevantLinesStart": 57}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/repository/ProductRepository.java", "language": "Java", "fileContent": "package com.app.repository;\n\nimport com.app.model.Product;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class ProductRepository {\n    private static final Logger logger = LoggerFactory.getLogger(ProductRepository.class);\n\n    private final Connection connection;\n\n    public ProductRepository(Connection connection) {\n        this.connection = connection;\n    }\n\n    public Optional<Product> findById(Long id) throws SQLException {\n        String sql = \"SELECT * FROM products WHERE id = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n            stmt.setLong(1, id);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                return Optional.of(mapResultSetToProduct(rs));\n            }\n        }\n        return Optional.empty();\n    }\n\n    public List<Product> findByName(String name) throws SQLException {\n        String sql = \"SELECT * FROM products WHERE name LIKE '%\" + name + \"%'\";\n        List<Product> products = new ArrayList<>();\n\n        try (Statement stmt = connection.createStatement()) {\n            ResultSet rs = stmt.executeQuery(sql);\n            while (rs.next()) {\n                products.add(mapResultSetToProduct(rs));\n            }\n        }\n\n        return products;\n    }\n\n    public List<Product> findByCategory(String category) throws SQLException {\n        String sql = \"SELECT * FROM products WHERE category = '\" + category + \"'\";\n        List<Product> products = new ArrayList<>();\n\n        try (Statement stmt = connection.createStatement()) {\n            ResultSet rs = stmt.executeQuery(sql);\n            while (rs.next()) {\n                products.add(mapResultSetToProduct(rs));\n            }\n        }\n\n        return products;\n    }\n\n    public List<Product> searchProducts(String searchTerm, String sortBy) throws SQLException {\n        String sql = \"SELECT * FROM products WHERE name LIKE '%\" + searchTerm + \"%' ORDER BY \" + sortBy;\n        List<Product> products = new ArrayList<>();\n\n        try (Statement stmt = connection.createStatement()) {\n            ResultSet rs = stmt.executeQuery(sql);\n            while (rs.next()) {\n                products.add(mapResultSetToProduct(rs));\n            }\n        }\n\n        return products;\n    }\n\n    public void updatePrice(Long productId, double newPrice) throws SQLException {\n        String sql = \"UPDATE products SET price = ? WHERE id = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n            stmt.setDouble(1, newPrice);\n            stmt.setLong(2, productId);\n            stmt.executeUpdate();\n        }\n    }\n\n    public void deleteByCategory(String category) throws SQLException {\n        String sql = \"DELETE FROM products WHERE category = '\" + category + \"'\";\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(sql);\n        }\n    }\n\n    private Product mapResultSetToProduct(ResultSet rs) throws SQLException {\n        return new Product(\n            rs.getLong(\"id\"),\n            rs.getString(\"name\"),\n            rs.getString(\"category\"),\n            rs.getDouble(\"price\"),\n            rs.getInt(\"quantity\")\n        );\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/repository/ProductRepository.java'\n\n@@ -0,0 +1,101 @@\n__new hunk__\n1 +package com.app.repository;\n2 +\n3 +import com.app.model.Product;\n4 +import org.slf4j.Logger;\n5 +import org.slf4j.LoggerFactory;\n6 +\n7 +import java.sql.*;\n8 +import java.util.ArrayList;\n9 +import java.util.List;\n10 +import java.util.Optional;\n11 +\n12 +public class ProductRepository {\n13 +    private static final Logger logger = LoggerFactory.getLogger(ProductRepository.class);\n14 +\n15 +    private final Connection connection;\n16 +\n17 +    public ProductRepository(Connection connection) {\n18 +        this.connection = connection;\n19 +    }\n20 +\n21 +    public Optional<Product> findById(Long id) throws SQLException {\n22 +        String sql = \"SELECT * FROM products WHERE id = ?\";\n23 +        try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n24 +            stmt.setLong(1, id);\n25 +            ResultSet rs = stmt.executeQuery();\n26 +            if (rs.next()) {\n27 +                return Optional.of(mapResultSetToProduct(rs));\n28 +            }\n29 +        }\n30 +        return Optional.empty();\n31 +    }\n32 +\n33 +    public List<Product> findByName(String name) throws SQLException {\n34 +        String sql = \"SELECT * FROM products WHERE name LIKE '%\" + name + \"%'\";\n35 +        List<Product> products = new ArrayList<>();\n36 +\n37 +        try (Statement stmt = connection.createStatement()) {\n38 +            ResultSet rs = stmt.executeQuery(sql);\n39 +            while (rs.next()) {\n40 +                products.add(mapResultSetToProduct(rs));\n41 +            }\n42 +        }\n43 +\n44 +        return products;\n45 +    }\n46 +\n47 +    public List<Product> findByCategory(String category) throws SQLException {\n48 +        String sql = \"SELECT * FROM products WHERE category = '\" + category + \"'\";\n49 +        List<Product> products = new ArrayList<>();\n50 +\n51 +        try (Statement stmt = connection.createStatement()) {\n52 +            ResultSet rs = stmt.executeQuery(sql);\n53 +            while (rs.next()) {\n54 +                products.add(mapResultSetToProduct(rs));\n55 +            }\n56 +        }\n57 +\n58 +        return products;\n59 +    }\n60 +\n61 +    public List<Product> searchProducts(String searchTerm, String sortBy) throws SQLException {\n62 +        String sql = \"SELECT * FROM products WHERE name LIKE '%\" + searchTerm + \"%' ORDER BY \" + sortBy;\n63 +        List<Product> products = new ArrayList<>();\n64 +\n65 +        try (Statement stmt = connection.createStatement()) {\n66 +            ResultSet rs = stmt.executeQuery(sql);\n67 +            while (rs.next()) {\n68 +                products.add(mapResultSetToProduct(rs));\n69 +            }\n70 +        }\n71 +\n72 +        return products;\n73 +    }\n74 +\n75 +    public void updatePrice(Long productId, double newPrice) throws SQLException {\n76 +        String sql = \"UPDATE products SET price = ? WHERE id = ?\";\n77 +        try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n78 +            stmt.setDouble(1, newPrice);\n79 +            stmt.setLong(2, productId);\n80 +            stmt.executeUpdate();\n81 +        }\n82 +    }\n83 +\n84 +    public void deleteByCategory(String category) throws SQLException {\n85 +        String sql = \"DELETE FROM products WHERE category = '\" + category + \"'\";\n86 +        try (Statement stmt = connection.createStatement()) {\n87 +            stmt.executeUpdate(sql);\n88 +        }\n89 +    }\n90 +\n91 +    private Product mapResultSetToProduct(ResultSet rs) throws SQLException {\n92 +        return new Product(\n93 +            rs.getLong(\"id\"),\n94 +            rs.getString(\"name\"),\n95 +            rs.getString(\"category\"),\n96 +            rs.getDouble(\"price\"),\n97 +            rs.getInt(\"quantity\")\n98 +        );\n99 +    }\n100 +}\n101 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/repository/ProductRepository.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "String sql = \"SELECT * FROM products WHERE name LIKE '%\" + name + \"%'\";", "improvedCode": "String sql = \"SELECT * FROM products WHERE name LIKE ?\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\n    stmt.setString(1, \"%\" + name + \"%\");", "relevantFile": "src/main/java/com/app/repository/ProductRepository.java", "relevantLinesEnd": 33, "suggestionContent": "The `findByName` method concatenates user input directly into SQL query, enabling SQL injection. An attacker can input `%' OR '1'='1' --` to retrieve all products or `%'; DROP TABLE products; --` to delete the table. Use PreparedStatement with parameters.", "oneSentenceSummary": "SQL injection in findByName - user input concatenated into query", "relevantLinesStart": 33}, {"label": "bug", "language": "Java", "existingCode": "String sql = \"SELECT * FROM products WHERE name LIKE '%\" + searchTerm + \"%' ORDER BY \" + sortBy;", "improvedCode": "Set<String> allowedSortColumns = Set.of(\"name\", \"price\", \"category\");\nif (!allowedSortColumns.contains(sortBy)) {\n    throw new IllegalArgumentException(\"Invalid sort column\");\n}\nString sql = \"SELECT * FROM products WHERE name LIKE ? ORDER BY \" + sortBy;", "relevantFile": "src/main/java/com/app/repository/ProductRepository.java", "relevantLinesEnd": 60, "suggestionContent": "The `searchProducts` method has two SQL injection vulnerabilities: the `searchTerm` and `sortBy` parameters are both concatenated into the query. The `sortBy` injection is particularly dangerous as ORDER BY cannot be parameterized - it needs allowlist validation.", "oneSentenceSummary": "SQL injection in searchProducts - both searchTerm and sortBy are injectable", "relevantLinesStart": 60}, {"label": "bug", "language": "Java", "existingCode": "String sql = \"DELETE FROM products WHERE category = '\" + category + \"'\";", "improvedCode": "String sql = \"DELETE FROM products WHERE category = ?\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\n    stmt.setString(1, category);", "relevantFile": "src/main/java/com/app/repository/ProductRepository.java", "relevantLinesEnd": 82, "suggestionContent": "The `deleteByCategory` method concatenates the category parameter directly into a DELETE statement. An attacker can inject `'; DELETE FROM users; --` to delete data from other tables.", "oneSentenceSummary": "SQL injection in DELETE statement allows deleting arbitrary data", "relevantLinesStart": 82}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/util/StringUtils.java", "language": "Java", "fileContent": "package com.app.util;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\n\npublic class StringUtils {\n\n    private static final Pattern EMAIL_PATTERN = Pattern.compile(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n\n    public static String joinWithSeparator(List<String> items, String separator) {\n        String result = \"\";\n        for (int i = 0; i < items.size(); i++) {\n            result += items.get(i);\n            if (i < items.size() - 1) {\n                result += separator;\n            }\n        }\n        return result;\n    }\n\n    public static String repeat(String str, int times) {\n        String result = \"\";\n        for (int i = 0; i < times; i++) {\n            result = result + str;\n        }\n        return result;\n    }\n\n    public static String buildQuery(Map<String, String> params) {\n        String query = \"\";\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            if (!query.isEmpty()) {\n                query += \"&\";\n            }\n            query += entry.getKey() + \"=\" + entry.getValue();\n        }\n        return query;\n    }\n\n    public static boolean isValidEmail(String email) {\n        return email != null && EMAIL_PATTERN.matcher(email).matches();\n    }\n\n    public static String capitalize(String str) {\n        if (str == null || str.isEmpty()) {\n            return str;\n        }\n        return Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();\n    }\n\n    public static String truncate(String str, int maxLength) {\n        if (str == null || str.length() <= maxLength) {\n            return str;\n        }\n        return str.substring(0, maxLength) + \"...\";\n    }\n\n    public static List<String> splitByLength(String str, int chunkSize) {\n        List<String> chunks = new ArrayList<>();\n        for (int i = 0; i < str.length(); i += chunkSize) {\n            chunks.add(str.substring(i, Math.min(i + chunkSize, str.length())));\n        }\n        return chunks;\n    }\n\n    public static String reverse(String str) {\n        String result = \"\";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            result += str.charAt(i);\n        }\n        return result;\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/util/StringUtils.java'\n\n@@ -0,0 +1,74 @@\n__new hunk__\n1 +package com.app.util;\n2 +\n3 +import java.util.*;\n4 +import java.util.regex.Pattern;\n5 +\n6 +public class StringUtils {\n7 +\n8 +    private static final Pattern EMAIL_PATTERN = Pattern.compile(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n9 +\n10 +    public static String joinWithSeparator(List<String> items, String separator) {\n11 +        String result = \"\";\n12 +        for (int i = 0; i < items.size(); i++) {\n13 +            result += items.get(i);\n14 +            if (i < items.size() - 1) {\n15 +                result += separator;\n16 +            }\n17 +        }\n18 +        return result;\n19 +    }\n20 +\n21 +    public static String repeat(String str, int times) {\n22 +        String result = \"\";\n23 +        for (int i = 0; i < times; i++) {\n24 +            result = result + str;\n25 +        }\n26 +        return result;\n27 +    }\n28 +\n29 +    public static String buildQuery(Map<String, String> params) {\n30 +        String query = \"\";\n31 +        for (Map.Entry<String, String> entry : params.entrySet()) {\n32 +            if (!query.isEmpty()) {\n33 +                query += \"&\";\n34 +            }\n35 +            query += entry.getKey() + \"=\" + entry.getValue();\n36 +        }\n37 +        return query;\n38 +    }\n39 +\n40 +    public static boolean isValidEmail(String email) {\n41 +        return email != null && EMAIL_PATTERN.matcher(email).matches();\n42 +    }\n43 +\n44 +    public static String capitalize(String str) {\n45 +        if (str == null || str.isEmpty()) {\n46 +            return str;\n47 +        }\n48 +        return Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();\n49 +    }\n50 +\n51 +    public static String truncate(String str, int maxLength) {\n52 +        if (str == null || str.length() <= maxLength) {\n53 +            return str;\n54 +        }\n55 +        return str.substring(0, maxLength) + \"...\";\n56 +    }\n57 +\n58 +    public static List<String> splitByLength(String str, int chunkSize) {\n59 +        List<String> chunks = new ArrayList<>();\n60 +        for (int i = 0; i < str.length(); i += chunkSize) {\n61 +            chunks.add(str.substring(i, Math.min(i + chunkSize, str.length())));\n62 +        }\n63 +        return chunks;\n64 +    }\n65 +\n66 +    public static String reverse(String str) {\n67 +        String result = \"\";\n68 +        for (int i = str.length() - 1; i >= 0; i--) {\n69 +            result += str.charAt(i);\n70 +        }\n71 +        return result;\n72 +    }\n73 +}\n74 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in src/main/java/com/app/util/StringUtils.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "public static String joinWithSeparator(List<String> items, String separator) {\n        String result = \"\";\n        for (int i = 0; i < items.size(); i++) {\n            result += items.get(i);", "improvedCode": "public static String joinWithSeparator(List<String> items, String separator) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < items.size(); i++) {\n            result.append(items.get(i));", "relevantFile": "src/main/java/com/app/util/StringUtils.java", "relevantLinesEnd": 17, "suggestionContent": "Multiple methods use String concatenation with `+=` in loops (`joinWithSeparator`, `repeat`, `buildQuery`, `reverse`). In Java, strings are immutable, so each `+=` creates a new String object and copies all previous characters. For n iterations, this is O(n) time complexity and creates n garbage objects. Use StringBuilder instead.", "oneSentenceSummary": "String concatenation in loop is O(n) - creates n String objects per iteration", "relevantLinesStart": 11}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/OrderService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport com.app.model.Order;\nimport com.app.model.OrderItem;\nimport com.app.model.Customer;\nimport com.app.repository.OrderRepository;\nimport com.app.repository.CustomerRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class OrderService {\n    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);\n\n    private final OrderRepository orderRepository;\n    private final CustomerRepository customerRepository;\n\n    public OrderService(OrderRepository orderRepository, CustomerRepository customerRepository) {\n        this.orderRepository = orderRepository;\n        this.customerRepository = customerRepository;\n    }\n\n    public Order createOrder(String customerId, List<OrderItem> items) {\n        Customer customer = customerRepository.findById(customerId).orElse(null);\n\n        Order order = new Order();\n        order.setCustomerId(customerId);\n        order.setCustomerEmail(customer.getEmail());\n        order.setItems(items);\n        order.setStatus(\"PENDING\");\n        order.setCreatedAt(LocalDateTime.now());\n        order.setTotal(calculateTotal(items));\n\n        return orderRepository.save(order);\n    }\n\n    public BigDecimal calculateTotal(List<OrderItem> items) {\n        BigDecimal total = BigDecimal.ZERO;\n        for (OrderItem item : items) {\n            BigDecimal itemTotal = item.getPrice().multiply(new BigDecimal(item.getQuantity()));\n            total = total.add(itemTotal);\n        }\n        return total;\n    }\n\n    public void processOrder(String orderId) {\n        Order order = orderRepository.findById(orderId).orElse(null);\n\n        logger.info(\"Processing order {} for customer {}\", order.getId(), order.getCustomerId());\n\n        if (order.getStatus().equals(\"PENDING\")) {\n            order.setStatus(\"PROCESSING\");\n            orderRepository.save(order);\n        }\n    }\n\n    public String getOrderSummary(String orderId) {\n        Order order = orderRepository.findById(orderId).orElse(null);\n        Customer customer = customerRepository.findById(order.getCustomerId()).orElse(null);\n\n        StringBuilder summary = new StringBuilder();\n        summary.append(\"Order: \").append(order.getId()).append(\"\\n\");\n        summary.append(\"Customer: \").append(customer.getName()).append(\"\\n\");\n        summary.append(\"Email: \").append(customer.getEmail()).append(\"\\n\");\n        summary.append(\"Total: \").append(order.getTotal()).append(\"\\n\");\n\n        return summary.toString();\n    }\n\n    public void applyDiscount(String orderId, String couponCode) {\n        Order order = orderRepository.findById(orderId).orElse(null);\n\n        if (order != null && couponCode != null) {\n            BigDecimal discount = calculateDiscount(couponCode, order.getTotal());\n            order.setDiscount(discount);\n            order.setTotal(order.getTotal().subtract(discount));\n            orderRepository.save(order);\n        }\n    }\n\n    private BigDecimal calculateDiscount(String couponCode, BigDecimal total) {\n        if (couponCode.startsWith(\"PERCENT\")) {\n            int percent = Integer.parseInt(couponCode.substring(7));\n            return total.multiply(new BigDecimal(percent)).divide(new BigDecimal(100));\n        }\n        return BigDecimal.ZERO;\n    }\n\n    public boolean cancelOrder(String orderId) {\n        Optional<Order> orderOpt = orderRepository.findById(orderId);\n        if (orderOpt.isPresent()) {\n            Order order = orderOpt.get();\n            if (!\"SHIPPED\".equals(order.getStatus())) {\n                order.setStatus(\"CANCELLED\");\n                orderRepository.save(order);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/OrderService.java'\n\n@@ -0,0 +1,106 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import com.app.model.Order;\n4 +import com.app.model.OrderItem;\n5 +import com.app.model.Customer;\n6 +import com.app.repository.OrderRepository;\n7 +import com.app.repository.CustomerRepository;\n8 +import org.slf4j.Logger;\n9 +import org.slf4j.LoggerFactory;\n10 +\n11 +import java.math.BigDecimal;\n12 +import java.time.LocalDateTime;\n13 +import java.util.List;\n14 +import java.util.Optional;\n15 +\n16 +public class OrderService {\n17 +    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);\n18 +\n19 +    private final OrderRepository orderRepository;\n20 +    private final CustomerRepository customerRepository;\n21 +\n22 +    public OrderService(OrderRepository orderRepository, CustomerRepository customerRepository) {\n23 +        this.orderRepository = orderRepository;\n24 +        this.customerRepository = customerRepository;\n25 +    }\n26 +\n27 +    public Order createOrder(String customerId, List<OrderItem> items) {\n28 +        Customer customer = customerRepository.findById(customerId).orElse(null);\n29 +\n30 +        Order order = new Order();\n31 +        order.setCustomerId(customerId);\n32 +        order.setCustomerEmail(customer.getEmail());\n33 +        order.setItems(items);\n34 +        order.setStatus(\"PENDING\");\n35 +        order.setCreatedAt(LocalDateTime.now());\n36 +        order.setTotal(calculateTotal(items));\n37 +\n38 +        return orderRepository.save(order);\n39 +    }\n40 +\n41 +    public BigDecimal calculateTotal(List<OrderItem> items) {\n42 +        BigDecimal total = BigDecimal.ZERO;\n43 +        for (OrderItem item : items) {\n44 +            BigDecimal itemTotal = item.getPrice().multiply(new BigDecimal(item.getQuantity()));\n45 +            total = total.add(itemTotal);\n46 +        }\n47 +        return total;\n48 +    }\n49 +\n50 +    public void processOrder(String orderId) {\n51 +        Order order = orderRepository.findById(orderId).orElse(null);\n52 +\n53 +        logger.info(\"Processing order {} for customer {}\", order.getId(), order.getCustomerId());\n54 +\n55 +        if (order.getStatus().equals(\"PENDING\")) {\n56 +            order.setStatus(\"PROCESSING\");\n57 +            orderRepository.save(order);\n58 +        }\n59 +    }\n60 +\n61 +    public String getOrderSummary(String orderId) {\n62 +        Order order = orderRepository.findById(orderId).orElse(null);\n63 +        Customer customer = customerRepository.findById(order.getCustomerId()).orElse(null);\n64 +\n65 +        StringBuilder summary = new StringBuilder();\n66 +        summary.append(\"Order: \").append(order.getId()).append(\"\\n\");\n67 +        summary.append(\"Customer: \").append(customer.getName()).append(\"\\n\");\n68 +        summary.append(\"Email: \").append(customer.getEmail()).append(\"\\n\");\n69 +        summary.append(\"Total: \").append(order.getTotal()).append(\"\\n\");\n70 +\n71 +        return summary.toString();\n72 +    }\n73 +\n74 +    public void applyDiscount(String orderId, String couponCode) {\n75 +        Order order = orderRepository.findById(orderId).orElse(null);\n76 +\n77 +        if (order != null && couponCode != null) {\n78 +            BigDecimal discount = calculateDiscount(couponCode, order.getTotal());\n79 +            order.setDiscount(discount);\n80 +            order.setTotal(order.getTotal().subtract(discount));\n81 +            orderRepository.save(order);\n82 +        }\n83 +    }\n84 +\n85 +    private BigDecimal calculateDiscount(String couponCode, BigDecimal total) {\n86 +        if (couponCode.startsWith(\"PERCENT\")) {\n87 +            int percent = Integer.parseInt(couponCode.substring(7));\n88 +            return total.multiply(new BigDecimal(percent)).divide(new BigDecimal(100));\n89 +        }\n90 +        return BigDecimal.ZERO;\n91 +    }\n92 +\n93 +    public boolean cancelOrder(String orderId) {\n94 +        Optional<Order> orderOpt = orderRepository.findById(orderId);\n95 +        if (orderOpt.isPresent()) {\n96 +            Order order = orderOpt.get();\n97 +            if (!\"SHIPPED\".equals(order.getStatus())) {\n98 +                order.setStatus(\"CANCELLED\");\n99 +                orderRepository.save(order);\n100 +                return true;\n101 +            }\n102 +        }\n103 +        return false;\n104 +    }\n105 +}\n106 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in src/main/java/com/app/service/OrderService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "Customer customer = customerRepository.findById(customerId).orElse(null);\n        \n        Order order = new Order();\n        order.setCustomerId(customerId);\n        order.setCustomerEmail(customer.getEmail());", "improvedCode": "Customer customer = customerRepository.findById(customerId)\n            .orElseThrow(() -> new IllegalArgumentException(\"Customer not found: \" + customerId));\n        \n        Order order = new Order();\n        order.setCustomerId(customerId);\n        order.setCustomerEmail(customer.getEmail());", "relevantFile": "src/main/java/com/app/service/OrderService.java", "relevantLinesEnd": 32, "suggestionContent": "In `createOrder`, `customerRepository.findById()` returns null via `orElse(null)`, then `customer.getEmail()` is called without null check. If customer doesn't exist, this throws NullPointerException.", "oneSentenceSummary": "NullPointerException when customer not found - null.getEmail() called", "relevantLinesStart": 28}, {"label": "bug", "language": "Java", "existingCode": "Order order = orderRepository.findById(orderId).orElse(null);\n        \n        logger.info(\"Processing order {} for customer {}\", order.getId(), order.getCustomerId());", "improvedCode": "Order order = orderRepository.findById(orderId)\n            .orElseThrow(() -> new IllegalArgumentException(\"Order not found: \" + orderId));\n        \n        logger.info(\"Processing order {} for customer {}\", order.getId(), order.getCustomerId());", "relevantFile": "src/main/java/com/app/service/OrderService.java", "relevantLinesEnd": 52, "suggestionContent": "In `processOrder`, the order is retrieved with `orElse(null)` and immediately used without null check. If order doesn't exist, `order.getId()` throws NullPointerException.", "oneSentenceSummary": "NullPointerException in processOrder when order not found", "relevantLinesStart": 50}, {"label": "bug", "language": "Java", "existingCode": "Order order = orderRepository.findById(orderId).orElse(null);\n        Customer customer = customerRepository.findById(order.getCustomerId()).orElse(null);", "improvedCode": "Order order = orderRepository.findById(orderId)\n            .orElseThrow(() -> new IllegalArgumentException(\"Order not found\"));\n        Customer customer = customerRepository.findById(order.getCustomerId())\n            .orElseThrow(() -> new IllegalArgumentException(\"Customer not found\"));", "relevantFile": "src/main/java/com/app/service/OrderService.java", "relevantLinesEnd": 61, "suggestionContent": "In `getOrderSummary`, both order and customer can be null, but both are dereferenced without checks. The method chains `order.getCustomerId()` even when order might be null.", "oneSentenceSummary": "Multiple NullPointerException risks - order and customer accessed without null checks", "relevantLinesStart": 60}]}}, "metadata" : {}}
{"inputs" : {"inputs": {"filePath": "src/main/java/com/app/service/CacheService.java", "language": "Java", "fileContent": "package com.app.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class CacheService {\n    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);\n\n    private final Map<String, byte[]> cache = new ConcurrentHashMap<>();\n    private final String cacheDirectory;\n\n    public CacheService(String cacheDirectory) {\n        this.cacheDirectory = cacheDirectory;\n    }\n\n    public void put(String key, Object value) {\n        try {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(value);\n            oos.close();\n\n            cache.put(key, bos.toByteArray());\n        } catch (IOException e) {\n            logger.error(\"Failed to serialize object for key {}\", key, e);\n        }\n    }\n\n    public Object get(String key) {\n        byte[] data = cache.get(key);\n        if (data == null) {\n            return null;\n        }\n\n        try {\n            ByteArrayInputStream bis = new ByteArrayInputStream(data);\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            return ois.readObject();\n        } catch (Exception e) {\n            logger.error(\"Failed to deserialize object for key {}\", key, e);\n            return null;\n        }\n    }\n\n    public void saveToFile(String key) {\n        byte[] data = cache.get(key);\n        if (data == null) {\n            return;\n        }\n\n        try {\n            String filePath = cacheDirectory + \"/\" + key + \".cache\";\n            FileOutputStream fos = new FileOutputStream(filePath);\n            fos.write(data);\n            fos.close();\n        } catch (IOException e) {\n            logger.error(\"Failed to save cache to file\", e);\n        }\n    }\n\n    public Object loadFromFile(String key) {\n        String filePath = cacheDirectory + \"/\" + key + \".cache\";\n\n        try {\n            FileInputStream fis = new FileInputStream(filePath);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            Object obj = ois.readObject();\n            ois.close();\n\n            return obj;\n        } catch (Exception e) {\n            logger.error(\"Failed to load cache from file\", e);\n            return null;\n        }\n    }\n\n    public void importCache(byte[] serializedData) {\n        try {\n            ByteArrayInputStream bis = new ByteArrayInputStream(serializedData);\n            ObjectInputStream ois = new ObjectInputStream(bis);\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, byte[]> importedCache = (Map<String, byte[]>) ois.readObject();\n\n            cache.putAll(importedCache);\n            logger.info(\"Imported {} cache entries\", importedCache.size());\n        } catch (Exception e) {\n            logger.error(\"Failed to import cache\", e);\n        }\n    }\n\n    public byte[] exportCache() {\n        try {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(new HashMap<>(cache));\n            oos.close();\n\n            return bos.toByteArray();\n        } catch (IOException e) {\n            logger.error(\"Failed to export cache\", e);\n            return null;\n        }\n    }\n\n    public void clear() {\n        cache.clear();\n    }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'src/main/java/com/app/service/CacheService.java'\n\n@@ -0,0 +1,114 @@\n__new hunk__\n1 +package com.app.service;\n2 +\n3 +import org.slf4j.Logger;\n4 +import org.slf4j.LoggerFactory;\n5 +\n6 +import java.io.*;\n7 +import java.util.*;\n8 +import java.util.concurrent.ConcurrentHashMap;\n9 +\n10 +public class CacheService {\n11 +    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);\n12 +\n13 +    private final Map<String, byte[]> cache = new ConcurrentHashMap<>();\n14 +    private final String cacheDirectory;\n15 +\n16 +    public CacheService(String cacheDirectory) {\n17 +        this.cacheDirectory = cacheDirectory;\n18 +    }\n19 +\n20 +    public void put(String key, Object value) {\n21 +        try {\n22 +            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n23 +            ObjectOutputStream oos = new ObjectOutputStream(bos);\n24 +            oos.writeObject(value);\n25 +            oos.close();\n26 +\n27 +            cache.put(key, bos.toByteArray());\n28 +        } catch (IOException e) {\n29 +            logger.error(\"Failed to serialize object for key {}\", key, e);\n30 +        }\n31 +    }\n32 +\n33 +    public Object get(String key) {\n34 +        byte[] data = cache.get(key);\n35 +        if (data == null) {\n36 +            return null;\n37 +        }\n38 +\n39 +        try {\n40 +            ByteArrayInputStream bis = new ByteArrayInputStream(data);\n41 +            ObjectInputStream ois = new ObjectInputStream(bis);\n42 +            return ois.readObject();\n43 +        } catch (Exception e) {\n44 +            logger.error(\"Failed to deserialize object for key {}\", key, e);\n45 +            return null;\n46 +        }\n47 +    }\n48 +\n49 +    public void saveToFile(String key) {\n50 +        byte[] data = cache.get(key);\n51 +        if (data == null) {\n52 +            return;\n53 +        }\n54 +\n55 +        try {\n56 +            String filePath = cacheDirectory + \"/\" + key + \".cache\";\n57 +            FileOutputStream fos = new FileOutputStream(filePath);\n58 +            fos.write(data);\n59 +            fos.close();\n60 +        } catch (IOException e) {\n61 +            logger.error(\"Failed to save cache to file\", e);\n62 +        }\n63 +    }\n64 +\n65 +    public Object loadFromFile(String key) {\n66 +        String filePath = cacheDirectory + \"/\" + key + \".cache\";\n67 +\n68 +        try {\n69 +            FileInputStream fis = new FileInputStream(filePath);\n70 +            ObjectInputStream ois = new ObjectInputStream(fis);\n71 +            Object obj = ois.readObject();\n72 +            ois.close();\n73 +\n74 +            return obj;\n75 +        } catch (Exception e) {\n76 +            logger.error(\"Failed to load cache from file\", e);\n77 +            return null;\n78 +        }\n79 +    }\n80 +\n81 +    public void importCache(byte[] serializedData) {\n82 +        try {\n83 +            ByteArrayInputStream bis = new ByteArrayInputStream(serializedData);\n84 +            ObjectInputStream ois = new ObjectInputStream(bis);\n85 +\n86 +            @SuppressWarnings(\"unchecked\")\n87 +            Map<String, byte[]> importedCache = (Map<String, byte[]>) ois.readObject();\n88 +\n89 +            cache.putAll(importedCache);\n90 +            logger.info(\"Imported {} cache entries\", importedCache.size());\n91 +        } catch (Exception e) {\n92 +            logger.error(\"Failed to import cache\", e);\n93 +        }\n94 +    }\n95 +\n96 +    public byte[] exportCache() {\n97 +        try {\n98 +            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n99 +            ObjectOutputStream oos = new ObjectOutputStream(bos);\n100 +            oos.writeObject(new HashMap<>(cache));\n101 +            oos.close();\n102 +\n103 +            return bos.toByteArray();\n104 +        } catch (IOException e) {\n105 +            logger.error(\"Failed to export cache\", e);\n106 +            return null;\n107 +        }\n108 +    }\n109 +\n110 +    public void clear() {\n111 +        cache.clear();\n112 +    }\n113 +}\n114 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in src/main/java/com/app/service/CacheService.java", "codeSuggestions": [{"label": "bug", "language": "Java", "existingCode": "ObjectInputStream ois = new ObjectInputStream(fis);\n            Object obj = ois.readObject();", "improvedCode": "// Use JSON serialization instead of Java serialization\n// ObjectMapper mapper = new ObjectMapper();\n// Object obj = mapper.readValue(fis, expectedClass);", "relevantFile": "src/main/java/com/app/service/CacheService.java", "relevantLinesEnd": 68, "suggestionContent": "The `loadFromFile` and `importCache` methods use `ObjectInputStream` to deserialize data from files and external input. Java deserialization is inherently unsafe - malicious serialized data can execute arbitrary code during deserialization. An attacker can craft payloads using gadget chains (like Apache Commons Collections). Use JSON or other safe formats instead.", "oneSentenceSummary": "Insecure deserialization - ObjectInputStream can execute arbitrary code", "relevantLinesStart": 67}, {"label": "bug", "language": "Java", "existingCode": "public void importCache(byte[] serializedData) {\n        try {\n            ByteArrayInputStream bis = new ByteArrayInputStream(serializedData);\n            ObjectInputStream ois = new ObjectInputStream(bis);", "improvedCode": "// Never deserialize untrusted data with ObjectInputStream\n// Use a whitelist-based ObjectInputFilter or switch to JSON\npublic void importCache(String jsonData) {\n    ObjectMapper mapper = new ObjectMapper();\n    TypeReference<Map<String, byte[]>> typeRef = new TypeReference<>() {};\n    Map<String, byte[]> importedCache = mapper.readValue(jsonData, typeRef);", "relevantFile": "src/main/java/com/app/service/CacheService.java", "relevantLinesEnd": 81, "suggestionContent": "The `importCache` method deserializes external data passed as a byte array parameter. This is especially dangerous as the data likely comes from an untrusted source (network, user upload). Remote code execution is possible.", "oneSentenceSummary": "Deserializing untrusted byte array enables remote code execution", "relevantLinesStart": 78}]}}, "metadata" : {}}
