{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/auth/src/jwt/JwtService.ts", "language": "TypeScript", "fileContent": "import * as crypto from 'crypto';\n\nexport interface JwtPayload {\n  sub: string;\n  iat: number;\n  exp: number;\n  iss?: string;\n  aud?: string;\n  [key: string]: unknown;\n}\n\nexport interface JwtHeader {\n  alg: string;\n  typ: string;\n}\n\nexport interface JwtConfig {\n  secret: string;\n  issuer: string;\n  audience: string;\n  expiresIn: number;\n}\n\nfunction base64UrlEncode(data: string | Buffer): string {\n  const base64 = Buffer.from(data).toString('base64');\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n\nfunction base64UrlDecode(data: string): string {\n  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n  const padding = base64.length % 4;\n  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n  return Buffer.from(padded, 'base64').toString();\n}\n\nexport class JwtService {\n  private config: JwtConfig;\n\n  constructor(config: JwtConfig) {\n    this.config = config;\n  }\n\n  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n    const now = Math.floor(Date.now() / 1000);\n\n    const header: JwtHeader = {\n      alg: 'HS256',\n      typ: 'JWT',\n    };\n\n    const fullPayload: JwtPayload = {\n      ...payload,\n      iat: now,\n      exp: now + this.config.expiresIn,\n      iss: this.config.issuer,\n      aud: this.config.audience,\n    };\n\n    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n\n    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n\n    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n  }\n\n  verify(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    const [headerEncoded, payloadEncoded, signature] = parts;\n\n    try {\n      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n\n      // Verify algorithm\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\n        return null;\n      }\n\n      // Verify signature\n      if (header.alg !== 'none') {\n        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n        if (signature !== expectedSignature) {\n          return null;\n        }\n      }\n\n      // Check expiration\n      const now = Math.floor(Date.now() / 1000);\n      if (payload.exp && payload.exp < now) {\n        return null;\n      }\n\n      // Verify issuer and audience\n      if (payload.iss !== this.config.issuer) {\n        return null;\n      }\n\n      if (payload.aud !== this.config.audience) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  private createSignature(data: string): string {\n    const hmac = crypto.createHmac('sha256', this.config.secret);\n    hmac.update(data);\n    return base64UrlEncode(hmac.digest());\n  }\n\n  decode(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  refresh(token: string): string | null {\n    const payload = this.verify(token);\n    if (!payload) {\n      return null;\n    }\n\n    const { iat, exp, ...rest } = payload;\n    return this.sign(rest);\n  }\n\n  isExpired(token: string): boolean {\n    const payload = this.decode(token);\n    if (!payload || !payload.exp) {\n      return true;\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n    return payload.exp < now;\n  }\n}\n\nexport function createJwtService(config: JwtConfig): JwtService {\n  return new JwtService(config);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/auth/src/jwt/JwtService.ts'\n\n@@ -0,0 +1,156 @@\n__new hunk__\n1 +import * as crypto from 'crypto';\n2 +\n3 +export interface JwtPayload {\n4 +  sub: string;\n5 +  iat: number;\n6 +  exp: number;\n7 +  iss?: string;\n8 +  aud?: string;\n9 +  [key: string]: unknown;\n10 +}\n11 +\n12 +export interface JwtHeader {\n13 +  alg: string;\n14 +  typ: string;\n15 +}\n16 +\n17 +export interface JwtConfig {\n18 +  secret: string;\n19 +  issuer: string;\n20 +  audience: string;\n21 +  expiresIn: number;\n22 +}\n23 +\n24 +function base64UrlEncode(data: string | Buffer): string {\n25 +  const base64 = Buffer.from(data).toString('base64');\n26 +  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n27 +}\n28 +\n29 +function base64UrlDecode(data: string): string {\n30 +  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n31 +  const padding = base64.length % 4;\n32 +  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n33 +  return Buffer.from(padded, 'base64').toString();\n34 +}\n35 +\n36 +export class JwtService {\n37 +  private config: JwtConfig;\n38 +\n39 +  constructor(config: JwtConfig) {\n40 +    this.config = config;\n41 +  }\n42 +\n43 +  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n44 +    const now = Math.floor(Date.now() / 1000);\n45 +\n46 +    const header: JwtHeader = {\n47 +      alg: 'HS256',\n48 +      typ: 'JWT',\n49 +    };\n50 +\n51 +    const fullPayload: JwtPayload = {\n52 +      ...payload,\n53 +      iat: now,\n54 +      exp: now + this.config.expiresIn,\n55 +      iss: this.config.issuer,\n56 +      aud: this.config.audience,\n57 +    };\n58 +\n59 +    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n60 +    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n61 +\n62 +    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n63 +\n64 +    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n65 +  }\n66 +\n67 +  verify(token: string): JwtPayload | null {\n68 +    const parts = token.split('.');\n69 +    if (parts.length !== 3) {\n70 +      return null;\n71 +    }\n72 +\n73 +    const [headerEncoded, payloadEncoded, signature] = parts;\n74 +\n75 +    try {\n76 +      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n77 +      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n78 +\n79 +      // Verify algorithm\n80 +      if (header.alg !== 'HS256' && header.alg !== 'none') {\n81 +        return null;\n82 +      }\n83 +\n84 +      // Verify signature\n85 +      if (header.alg !== 'none') {\n86 +        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n87 +        if (signature !== expectedSignature) {\n88 +          return null;\n89 +        }\n90 +      }\n91 +\n92 +      // Check expiration\n93 +      const now = Math.floor(Date.now() / 1000);\n94 +      if (payload.exp && payload.exp < now) {\n95 +        return null;\n96 +      }\n97 +\n98 +      // Verify issuer and audience\n99 +      if (payload.iss !== this.config.issuer) {\n100 +        return null;\n101 +      }\n102 +\n103 +      if (payload.aud !== this.config.audience) {\n104 +        return null;\n105 +      }\n106 +\n107 +      return payload;\n108 +    } catch {\n109 +      return null;\n110 +    }\n111 +  }\n112 +\n113 +  private createSignature(data: string): string {\n114 +    const hmac = crypto.createHmac('sha256', this.config.secret);\n115 +    hmac.update(data);\n116 +    return base64UrlEncode(hmac.digest());\n117 +  }\n118 +\n119 +  decode(token: string): JwtPayload | null {\n120 +    const parts = token.split('.');\n121 +    if (parts.length !== 3) {\n122 +      return null;\n123 +    }\n124 +\n125 +    try {\n126 +      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n127 +    } catch {\n128 +      return null;\n129 +    }\n130 +  }\n131 +\n132 +  refresh(token: string): string | null {\n133 +    const payload = this.verify(token);\n134 +    if (!payload) {\n135 +      return null;\n136 +    }\n137 +\n138 +    const { iat, exp, ...rest } = payload;\n139 +    return this.sign(rest);\n140 +  }\n141 +\n142 +  isExpired(token: string): boolean {\n143 +    const payload = this.decode(token);\n144 +    if (!payload || !payload.exp) {\n145 +      return true;\n146 +    }\n147 +\n148 +    const now = Math.floor(Date.now() / 1000);\n149 +    return payload.exp < now;\n150 +  }\n151 +}\n152 +\n153 +export function createJwtService(config: JwtConfig): JwtService {\n154 +  return new JwtService(config);\n155 +}\n156 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in packages/auth/src/jwt/JwtService.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "// Verify algorithm\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\n        return null;\n      }\n\n      // Verify signature\n      if (header.alg !== 'none') {", "improvedCode": "// Verify algorithm - NEVER accept 'none'\n      if (header.alg !== 'HS256') {\n        return null;\n      }\n\n      // Verify signature", "relevantFile": "packages/auth/src/jwt/JwtService.ts", "relevantLinesEnd": 81, "suggestionContent": "The `verify` method accepts tokens with `alg: 'none'`, which means an attacker can forge tokens by setting the algorithm to 'none' and providing an empty signature. This is the classic JWT algorithm confusion attack. Never accept 'none' as a valid algorithm.", "oneSentenceSummary": "JWT algorithm confusion - accepting 'none' allows forged tokens", "relevantLinesStart": 75}, {"label": "bug", "language": "TypeScript", "existingCode": "if (signature !== expectedSignature) {\n          return null;\n        }", "improvedCode": "if (!crypto.timingSafeEqual(\n          Buffer.from(signature),\n          Buffer.from(expectedSignature)\n        )) {\n          return null;\n        }", "relevantFile": "packages/auth/src/jwt/JwtService.ts", "relevantLinesEnd": 85, "suggestionContent": "The signature comparison `signature !== expectedSignature` uses JavaScript's standard string comparison, which is not constant-time. This allows timing attacks where an attacker can determine how many characters of the signature match by measuring response times. Use a constant-time comparison function.", "oneSentenceSummary": "Timing attack vulnerability - signature comparison is not constant-time", "relevantLinesStart": 83}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/core/src/cache/RequestCache.ts", "language": "TypeScript", "fileContent": "import { Logger } from '../utils/logger';\n\ninterface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  ttl: number;\n}\n\ninterface CacheOptions {\n  defaultTtl: number;\n  maxSize: number;\n  onEvict?: (key: string, value: unknown) => void;\n}\n\nexport class RequestCache<T = unknown> {\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\n  private readonly logger: Logger;\n  private readonly options: CacheOptions;\n  private hits = 0;\n  private misses = 0;\n\n  constructor(options: Partial<CacheOptions> = {}) {\n    this.cache = new WeakMap();\n    this.logger = new Logger('RequestCache');\n    this.options = {\n      defaultTtl: 60000,\n      maxSize: 1000,\n      ...options,\n    };\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key as unknown as object);\n    if (!entry) {\n      this.misses++;\n      return undefined;\n    }\n\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key as unknown as object);\n      this.misses++;\n      return undefined;\n    }\n\n    this.hits++;\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      ttl: ttl ?? this.options.defaultTtl,\n    };\n    this.cache.set(key as unknown as object, entry);\n    this.logger.debug(`Cached key: ${key}`);\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key as unknown as object);\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      hitRate: total > 0 ? this.hits / total : 0,\n    };\n  }\n\n  clear(): void {\n    this.cache = new WeakMap();\n    this.hits = 0;\n    this.misses = 0;\n  }\n}\n\nexport function createRequestCache<T>(options?: Partial<CacheOptions>) {\n  return new RequestCache<T>(options);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/core/src/cache/RequestCache.ts'\n\n@@ -0,0 +1,82 @@\n__new hunk__\n1 +import { Logger } from '../utils/logger';\n2 +\n3 +interface CacheEntry<T> {\n4 +  value: T;\n5 +  timestamp: number;\n6 +  ttl: number;\n7 +}\n8 +\n9 +interface CacheOptions {\n10 +  defaultTtl: number;\n11 +  maxSize: number;\n12 +  onEvict?: (key: string, value: unknown) => void;\n13 +}\n14 +\n15 +export class RequestCache<T = unknown> {\n16 +  private readonly cache: WeakMap<object, CacheEntry<T>>;\n17 +  private readonly logger: Logger;\n18 +  private readonly options: CacheOptions;\n19 +  private hits = 0;\n20 +  private misses = 0;\n21 +\n22 +  constructor(options: Partial<CacheOptions> = {}) {\n23 +    this.cache = new WeakMap();\n24 +    this.logger = new Logger('RequestCache');\n25 +    this.options = {\n26 +      defaultTtl: 60000,\n27 +      maxSize: 1000,\n28 +      ...options,\n29 +    };\n30 +  }\n31 +\n32 +  get(key: string): T | undefined {\n33 +    const entry = this.cache.get(key as unknown as object);\n34 +    if (!entry) {\n35 +      this.misses++;\n36 +      return undefined;\n37 +    }\n38 +\n39 +    if (Date.now() - entry.timestamp > entry.ttl) {\n40 +      this.cache.delete(key as unknown as object);\n41 +      this.misses++;\n42 +      return undefined;\n43 +    }\n44 +\n45 +    this.hits++;\n46 +    return entry.value;\n47 +  }\n48 +\n49 +  set(key: string, value: T, ttl?: number): void {\n50 +    const entry: CacheEntry<T> = {\n51 +      value,\n52 +      timestamp: Date.now(),\n53 +      ttl: ttl ?? this.options.defaultTtl,\n54 +    };\n55 +    this.cache.set(key as unknown as object, entry);\n56 +    this.logger.debug(`Cached key: ${key}`);\n57 +  }\n58 +\n59 +  delete(key: string): boolean {\n60 +    return this.cache.delete(key as unknown as object);\n61 +  }\n62 +\n63 +  getStats() {\n64 +    const total = this.hits + this.misses;\n65 +    return {\n66 +      hits: this.hits,\n67 +      misses: this.misses,\n68 +      hitRate: total > 0 ? this.hits / total : 0,\n69 +    };\n70 +  }\n71 +\n72 +  clear(): void {\n73 +    this.cache = new WeakMap();\n74 +    this.hits = 0;\n75 +    this.misses = 0;\n76 +  }\n77 +}\n78 +\n79 +export function createRequestCache<T>(options?: Partial<CacheOptions>) {\n80 +  return new RequestCache<T>(options);\n81 +}\n82 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/core/src/cache/RequestCache.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "private readonly cache: WeakMap<object, CacheEntry<T>>;", "improvedCode": "private readonly cache: Map<string, CacheEntry<T>>;", "relevantFile": "packages/core/src/cache/RequestCache.ts", "relevantLinesEnd": 17, "suggestionContent": "WeakMap only accepts objects as keys, not primitive values like strings. The code casts strings to objects with `as unknown as object`, but this doesn't actually convert the string to an object - it just bypasses TypeScript's type checking. At runtime, WeakMap.set() will throw a TypeError when called with a string key. Use a regular Map instead of WeakMap for string keys, or if you need weak references, use the string as a property of a wrapper object.", "oneSentenceSummary": "WeakMap cannot use primitive string keys - will throw TypeError at runtime", "relevantLinesStart": 17}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/text/src/utils/TextTruncator.ts", "language": "TypeScript", "fileContent": "export interface TruncateOptions {\n  maxLength: number;\n  ellipsis?: string;\n  wordBoundary?: boolean;\n  preserveWords?: boolean;\n}\n\nconst DEFAULT_ELLIPSIS = '...';\n\nexport function getCharacterCount(text: string): number {\n  return text.length;\n}\n\nexport function truncateText(\n  text: string,\n  options: TruncateOptions\n): string {\n  const {\n    maxLength,\n    ellipsis = DEFAULT_ELLIPSIS,\n    wordBoundary = false,\n  } = options;\n\n  if (text.length <= maxLength) {\n    return text;\n  }\n\n  const truncateAt = maxLength - ellipsis.length;\n\n  if (truncateAt <= 0) {\n    return ellipsis.slice(0, maxLength);\n  }\n\n  let truncated = text.slice(0, truncateAt);\n\n  if (wordBoundary) {\n    const lastSpace = truncated.lastIndexOf(' ');\n    if (lastSpace > truncateAt * 0.5) {\n      truncated = truncated.slice(0, lastSpace);\n    }\n  }\n\n  return truncated + ellipsis;\n}\n\nexport function truncateMiddle(\n  text: string,\n  maxLength: number,\n  separator: string = '...'\n): string {\n  if (text.length <= maxLength) {\n    return text;\n  }\n\n  const separatorLength = separator.length;\n  const charsToShow = maxLength - separatorLength;\n\n  if (charsToShow <= 0) {\n    return separator.slice(0, maxLength);\n  }\n\n  const frontChars = Math.ceil(charsToShow / 2);\n  const backChars = Math.floor(charsToShow / 2);\n\n  return text.slice(0, frontChars) + separator + text.slice(-backChars);\n}\n\nexport function countWords(text: string): number {\n  return text.trim().split(/\\s+/).filter(Boolean).length;\n}\n\nexport function truncateWords(\n  text: string,\n  maxWords: number,\n  ellipsis: string = DEFAULT_ELLIPSIS\n): string {\n  const words = text.trim().split(/\\s+/);\n\n  if (words.length <= maxWords) {\n    return text;\n  }\n\n  return words.slice(0, maxWords).join(' ') + ellipsis;\n}\n\nexport class TextTruncator {\n  private defaultOptions: TruncateOptions;\n\n  constructor(defaultOptions: Partial<TruncateOptions> = {}) {\n    this.defaultOptions = {\n      maxLength: 100,\n      ellipsis: DEFAULT_ELLIPSIS,\n      wordBoundary: true,\n      ...defaultOptions,\n    };\n  }\n\n  truncate(text: string, options?: Partial<TruncateOptions>): string {\n    return truncateText(text, { ...this.defaultOptions, ...options });\n  }\n\n  truncateForDisplay(text: string, maxLength: number): string {\n    return truncateText(text, {\n      ...this.defaultOptions,\n      maxLength,\n      wordBoundary: true,\n    });\n  }\n\n  getLength(text: string): number {\n    return getCharacterCount(text);\n  }\n\n  isWithinLimit(text: string, limit: number): boolean {\n    return this.getLength(text) <= limit;\n  }\n}\n\nexport default TextTruncator;\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/text/src/utils/TextTruncator.ts'\n\n@@ -0,0 +1,120 @@\n__new hunk__\n1 +export interface TruncateOptions {\n2 +  maxLength: number;\n3 +  ellipsis?: string;\n4 +  wordBoundary?: boolean;\n5 +  preserveWords?: boolean;\n6 +}\n7 +\n8 +const DEFAULT_ELLIPSIS = '...';\n9 +\n10 +export function getCharacterCount(text: string): number {\n11 +  return text.length;\n12 +}\n13 +\n14 +export function truncateText(\n15 +  text: string,\n16 +  options: TruncateOptions\n17 +): string {\n18 +  const {\n19 +    maxLength,\n20 +    ellipsis = DEFAULT_ELLIPSIS,\n21 +    wordBoundary = false,\n22 +  } = options;\n23 +\n24 +  if (text.length <= maxLength) {\n25 +    return text;\n26 +  }\n27 +\n28 +  const truncateAt = maxLength - ellipsis.length;\n29 +\n30 +  if (truncateAt <= 0) {\n31 +    return ellipsis.slice(0, maxLength);\n32 +  }\n33 +\n34 +  let truncated = text.slice(0, truncateAt);\n35 +\n36 +  if (wordBoundary) {\n37 +    const lastSpace = truncated.lastIndexOf(' ');\n38 +    if (lastSpace > truncateAt * 0.5) {\n39 +      truncated = truncated.slice(0, lastSpace);\n40 +    }\n41 +  }\n42 +\n43 +  return truncated + ellipsis;\n44 +}\n45 +\n46 +export function truncateMiddle(\n47 +  text: string,\n48 +  maxLength: number,\n49 +  separator: string = '...'\n50 +): string {\n51 +  if (text.length <= maxLength) {\n52 +    return text;\n53 +  }\n54 +\n55 +  const separatorLength = separator.length;\n56 +  const charsToShow = maxLength - separatorLength;\n57 +\n58 +  if (charsToShow <= 0) {\n59 +    return separator.slice(0, maxLength);\n60 +  }\n61 +\n62 +  const frontChars = Math.ceil(charsToShow / 2);\n63 +  const backChars = Math.floor(charsToShow / 2);\n64 +\n65 +  return text.slice(0, frontChars) + separator + text.slice(-backChars);\n66 +}\n67 +\n68 +export function countWords(text: string): number {\n69 +  return text.trim().split(/\\s+/).filter(Boolean).length;\n70 +}\n71 +\n72 +export function truncateWords(\n73 +  text: string,\n74 +  maxWords: number,\n75 +  ellipsis: string = DEFAULT_ELLIPSIS\n76 +): string {\n77 +  const words = text.trim().split(/\\s+/);\n78 +\n79 +  if (words.length <= maxWords) {\n80 +    return text;\n81 +  }\n82 +\n83 +  return words.slice(0, maxWords).join(' ') + ellipsis;\n84 +}\n85 +\n86 +export class TextTruncator {\n87 +  private defaultOptions: TruncateOptions;\n88 +\n89 +  constructor(defaultOptions: Partial<TruncateOptions> = {}) {\n90 +    this.defaultOptions = {\n91 +      maxLength: 100,\n92 +      ellipsis: DEFAULT_ELLIPSIS,\n93 +      wordBoundary: true,\n94 +      ...defaultOptions,\n95 +    };\n96 +  }\n97 +\n98 +  truncate(text: string, options?: Partial<TruncateOptions>): string {\n99 +    return truncateText(text, { ...this.defaultOptions, ...options });\n100 +  }\n101 +\n102 +  truncateForDisplay(text: string, maxLength: number): string {\n103 +    return truncateText(text, {\n104 +      ...this.defaultOptions,\n105 +      maxLength,\n106 +      wordBoundary: true,\n107 +    });\n108 +  }\n109 +\n110 +  getLength(text: string): number {\n111 +    return getCharacterCount(text);\n112 +  }\n113 +\n114 +  isWithinLimit(text: string, limit: number): boolean {\n115 +    return this.getLength(text) <= limit;\n116 +  }\n117 +}\n118 +\n119 +export default TextTruncator;\n120 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/text/src/utils/TextTruncator.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "export function getCharacterCount(text: string): number {\n  return text.length;\n}", "improvedCode": "export function getCharacterCount(text: string): number {\n  return [...text].length;\n}", "relevantFile": "packages/text/src/utils/TextTruncator.ts", "relevantLinesEnd": 12, "suggestionContent": "The `getCharacterCount` function and all length checks use `string.length`, which counts UTF-16 code units, not actual characters (graphemes). This causes incorrect behavior with emojis, accented characters, and other Unicode text. For example, 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦' has `.length` of 11 but is visually 1 character; 'ðŸ‡ºðŸ‡¸' has `.length` of 4 but is 1 flag emoji. Text could be truncated in the middle of a multi-code-unit character, producing invalid Unicode or broken emoji. Use `Intl.Segmenter` or spread syntax `[...text].length` for accurate character counting.", "oneSentenceSummary": "String.length counts UTF-16 code units not characters - breaks with emoji/Unicode", "relevantLinesStart": 10}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/realtime/src/client/WebSocketManager.ts", "language": "TypeScript", "fileContent": "export type MessageHandler = (data: unknown) => void;\nexport type ConnectionHandler = () => void;\nexport type ErrorHandler = (error: Event) => void;\n\nexport interface WebSocketConfig {\n  url: string;\n  protocols?: string[];\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n  messageQueueSize: number;\n}\n\nexport interface QueuedMessage {\n  data: string;\n  timestamp: number;\n  priority: number;\n}\n\nconst DEFAULT_CONFIG: Partial<WebSocketConfig> = {\n  reconnectInterval: 1000,\n  maxReconnectAttempts: 10,\n  heartbeatInterval: 30000,\n  messageQueueSize: 100,\n};\n\nexport class WebSocketManager {\n  private socket: WebSocket | null = null;\n  private config: WebSocketConfig;\n  private messageHandlers: Map<string, Set<MessageHandler>> = new Map();\n  private connectionHandlers: Set<ConnectionHandler> = new Set();\n  private errorHandlers: Set<ErrorHandler> = new Set();\n  private messageQueue: QueuedMessage[] = [];\n  private reconnectAttempts = 0;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private isConnecting = false;\n  private isIntentionallyClosed = false;\n\n  constructor(config: Partial<WebSocketConfig> & { url: string }) {\n    this.config = { ...DEFAULT_CONFIG, ...config } as WebSocketConfig;\n  }\n\n  connect(): void {\n    if (this.socket?.readyState === WebSocket.OPEN || this.isConnecting) {\n      return;\n    }\n\n    this.isConnecting = true;\n    this.isIntentionallyClosed = false;\n\n    try {\n      this.socket = new WebSocket(this.config.url, this.config.protocols);\n      this.setupEventHandlers();\n    } catch (error) {\n      this.isConnecting = false;\n      this.handleReconnect();\n    }\n  }\n\n  private setupEventHandlers(): void {\n    if (!this.socket) return;\n\n    this.socket.onopen = () => {\n      this.isConnecting = false;\n      this.reconnectAttempts = 0;\n      this.startHeartbeat();\n      this.flushMessageQueue();\n      this.connectionHandlers.forEach(handler => handler());\n    };\n\n    this.socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        const type = message.type || 'default';\n        const handlers = this.messageHandlers.get(type);\n\n        if (handlers) {\n          handlers.forEach(handler => handler(message.payload));\n        }\n      } catch (error) {\n        console.error('Failed to parse WebSocket message:', error);\n      }\n    };\n\n    this.socket.onclose = (event) => {\n      this.stopHeartbeat();\n      this.isConnecting = false;\n\n      if (!this.isIntentionallyClosed && !event.wasClean) {\n        this.handleReconnect();\n      }\n    };\n\n    this.socket.onerror = (error) => {\n      this.errorHandlers.forEach(handler => handler(error));\n    };\n  }\n\n  private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n\n    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\n    this.reconnectAttempts++;\n\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify({ type: 'ping' }));\n      }\n    }, this.config.heartbeatInterval);\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n  }\n\n  private flushMessageQueue(): void {\n    while (this.messageQueue.length > 0 && this.socket?.readyState === WebSocket.OPEN) {\n      const message = this.messageQueue.shift();\n      if (message) {\n        this.socket.send(message.data);\n      }\n    }\n  }\n\n  send(type: string, payload: unknown, priority = 0): boolean {\n    const message = JSON.stringify({ type, payload });\n\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.socket.send(message);\n      return true;\n    }\n\n    if (this.messageQueue.length < this.config.messageQueueSize) {\n      this.messageQueue.push({\n        data: message,\n        timestamp: Date.now(),\n        priority,\n      });\n      this.messageQueue.sort((a, b) => b.priority - a.priority);\n      return true;\n    }\n\n    return false;\n  }\n\n  on(type: string, handler: MessageHandler): () => void {\n    if (!this.messageHandlers.has(type)) {\n      this.messageHandlers.set(type, new Set());\n    }\n    this.messageHandlers.get(type)!.add(handler);\n\n    return () => {\n      this.messageHandlers.get(type)?.delete(handler);\n    };\n  }\n\n  onConnect(handler: ConnectionHandler): () => void {\n    this.connectionHandlers.add(handler);\n    return () => this.connectionHandlers.delete(handler);\n  }\n\n  onError(handler: ErrorHandler): () => void {\n    this.errorHandlers.add(handler);\n    return () => this.errorHandlers.delete(handler);\n  }\n\n  disconnect(): void {\n    this.isIntentionallyClosed = true;\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n\n    this.stopHeartbeat();\n\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  getReadyState(): number {\n    return this.socket?.readyState ?? WebSocket.CLOSED;\n  }\n\n  isConnected(): boolean {\n    return this.socket?.readyState === WebSocket.OPEN;\n  }\n}\n\nexport function createWebSocketManager(\n  config: Partial<WebSocketConfig> & { url: string }\n): WebSocketManager {\n  return new WebSocketManager(config);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/realtime/src/client/WebSocketManager.ts'\n\n@@ -0,0 +1,208 @@\n__new hunk__\n1 +export type MessageHandler = (data: unknown) => void;\n2 +export type ConnectionHandler = () => void;\n3 +export type ErrorHandler = (error: Event) => void;\n4 +\n5 +export interface WebSocketConfig {\n6 +  url: string;\n7 +  protocols?: string[];\n8 +  reconnectInterval: number;\n9 +  maxReconnectAttempts: number;\n10 +  heartbeatInterval: number;\n11 +  messageQueueSize: number;\n12 +}\n13 +\n14 +export interface QueuedMessage {\n15 +  data: string;\n16 +  timestamp: number;\n17 +  priority: number;\n18 +}\n19 +\n20 +const DEFAULT_CONFIG: Partial<WebSocketConfig> = {\n21 +  reconnectInterval: 1000,\n22 +  maxReconnectAttempts: 10,\n23 +  heartbeatInterval: 30000,\n24 +  messageQueueSize: 100,\n25 +};\n26 +\n27 +export class WebSocketManager {\n28 +  private socket: WebSocket | null = null;\n29 +  private config: WebSocketConfig;\n30 +  private messageHandlers: Map<string, Set<MessageHandler>> = new Map();\n31 +  private connectionHandlers: Set<ConnectionHandler> = new Set();\n32 +  private errorHandlers: Set<ErrorHandler> = new Set();\n33 +  private messageQueue: QueuedMessage[] = [];\n34 +  private reconnectAttempts = 0;\n35 +  private reconnectTimeout: NodeJS.Timeout | null = null;\n36 +  private heartbeatInterval: NodeJS.Timeout | null = null;\n37 +  private isConnecting = false;\n38 +  private isIntentionallyClosed = false;\n39 +\n40 +  constructor(config: Partial<WebSocketConfig> & { url: string }) {\n41 +    this.config = { ...DEFAULT_CONFIG, ...config } as WebSocketConfig;\n42 +  }\n43 +\n44 +  connect(): void {\n45 +    if (this.socket?.readyState === WebSocket.OPEN || this.isConnecting) {\n46 +      return;\n47 +    }\n48 +\n49 +    this.isConnecting = true;\n50 +    this.isIntentionallyClosed = false;\n51 +\n52 +    try {\n53 +      this.socket = new WebSocket(this.config.url, this.config.protocols);\n54 +      this.setupEventHandlers();\n55 +    } catch (error) {\n56 +      this.isConnecting = false;\n57 +      this.handleReconnect();\n58 +    }\n59 +  }\n60 +\n61 +  private setupEventHandlers(): void {\n62 +    if (!this.socket) return;\n63 +\n64 +    this.socket.onopen = () => {\n65 +      this.isConnecting = false;\n66 +      this.reconnectAttempts = 0;\n67 +      this.startHeartbeat();\n68 +      this.flushMessageQueue();\n69 +      this.connectionHandlers.forEach(handler => handler());\n70 +    };\n71 +\n72 +    this.socket.onmessage = (event) => {\n73 +      try {\n74 +        const message = JSON.parse(event.data);\n75 +        const type = message.type || 'default';\n76 +        const handlers = this.messageHandlers.get(type);\n77 +\n78 +        if (handlers) {\n79 +          handlers.forEach(handler => handler(message.payload));\n80 +        }\n81 +      } catch (error) {\n82 +        console.error('Failed to parse WebSocket message:', error);\n83 +      }\n84 +    };\n85 +\n86 +    this.socket.onclose = (event) => {\n87 +      this.stopHeartbeat();\n88 +      this.isConnecting = false;\n89 +\n90 +      if (!this.isIntentionallyClosed && !event.wasClean) {\n91 +        this.handleReconnect();\n92 +      }\n93 +    };\n94 +\n95 +    this.socket.onerror = (error) => {\n96 +      this.errorHandlers.forEach(handler => handler(error));\n97 +    };\n98 +  }\n99 +\n100 +  private handleReconnect(): void {\n101 +    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n102 +      console.error('Max reconnection attempts reached');\n103 +      return;\n104 +    }\n105 +\n106 +    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\n107 +    this.reconnectAttempts++;\n108 +\n109 +    this.reconnectTimeout = setTimeout(() => {\n110 +      this.connect();\n111 +    }, delay);\n112 +  }\n113 +\n114 +  private startHeartbeat(): void {\n115 +    this.heartbeatInterval = setInterval(() => {\n116 +      if (this.socket?.readyState === WebSocket.OPEN) {\n117 +        this.socket.send(JSON.stringify({ type: 'ping' }));\n118 +      }\n119 +    }, this.config.heartbeatInterval);\n120 +  }\n121 +\n122 +  private stopHeartbeat(): void {\n123 +    if (this.heartbeatInterval) {\n124 +      clearInterval(this.heartbeatInterval);\n125 +    }\n126 +  }\n127 +\n128 +  private flushMessageQueue(): void {\n129 +    while (this.messageQueue.length > 0 && this.socket?.readyState === WebSocket.OPEN) {\n130 +      const message = this.messageQueue.shift();\n131 +      if (message) {\n132 +        this.socket.send(message.data);\n133 +      }\n134 +    }\n135 +  }\n136 +\n137 +  send(type: string, payload: unknown, priority = 0): boolean {\n138 +    const message = JSON.stringify({ type, payload });\n139 +\n140 +    if (this.socket?.readyState === WebSocket.OPEN) {\n141 +      this.socket.send(message);\n142 +      return true;\n143 +    }\n144 +\n145 +    if (this.messageQueue.length < this.config.messageQueueSize) {\n146 +      this.messageQueue.push({\n147 +        data: message,\n148 +        timestamp: Date.now(),\n149 +        priority,\n150 +      });\n151 +      this.messageQueue.sort((a, b) => b.priority - a.priority);\n152 +      return true;\n153 +    }\n154 +\n155 +    return false;\n156 +  }\n157 +\n158 +  on(type: string, handler: MessageHandler): () => void {\n159 +    if (!this.messageHandlers.has(type)) {\n160 +      this.messageHandlers.set(type, new Set());\n161 +    }\n162 +    this.messageHandlers.get(type)!.add(handler);\n163 +\n164 +    return () => {\n165 +      this.messageHandlers.get(type)?.delete(handler);\n166 +    };\n167 +  }\n168 +\n169 +  onConnect(handler: ConnectionHandler): () => void {\n170 +    this.connectionHandlers.add(handler);\n171 +    return () => this.connectionHandlers.delete(handler);\n172 +  }\n173 +\n174 +  onError(handler: ErrorHandler): () => void {\n175 +    this.errorHandlers.add(handler);\n176 +    return () => this.errorHandlers.delete(handler);\n177 +  }\n178 +\n179 +  disconnect(): void {\n180 +    this.isIntentionallyClosed = true;\n181 +\n182 +    if (this.reconnectTimeout) {\n183 +      clearTimeout(this.reconnectTimeout);\n184 +    }\n185 +\n186 +    this.stopHeartbeat();\n187 +\n188 +    if (this.socket) {\n189 +      this.socket.close();\n190 +      this.socket = null;\n191 +    }\n192 +  }\n193 +\n194 +  getReadyState(): number {\n195 +    return this.socket?.readyState ?? WebSocket.CLOSED;\n196 +  }\n197 +\n198 +  isConnected(): boolean {\n199 +    return this.socket?.readyState === WebSocket.OPEN;\n200 +  }\n201 +}\n202 +\n203 +export function createWebSocketManager(\n204 +  config: Partial<WebSocketConfig> & { url: string }\n205 +): WebSocketManager {\n206 +  return new WebSocketManager(config);\n207 +}\n208 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in packages/realtime/src/client/WebSocketManager.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n  }", "improvedCode": "private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }", "relevantFile": "packages/realtime/src/client/WebSocketManager.ts", "relevantLinesEnd": 112, "suggestionContent": "The `stopHeartbeat` method clears the interval but doesn't set `this.heartbeatInterval` to null. When `startHeartbeat` is called again after reconnection, it creates a new interval without clearing the previous one (which may still exist if the reference wasn't properly cleaned). This can cause multiple heartbeat intervals running simultaneously after several reconnects.", "oneSentenceSummary": "Heartbeat interval not nullified after clear - multiple intervals after reconnects", "relevantLinesStart": 108}, {"label": "bug", "language": "TypeScript", "existingCode": "private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n\n    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\n    this.reconnectAttempts++;\n\n    this.reconnectTimeout = setTimeout(() => {", "improvedCode": "private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n\n    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\n    this.reconnectAttempts++;\n\n    this.reconnectTimeout = setTimeout(() => {", "relevantFile": "packages/realtime/src/client/WebSocketManager.ts", "relevantLinesEnd": 100, "suggestionContent": "The `handleReconnect` method doesn't clear an existing `reconnectTimeout` before setting a new one. If `handleReconnect` is called multiple times quickly (e.g., due to rapid close/error events), multiple reconnection timeouts will be scheduled, causing multiple simultaneous connection attempts.", "oneSentenceSummary": "Missing timeout clear before reconnect - multiple concurrent reconnection attempts", "relevantLinesStart": 91}, {"label": "bug", "language": "TypeScript", "existingCode": "if (this.messageQueue.length < this.config.messageQueueSize) {\n      this.messageQueue.push({\n        data: message,\n        timestamp: Date.now(),\n        priority,\n      });\n      this.messageQueue.sort((a, b) => b.priority - a.priority);\n      return true;\n    }", "improvedCode": "if (this.messageQueue.length < this.config.messageQueueSize) {\n      // Remove expired messages (older than 30 seconds)\n      const now = Date.now();\n      this.messageQueue = this.messageQueue.filter(m => now - m.timestamp < 30000);\n      \n      this.messageQueue.push({\n        data: message,\n        timestamp: now,\n        priority,\n      });\n      this.messageQueue.sort((a, b) => b.priority - a.priority);\n      return true;\n    }", "relevantFile": "packages/realtime/src/client/WebSocketManager.ts", "relevantLinesEnd": 138, "suggestionContent": "The message queue's `sort` by priority is called every time a message is added, which is O(n log n). More importantly, when flushing the queue with `shift()`, messages are dequeued in array order, not priority order since shift() removes from the front but sort() put highest priority at the front - wait, that's correct. However, there's still an issue: the queue doesn't expire old messages. Messages queued while offline could be sent much later when they're no longer relevant, causing stale data issues.", "oneSentenceSummary": "Message queue never expires old messages - stale data sent after reconnection", "relevantLinesStart": 131}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/validation/src/validators/InputValidator.ts", "language": "TypeScript", "fileContent": "export interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nexport interface ValidationRule {\n  name: string;\n  validate: (value: string) => boolean;\n  message: string;\n}\n\nconst PATTERNS = {\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/g,\n  phone: /^\\+?[1-9]\\d{1,14}$/g,\n  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/g,\n  username: /^[a-zA-Z][a-zA-Z0-9_]{2,29}$/g,\n  alphanumeric: /^[a-zA-Z0-9]+$/g,\n  numeric: /^\\d+$/g,\n  url: /^https?:\\/\\/[^\\s/$.?#].[^\\s]*$/gi,\n};\n\nexport function validateEmail(email: string): boolean {\n  return PATTERNS.email.test(email);\n}\n\nexport function validatePhone(phone: string): boolean {\n  return PATTERNS.phone.test(phone);\n}\n\nexport function validateSlug(slug: string): boolean {\n  return PATTERNS.slug.test(slug);\n}\n\nexport function validateUsername(username: string): boolean {\n  return PATTERNS.username.test(username);\n}\n\nexport function validateUrl(url: string): boolean {\n  return PATTERNS.url.test(url);\n}\n\nexport function validateField(\n  value: string,\n  rules: ValidationRule[]\n): ValidationResult {\n  const errors: string[] = [];\n\n  for (const rule of rules) {\n    if (!rule.validate(value)) {\n      errors.push(rule.message);\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\nexport function createPatternRule(\n  name: string,\n  pattern: RegExp,\n  message: string\n): ValidationRule {\n  return {\n    name,\n    validate: (value: string) => pattern.test(value),\n    message,\n  };\n}\n\nexport class InputValidator {\n  private rules: Map<string, ValidationRule[]> = new Map();\n\n  addRule(fieldName: string, rule: ValidationRule): this {\n    const existing = this.rules.get(fieldName) ?? [];\n    existing.push(rule);\n    this.rules.set(fieldName, existing);\n    return this;\n  }\n\n  addEmailRule(fieldName: string, message?: string): this {\n    return this.addRule(fieldName, {\n      name: 'email',\n      validate: validateEmail,\n      message: message ?? 'Invalid email address',\n    });\n  }\n\n  addPhoneRule(fieldName: string, message?: string): this {\n    return this.addRule(fieldName, {\n      name: 'phone',\n      validate: validatePhone,\n      message: message ?? 'Invalid phone number',\n    });\n  }\n\n  addSlugRule(fieldName: string, message?: string): this {\n    return this.addRule(fieldName, {\n      name: 'slug',\n      validate: validateSlug,\n      message: message ?? 'Invalid slug format',\n    });\n  }\n\n  validate(fieldName: string, value: string): ValidationResult {\n    const rules = this.rules.get(fieldName);\n    if (!rules) {\n      return { isValid: true, errors: [] };\n    }\n    return validateField(value, rules);\n  }\n\n  validateAll(data: Record<string, string>): Map<string, ValidationResult> {\n    const results = new Map<string, ValidationResult>();\n\n    for (const [fieldName, value] of Object.entries(data)) {\n      results.set(fieldName, this.validate(fieldName, value));\n    }\n\n    return results;\n  }\n}\n\nexport const defaultValidator = new InputValidator();\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/validation/src/validators/InputValidator.ts'\n\n@@ -0,0 +1,126 @@\n__new hunk__\n1 +export interface ValidationResult {\n2 +  isValid: boolean;\n3 +  errors: string[];\n4 +}\n5 +\n6 +export interface ValidationRule {\n7 +  name: string;\n8 +  validate: (value: string) => boolean;\n9 +  message: string;\n10 +}\n11 +\n12 +const PATTERNS = {\n13 +  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/g,\n14 +  phone: /^\\+?[1-9]\\d{1,14}$/g,\n15 +  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/g,\n16 +  username: /^[a-zA-Z][a-zA-Z0-9_]{2,29}$/g,\n17 +  alphanumeric: /^[a-zA-Z0-9]+$/g,\n18 +  numeric: /^\\d+$/g,\n19 +  url: /^https?:\\/\\/[^\\s/$.?#].[^\\s]*$/gi,\n20 +};\n21 +\n22 +export function validateEmail(email: string): boolean {\n23 +  return PATTERNS.email.test(email);\n24 +}\n25 +\n26 +export function validatePhone(phone: string): boolean {\n27 +  return PATTERNS.phone.test(phone);\n28 +}\n29 +\n30 +export function validateSlug(slug: string): boolean {\n31 +  return PATTERNS.slug.test(slug);\n32 +}\n33 +\n34 +export function validateUsername(username: string): boolean {\n35 +  return PATTERNS.username.test(username);\n36 +}\n37 +\n38 +export function validateUrl(url: string): boolean {\n39 +  return PATTERNS.url.test(url);\n40 +}\n41 +\n42 +export function validateField(\n43 +  value: string,\n44 +  rules: ValidationRule[]\n45 +): ValidationResult {\n46 +  const errors: string[] = [];\n47 +\n48 +  for (const rule of rules) {\n49 +    if (!rule.validate(value)) {\n50 +      errors.push(rule.message);\n51 +    }\n52 +  }\n53 +\n54 +  return {\n55 +    isValid: errors.length === 0,\n56 +    errors,\n57 +  };\n58 +}\n59 +\n60 +export function createPatternRule(\n61 +  name: string,\n62 +  pattern: RegExp,\n63 +  message: string\n64 +): ValidationRule {\n65 +  return {\n66 +    name,\n67 +    validate: (value: string) => pattern.test(value),\n68 +    message,\n69 +  };\n70 +}\n71 +\n72 +export class InputValidator {\n73 +  private rules: Map<string, ValidationRule[]> = new Map();\n74 +\n75 +  addRule(fieldName: string, rule: ValidationRule): this {\n76 +    const existing = this.rules.get(fieldName) ?? [];\n77 +    existing.push(rule);\n78 +    this.rules.set(fieldName, existing);\n79 +    return this;\n80 +  }\n81 +\n82 +  addEmailRule(fieldName: string, message?: string): this {\n83 +    return this.addRule(fieldName, {\n84 +      name: 'email',\n85 +      validate: validateEmail,\n86 +      message: message ?? 'Invalid email address',\n87 +    });\n88 +  }\n89 +\n90 +  addPhoneRule(fieldName: string, message?: string): this {\n91 +    return this.addRule(fieldName, {\n92 +      name: 'phone',\n93 +      validate: validatePhone,\n94 +      message: message ?? 'Invalid phone number',\n95 +    });\n96 +  }\n97 +\n98 +  addSlugRule(fieldName: string, message?: string): this {\n99 +    return this.addRule(fieldName, {\n100 +      name: 'slug',\n101 +      validate: validateSlug,\n102 +      message: message ?? 'Invalid slug format',\n103 +    });\n104 +  }\n105 +\n106 +  validate(fieldName: string, value: string): ValidationResult {\n107 +    const rules = this.rules.get(fieldName);\n108 +    if (!rules) {\n109 +      return { isValid: true, errors: [] };\n110 +    }\n111 +    return validateField(value, rules);\n112 +  }\n113 +\n114 +  validateAll(data: Record<string, string>): Map<string, ValidationResult> {\n115 +    const results = new Map<string, ValidationResult>();\n116 +\n117 +    for (const [fieldName, value] of Object.entries(data)) {\n118 +      results.set(fieldName, this.validate(fieldName, value));\n119 +    }\n120 +\n121 +    return results;\n122 +  }\n123 +}\n124 +\n125 +export const defaultValidator = new InputValidator();\n126 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/validation/src/validators/InputValidator.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "const PATTERNS = {\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/g,\n  phone: /^\\+?[1-9]\\d{1,14}$/g,\n  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/g,", "improvedCode": "const PATTERNS = {\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n  phone: /^\\+?[1-9]\\d{1,14}$/,\n  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/,", "relevantFile": "packages/validation/src/validators/InputValidator.ts", "relevantLinesEnd": 20, "suggestionContent": "All regex patterns in PATTERNS object have the global flag (`/g`), which causes them to maintain state via `lastIndex`. When `test()` is called multiple times on the same regex, it alternates between true/false because `lastIndex` advances after each match. For example, `validateEmail('test@test.com')` will return true, then false, then true on consecutive calls. Remove the `g` flag from patterns used with `.test()` or create new RegExp instances for each validation.", "oneSentenceSummary": "RegExp global flag causes validation to alternate true/false on repeated calls", "relevantLinesStart": 13}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/data/src/sorting/ProductSorter.ts", "language": "TypeScript", "fileContent": "export interface Product {\n  id: string;\n  name: string;\n  price: number;\n  category: string;\n  rating: number | null;\n  reviewCount: number;\n  inStock: boolean;\n  createdAt: Date;\n}\n\nexport type SortField = 'name' | 'price' | 'rating' | 'reviewCount' | 'createdAt';\nexport type SortDirection = 'asc' | 'desc';\n\ninterface SortConfig {\n  field: SortField;\n  direction: SortDirection;\n}\n\nfunction compareValues(a: unknown, b: unknown, direction: SortDirection): number {\n  const modifier = direction === 'asc' ? 1 : -1;\n\n  if (a === null || a === undefined) return 1;\n  if (b === null || b === undefined) return -1;\n\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a.localeCompare(b) * modifier;\n  }\n\n  if (typeof a === 'number' && typeof b === 'number') {\n    return (a - b) * modifier;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return (a.getTime() - b.getTime()) * modifier;\n  }\n\n  return 0;\n}\n\nexport function sortProducts(\n  products: Product[],\n  configs: SortConfig[]\n): Product[] {\n  if (configs.length === 0) return products;\n\n  return [...products].sort((a, b) => {\n    for (const config of configs) {\n      const aValue = a[config.field];\n      const bValue = b[config.field];\n      const result = compareValues(aValue, bValue, config.direction);\n      if (result !== 0) return result;\n    }\n    return 0;\n  });\n}\n\nexport function sortByPopularity(products: Product[]): Product[] {\n  return [...products].sort((a, b) => {\n    const aScore = (a.rating ?? 0) * Math.log(a.reviewCount + 1);\n    const bScore = (b.rating ?? 0) * Math.log(b.reviewCount + 1);\n    return bScore - aScore;\n  });\n}\n\nexport function sortByRelevance(\n  products: Product[],\n  searchTerm: string\n): Product[] {\n  const term = searchTerm.toLowerCase();\n\n  return [...products].sort((a, b) => {\n    const aNameMatch = a.name.toLowerCase().includes(term);\n    const bNameMatch = b.name.toLowerCase().includes(term);\n\n    if (aNameMatch && !bNameMatch) return -1;\n    if (!aNameMatch && bNameMatch) return 1;\n\n    const aExact = a.name.toLowerCase() === term;\n    const bExact = b.name.toLowerCase() === term;\n\n    if (aExact && !bExact) return -1;\n    if (!aExact && bExact) return 1;\n\n    return (b.rating ?? 0) - (a.rating ?? 0);\n  });\n}\n\nexport class ProductSorter {\n  private defaultConfigs: SortConfig[] = [];\n\n  setDefaults(configs: SortConfig[]): void {\n    this.defaultConfigs = configs;\n  }\n\n  sort(products: Product[], configs?: SortConfig[]): Product[] {\n    return sortProducts(products, configs ?? this.defaultConfigs);\n  }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/data/src/sorting/ProductSorter.ts'\n\n@@ -0,0 +1,100 @@\n__new hunk__\n1 +export interface Product {\n2 +  id: string;\n3 +  name: string;\n4 +  price: number;\n5 +  category: string;\n6 +  rating: number | null;\n7 +  reviewCount: number;\n8 +  inStock: boolean;\n9 +  createdAt: Date;\n10 +}\n11 +\n12 +export type SortField = 'name' | 'price' | 'rating' | 'reviewCount' | 'createdAt';\n13 +export type SortDirection = 'asc' | 'desc';\n14 +\n15 +interface SortConfig {\n16 +  field: SortField;\n17 +  direction: SortDirection;\n18 +}\n19 +\n20 +function compareValues(a: unknown, b: unknown, direction: SortDirection): number {\n21 +  const modifier = direction === 'asc' ? 1 : -1;\n22 +\n23 +  if (a === null || a === undefined) return 1;\n24 +  if (b === null || b === undefined) return -1;\n25 +\n26 +  if (typeof a === 'string' && typeof b === 'string') {\n27 +    return a.localeCompare(b) * modifier;\n28 +  }\n29 +\n30 +  if (typeof a === 'number' && typeof b === 'number') {\n31 +    return (a - b) * modifier;\n32 +  }\n33 +\n34 +  if (a instanceof Date && b instanceof Date) {\n35 +    return (a.getTime() - b.getTime()) * modifier;\n36 +  }\n37 +\n38 +  return 0;\n39 +}\n40 +\n41 +export function sortProducts(\n42 +  products: Product[],\n43 +  configs: SortConfig[]\n44 +): Product[] {\n45 +  if (configs.length === 0) return products;\n46 +\n47 +  return [...products].sort((a, b) => {\n48 +    for (const config of configs) {\n49 +      const aValue = a[config.field];\n50 +      const bValue = b[config.field];\n51 +      const result = compareValues(aValue, bValue, config.direction);\n52 +      if (result !== 0) return result;\n53 +    }\n54 +    return 0;\n55 +  });\n56 +}\n57 +\n58 +export function sortByPopularity(products: Product[]): Product[] {\n59 +  return [...products].sort((a, b) => {\n60 +    const aScore = (a.rating ?? 0) * Math.log(a.reviewCount + 1);\n61 +    const bScore = (b.rating ?? 0) * Math.log(b.reviewCount + 1);\n62 +    return bScore - aScore;\n63 +  });\n64 +}\n65 +\n66 +export function sortByRelevance(\n67 +  products: Product[],\n68 +  searchTerm: string\n69 +): Product[] {\n70 +  const term = searchTerm.toLowerCase();\n71 +\n72 +  return [...products].sort((a, b) => {\n73 +    const aNameMatch = a.name.toLowerCase().includes(term);\n74 +    const bNameMatch = b.name.toLowerCase().includes(term);\n75 +\n76 +    if (aNameMatch && !bNameMatch) return -1;\n77 +    if (!aNameMatch && bNameMatch) return 1;\n78 +\n79 +    const aExact = a.name.toLowerCase() === term;\n80 +    const bExact = b.name.toLowerCase() === term;\n81 +\n82 +    if (aExact && !bExact) return -1;\n83 +    if (!aExact && bExact) return 1;\n84 +\n85 +    return (b.rating ?? 0) - (a.rating ?? 0);\n86 +  });\n87 +}\n88 +\n89 +export class ProductSorter {\n90 +  private defaultConfigs: SortConfig[] = [];\n91 +\n92 +  setDefaults(configs: SortConfig[]): void {\n93 +    this.defaultConfigs = configs;\n94 +  }\n95 +\n96 +  sort(products: Product[], configs?: SortConfig[]): Product[] {\n97 +    return sortProducts(products, configs ?? this.defaultConfigs);\n98 +  }\n99 +}\n100 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/data/src/sorting/ProductSorter.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "if (a === null || a === undefined) return 1;\n  if (b === null || b === undefined) return -1;", "improvedCode": "if (a === null || a === undefined) {\n    return b === null || b === undefined ? 0 : 1;\n  }\n  if (b === null || b === undefined) return -1;", "relevantFile": "packages/data/src/sorting/ProductSorter.ts", "relevantLinesEnd": 23, "suggestionContent": "The `compareValues` function returns inconsistent values when comparing null/undefined values, violating the sort comparator contract. When `a` is null it returns 1, and when `b` is null it returns -1. But when both are null, neither condition triggers and it falls through to return 0. However, if you have [null, 1, null], comparing positions 0-1 says null>1, but comparing 1-2 says 1>null, creating an inconsistent ordering that can cause Array.sort to produce unpredictable results or infinite loops in some JS engines.", "oneSentenceSummary": "Sort comparator violates transitivity when handling null values causing unstable sort", "relevantLinesStart": 21}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/network/src/utils/withTimeout.ts", "language": "TypeScript", "fileContent": "import { NetworkError } from '../errors/NetworkError';\n\ninterface TimeoutOptions {\n  timeoutMs: number;\n  errorMessage?: string;\n  onTimeout?: () => void;\n}\n\ntype Awaitable<T> = T | Promise<T>;\n\nexport class TimeoutError extends Error {\n  readonly code = 'TIMEOUT';\n\n  constructor(message: string, public readonly timeoutMs: number) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\nfunction createTimeoutPromise(ms: number, message: string): Promise<never> {\n  return new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new TimeoutError(message, ms));\n    }, ms);\n  });\n}\n\nexport async function withTimeout<T>(\n  operation: Awaitable<T>,\n  options: TimeoutOptions\n): Promise<T> {\n  const { timeoutMs, errorMessage, onTimeout } = options;\n\n  const timeoutPromise = createTimeoutPromise(\n    timeoutMs,\n    errorMessage ?? `Operation timed out after ${timeoutMs}ms`\n  );\n\n  try {\n    const result = await Promise.race([\n      Promise.resolve(operation),\n      timeoutPromise,\n    ]);\n    return result;\n  } catch (error) {\n    if (error instanceof TimeoutError) {\n      onTimeout?.();\n    }\n    throw error;\n  }\n}\n\nexport async function withRetryAndTimeout<T>(\n  operation: () => Promise<T>,\n  options: {\n    timeoutMs: number;\n    maxRetries: number;\n    retryDelayMs: number;\n  }\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n    try {\n      return await withTimeout(operation(), {\n        timeoutMs: options.timeoutMs,\n      });\n    } catch (error) {\n      lastError = error as Error;\n      if (attempt < options.maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, options.retryDelayMs));\n      }\n    }\n  }\n\n  throw lastError ?? new NetworkError('All retries exhausted');\n}\n\nexport function isTimeoutError(error: unknown): error is TimeoutError {\n  return error instanceof TimeoutError;\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/network/src/utils/withTimeout.ts'\n\n@@ -0,0 +1,82 @@\n__new hunk__\n1 +import { NetworkError } from '../errors/NetworkError';\n2 +\n3 +interface TimeoutOptions {\n4 +  timeoutMs: number;\n5 +  errorMessage?: string;\n6 +  onTimeout?: () => void;\n7 +}\n8 +\n9 +type Awaitable<T> = T | Promise<T>;\n10 +\n11 +export class TimeoutError extends Error {\n12 +  readonly code = 'TIMEOUT';\n13 +\n14 +  constructor(message: string, public readonly timeoutMs: number) {\n15 +    super(message);\n16 +    this.name = 'TimeoutError';\n17 +  }\n18 +}\n19 +\n20 +function createTimeoutPromise(ms: number, message: string): Promise<never> {\n21 +  return new Promise((_, reject) => {\n22 +    setTimeout(() => {\n23 +      reject(new TimeoutError(message, ms));\n24 +    }, ms);\n25 +  });\n26 +}\n27 +\n28 +export async function withTimeout<T>(\n29 +  operation: Awaitable<T>,\n30 +  options: TimeoutOptions\n31 +): Promise<T> {\n32 +  const { timeoutMs, errorMessage, onTimeout } = options;\n33 +\n34 +  const timeoutPromise = createTimeoutPromise(\n35 +    timeoutMs,\n36 +    errorMessage ?? `Operation timed out after ${timeoutMs}ms`\n37 +  );\n38 +\n39 +  try {\n40 +    const result = await Promise.race([\n41 +      Promise.resolve(operation),\n42 +      timeoutPromise,\n43 +    ]);\n44 +    return result;\n45 +  } catch (error) {\n46 +    if (error instanceof TimeoutError) {\n47 +      onTimeout?.();\n48 +    }\n49 +    throw error;\n50 +  }\n51 +}\n52 +\n53 +export async function withRetryAndTimeout<T>(\n54 +  operation: () => Promise<T>,\n55 +  options: {\n56 +    timeoutMs: number;\n57 +    maxRetries: number;\n58 +    retryDelayMs: number;\n59 +  }\n60 +): Promise<T> {\n61 +  let lastError: Error | undefined;\n62 +\n63 +  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n64 +    try {\n65 +      return await withTimeout(operation(), {\n66 +        timeoutMs: options.timeoutMs,\n67 +      });\n68 +    } catch (error) {\n69 +      lastError = error as Error;\n70 +      if (attempt < options.maxRetries) {\n71 +        await new Promise(resolve => setTimeout(resolve, options.retryDelayMs));\n72 +      }\n73 +    }\n74 +  }\n75 +\n76 +  throw lastError ?? new NetworkError('All retries exhausted');\n77 +}\n78 +\n79 +export function isTimeoutError(error: unknown): error is TimeoutError {\n80 +  return error instanceof TimeoutError;\n81 +}\n82 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/network/src/utils/withTimeout.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "function createTimeoutPromise(ms: number, message: string): Promise<never> {\n  return new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new TimeoutError(message, ms));\n    }, ms);\n  });\n}", "improvedCode": "function createTimeoutPromise(ms: number, message: string, signal: AbortSignal): Promise<never> {\n  return new Promise((_, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new TimeoutError(message, ms));\n    }, ms);\n    signal.addEventListener('abort', () => clearTimeout(timeoutId));\n  });\n}", "relevantFile": "packages/network/src/utils/withTimeout.ts", "relevantLinesEnd": 25, "suggestionContent": "The timeout promise created by `createTimeoutPromise` is never cancelled when the operation succeeds. In Promise.race, losing promises continue to exist and their timers keep running. If `withTimeout` is called frequently (e.g., for every API request), these orphaned setTimeout callbacks accumulate in memory until they fire, causing a memory leak. Use AbortController or manually clear the timeout when the operation completes.", "oneSentenceSummary": "Promise.race memory leak - timeout timer is never cancelled when operation succeeds", "relevantLinesStart": 19}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/sync/src/services/DataSyncService.ts", "language": "TypeScript", "fileContent": "import { EventEmitter } from 'events';\n\nexport interface SyncItem {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  entity: string;\n  data: Record<string, unknown>;\n  timestamp: number;\n}\n\nexport interface SyncResult {\n  success: boolean;\n  itemId: string;\n  error?: Error;\n}\n\nexport interface SyncConfig {\n  batchSize: number;\n  retryAttempts: number;\n  retryDelayMs: number;\n  onProgress?: (completed: number, total: number) => void;\n}\n\nconst DEFAULT_CONFIG: SyncConfig = {\n  batchSize: 50,\n  retryAttempts: 3,\n  retryDelayMs: 1000,\n};\n\nexport class DataSyncService extends EventEmitter {\n  private config: SyncConfig;\n  private isRunning = false;\n  private queue: SyncItem[] = [];\n\n  constructor(config: Partial<SyncConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async syncItem(item: SyncItem): Promise<SyncResult> {\n    // Simulated sync operation\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    if (Math.random() < 0.1) {\n      throw new Error(`Failed to sync item ${item.id}`);\n    }\n\n    return { success: true, itemId: item.id };\n  }\n\n  async syncBatch(items: SyncItem[]): Promise<SyncResult[]> {\n    const results: SyncResult[] = [];\n\n    await items.forEach(async (item) => {\n      try {\n        const result = await this.syncItem(item);\n        results.push(result);\n        this.emit('itemSynced', result);\n      } catch (error) {\n        results.push({\n          success: false,\n          itemId: item.id,\n          error: error as Error,\n        });\n        this.emit('itemFailed', { itemId: item.id, error });\n      }\n    });\n\n    return results;\n  }\n\n  async syncAll(items: SyncItem[]): Promise<SyncResult[]> {\n    if (this.isRunning) {\n      throw new Error('Sync already in progress');\n    }\n\n    this.isRunning = true;\n    this.emit('syncStarted', { total: items.length });\n\n    const allResults: SyncResult[] = [];\n    const batches: SyncItem[][] = [];\n\n    for (let i = 0; i < items.length; i += this.config.batchSize) {\n      batches.push(items.slice(i, i + this.config.batchSize));\n    }\n\n    for (const batch of batches) {\n      const batchResults = await this.syncBatch(batch);\n      allResults.push(...batchResults);\n\n      this.config.onProgress?.(\n        allResults.length,\n        items.length\n      );\n    }\n\n    this.isRunning = false;\n    this.emit('syncCompleted', { results: allResults });\n\n    return allResults;\n  }\n\n  addToQueue(item: SyncItem): void {\n    this.queue.push(item);\n  }\n\n  async processQueue(): Promise<SyncResult[]> {\n    const items = [...this.queue];\n    this.queue = [];\n    return this.syncAll(items);\n  }\n\n  getQueueLength(): number {\n    return this.queue.length;\n  }\n}\n\nexport async function createSyncService(\n  config?: Partial<SyncConfig>\n): Promise<DataSyncService> {\n  return new DataSyncService(config);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/sync/src/services/DataSyncService.ts'\n\n@@ -0,0 +1,123 @@\n__new hunk__\n1 +import { EventEmitter } from 'events';\n2 +\n3 +export interface SyncItem {\n4 +  id: string;\n5 +  type: 'create' | 'update' | 'delete';\n6 +  entity: string;\n7 +  data: Record<string, unknown>;\n8 +  timestamp: number;\n9 +}\n10 +\n11 +export interface SyncResult {\n12 +  success: boolean;\n13 +  itemId: string;\n14 +  error?: Error;\n15 +}\n16 +\n17 +export interface SyncConfig {\n18 +  batchSize: number;\n19 +  retryAttempts: number;\n20 +  retryDelayMs: number;\n21 +  onProgress?: (completed: number, total: number) => void;\n22 +}\n23 +\n24 +const DEFAULT_CONFIG: SyncConfig = {\n25 +  batchSize: 50,\n26 +  retryAttempts: 3,\n27 +  retryDelayMs: 1000,\n28 +};\n29 +\n30 +export class DataSyncService extends EventEmitter {\n31 +  private config: SyncConfig;\n32 +  private isRunning = false;\n33 +  private queue: SyncItem[] = [];\n34 +\n35 +  constructor(config: Partial<SyncConfig> = {}) {\n36 +    super();\n37 +    this.config = { ...DEFAULT_CONFIG, ...config };\n38 +  }\n39 +\n40 +  async syncItem(item: SyncItem): Promise<SyncResult> {\n41 +    // Simulated sync operation\n42 +    await new Promise(resolve => setTimeout(resolve, 100));\n43 +\n44 +    if (Math.random() < 0.1) {\n45 +      throw new Error(`Failed to sync item ${item.id}`);\n46 +    }\n47 +\n48 +    return { success: true, itemId: item.id };\n49 +  }\n50 +\n51 +  async syncBatch(items: SyncItem[]): Promise<SyncResult[]> {\n52 +    const results: SyncResult[] = [];\n53 +\n54 +    await items.forEach(async (item) => {\n55 +      try {\n56 +        const result = await this.syncItem(item);\n57 +        results.push(result);\n58 +        this.emit('itemSynced', result);\n59 +      } catch (error) {\n60 +        results.push({\n61 +          success: false,\n62 +          itemId: item.id,\n63 +          error: error as Error,\n64 +        });\n65 +        this.emit('itemFailed', { itemId: item.id, error });\n66 +      }\n67 +    });\n68 +\n69 +    return results;\n70 +  }\n71 +\n72 +  async syncAll(items: SyncItem[]): Promise<SyncResult[]> {\n73 +    if (this.isRunning) {\n74 +      throw new Error('Sync already in progress');\n75 +    }\n76 +\n77 +    this.isRunning = true;\n78 +    this.emit('syncStarted', { total: items.length });\n79 +\n80 +    const allResults: SyncResult[] = [];\n81 +    const batches: SyncItem[][] = [];\n82 +\n83 +    for (let i = 0; i < items.length; i += this.config.batchSize) {\n84 +      batches.push(items.slice(i, i + this.config.batchSize));\n85 +    }\n86 +\n87 +    for (const batch of batches) {\n88 +      const batchResults = await this.syncBatch(batch);\n89 +      allResults.push(...batchResults);\n90 +\n91 +      this.config.onProgress?.(\n92 +        allResults.length,\n93 +        items.length\n94 +      );\n95 +    }\n96 +\n97 +    this.isRunning = false;\n98 +    this.emit('syncCompleted', { results: allResults });\n99 +\n100 +    return allResults;\n101 +  }\n102 +\n103 +  addToQueue(item: SyncItem): void {\n104 +    this.queue.push(item);\n105 +  }\n106 +\n107 +  async processQueue(): Promise<SyncResult[]> {\n108 +    const items = [...this.queue];\n109 +    this.queue = [];\n110 +    return this.syncAll(items);\n111 +  }\n112 +\n113 +  getQueueLength(): number {\n114 +    return this.queue.length;\n115 +  }\n116 +}\n117 +\n118 +export async function createSyncService(\n119 +  config?: Partial<SyncConfig>\n120 +): Promise<DataSyncService> {\n121 +  return new DataSyncService(config);\n122 +}\n123 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/sync/src/services/DataSyncService.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "await items.forEach(async (item) => {\n      try {\n        const result = await this.syncItem(item);\n        results.push(result);", "improvedCode": "await Promise.all(items.map(async (item) => {\n      try {\n        const result = await this.syncItem(item);\n        results.push(result);", "relevantFile": "packages/sync/src/services/DataSyncService.ts", "relevantLinesEnd": 63, "suggestionContent": "The `syncBatch` method uses `await items.forEach(async ...)` which does not actually wait for the async callbacks to complete. `Array.forEach` ignores the return value of callbacks (including Promises), so this returns an empty `results` array immediately while the sync operations continue in the background. Use `Promise.all` with `map`, or a for...of loop to properly await each operation.", "oneSentenceSummary": "await forEach does not wait for async callbacks - returns empty array", "relevantLinesStart": 50}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/api/src/client/ApiClient.ts", "language": "TypeScript", "fileContent": "import { EventEmitter } from 'events';\n\nexport interface RequestConfig {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  url: string;\n  data?: unknown;\n  headers?: Record<string, string>;\n  timeout?: number;\n  retries?: number;\n}\n\nexport interface ApiResponse<T = unknown> {\n  data: T;\n  status: number;\n  headers: Record<string, string>;\n}\n\nexport interface ApiClientConfig {\n  baseUrl: string;\n  defaultTimeout: number;\n  defaultRetries: number;\n  authToken?: string;\n}\n\ntype RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\ntype ResponseInterceptor = <T>(response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;\n\nconst RETRY_STATUS_CODES = [408, 429, 500, 502, 503, 504];\n\nexport class ApiClient extends EventEmitter {\n  private config: ApiClientConfig;\n  private requestInterceptors: RequestInterceptor[] = [];\n  private responseInterceptors: ResponseInterceptor[] = [];\n  private pendingRequests: Map<string, AbortController> = new Map();\n  private requestCount = 0;\n  private isRefreshingToken = false;\n  private tokenRefreshPromise: Promise<string> | null = null;\n\n  constructor(config: ApiClientConfig) {\n    super();\n    this.config = config;\n  }\n\n  addRequestInterceptor(interceptor: RequestInterceptor): () => void {\n    this.requestInterceptors.push(interceptor);\n    return () => {\n      const index = this.requestInterceptors.indexOf(interceptor);\n      if (index > -1) this.requestInterceptors.splice(index, 1);\n    };\n  }\n\n  addResponseInterceptor(interceptor: ResponseInterceptor): () => void {\n    this.responseInterceptors.push(interceptor);\n    return () => {\n      const index = this.responseInterceptors.indexOf(interceptor);\n      if (index > -1) this.responseInterceptors.splice(index, 1);\n    };\n  }\n\n  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n    let currentConfig = config;\n    for (const interceptor of this.requestInterceptors) {\n      currentConfig = await interceptor(currentConfig);\n    }\n    return currentConfig;\n  }\n\n  private async applyResponseInterceptors<T>(response: ApiResponse<T>): Promise<ApiResponse<T>> {\n    let currentResponse = response;\n    for (const interceptor of this.responseInterceptors) {\n      currentResponse = await interceptor(currentResponse);\n    }\n    return currentResponse;\n  }\n\n  private generateRequestId(): string {\n    return `req_${++this.requestCount}_${Date.now()}`;\n  }\n\n  async refreshAuthToken(): Promise<string> {\n    if (this.isRefreshingToken) {\n      return this.tokenRefreshPromise!;\n    }\n\n    this.isRefreshingToken = true;\n    this.tokenRefreshPromise = this.doRefreshToken();\n\n    const newToken = await this.tokenRefreshPromise;\n    this.config.authToken = newToken;\n    this.isRefreshingToken = false;\n\n    return newToken;\n  }\n\n  private async doRefreshToken(): Promise<string> {\n    const response = await fetch(`${this.config.baseUrl}/auth/refresh`, {\n      method: 'POST',\n      credentials: 'include',\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to refresh token');\n    }\n\n    const data = await response.json();\n    return data.token;\n  }\n\n  async request<T>(config: RequestConfig): Promise<ApiResponse<T>> {\n    const requestId = this.generateRequestId();\n    const abortController = new AbortController();\n    this.pendingRequests.set(requestId, abortController);\n\n    const finalConfig = await this.applyRequestInterceptors({\n      ...config,\n      timeout: config.timeout ?? this.config.defaultTimeout,\n      retries: config.retries ?? this.config.defaultRetries,\n    });\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      ...finalConfig.headers,\n    };\n\n    if (this.config.authToken) {\n      headers['Authorization'] = `Bearer ${this.config.authToken}`;\n    }\n\n    let lastError: Error | null = null;\n    const maxRetries = finalConfig.retries ?? 0;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const timeoutId = setTimeout(() => {\n          abortController.abort();\n        }, finalConfig.timeout);\n\n        const response = await fetch(`${this.config.baseUrl}${finalConfig.url}`, {\n          method: finalConfig.method,\n          headers,\n          body: finalConfig.data ? JSON.stringify(finalConfig.data) : undefined,\n          signal: abortController.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (response.status === 401 && this.config.authToken) {\n          await this.refreshAuthToken();\n          headers['Authorization'] = `Bearer ${this.config.authToken}`;\n          continue;\n        }\n\n        if (!response.ok) {\n          if (RETRY_STATUS_CODES.includes(response.status) && attempt < maxRetries) {\n            await this.delay(Math.pow(2, attempt) * 1000);\n            continue;\n          }\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        const apiResponse: ApiResponse<T> = {\n          data,\n          status: response.status,\n          headers: Object.fromEntries(response.headers.entries()),\n        };\n\n        this.emit('requestComplete', { requestId, response: apiResponse });\n        return this.applyResponseInterceptors(apiResponse);\n\n      } catch (error) {\n        lastError = error as Error;\n        if (attempt < maxRetries) {\n          await this.delay(Math.pow(2, attempt) * 1000);\n        }\n      }\n    }\n\n    this.emit('requestFailed', { requestId, error: lastError });\n    throw lastError;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  cancelRequest(requestId: string): void {\n    const controller = this.pendingRequests.get(requestId);\n    if (controller) {\n      controller.abort();\n      this.pendingRequests.delete(requestId);\n    }\n  }\n\n  cancelAllRequests(): void {\n    for (const [id, controller] of this.pendingRequests) {\n      controller.abort();\n    }\n    this.pendingRequests.clear();\n  }\n\n  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'GET', url, ...config });\n  }\n\n  async post<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'POST', url, data, ...config });\n  }\n\n  async put<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'PUT', url, data, ...config });\n  }\n\n  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'DELETE', url, ...config });\n  }\n}\n\nexport function createApiClient(config: ApiClientConfig): ApiClient {\n  return new ApiClient(config);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/api/src/client/ApiClient.ts'\n\n@@ -0,0 +1,222 @@\n__new hunk__\n1 +import { EventEmitter } from 'events';\n2 +\n3 +export interface RequestConfig {\n4 +  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n5 +  url: string;\n6 +  data?: unknown;\n7 +  headers?: Record<string, string>;\n8 +  timeout?: number;\n9 +  retries?: number;\n10 +}\n11 +\n12 +export interface ApiResponse<T = unknown> {\n13 +  data: T;\n14 +  status: number;\n15 +  headers: Record<string, string>;\n16 +}\n17 +\n18 +export interface ApiClientConfig {\n19 +  baseUrl: string;\n20 +  defaultTimeout: number;\n21 +  defaultRetries: number;\n22 +  authToken?: string;\n23 +}\n24 +\n25 +type RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n26 +type ResponseInterceptor = <T>(response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;\n27 +\n28 +const RETRY_STATUS_CODES = [408, 429, 500, 502, 503, 504];\n29 +\n30 +export class ApiClient extends EventEmitter {\n31 +  private config: ApiClientConfig;\n32 +  private requestInterceptors: RequestInterceptor[] = [];\n33 +  private responseInterceptors: ResponseInterceptor[] = [];\n34 +  private pendingRequests: Map<string, AbortController> = new Map();\n35 +  private requestCount = 0;\n36 +  private isRefreshingToken = false;\n37 +  private tokenRefreshPromise: Promise<string> | null = null;\n38 +\n39 +  constructor(config: ApiClientConfig) {\n40 +    super();\n41 +    this.config = config;\n42 +  }\n43 +\n44 +  addRequestInterceptor(interceptor: RequestInterceptor): () => void {\n45 +    this.requestInterceptors.push(interceptor);\n46 +    return () => {\n47 +      const index = this.requestInterceptors.indexOf(interceptor);\n48 +      if (index > -1) this.requestInterceptors.splice(index, 1);\n49 +    };\n50 +  }\n51 +\n52 +  addResponseInterceptor(interceptor: ResponseInterceptor): () => void {\n53 +    this.responseInterceptors.push(interceptor);\n54 +    return () => {\n55 +      const index = this.responseInterceptors.indexOf(interceptor);\n56 +      if (index > -1) this.responseInterceptors.splice(index, 1);\n57 +    };\n58 +  }\n59 +\n60 +  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n61 +    let currentConfig = config;\n62 +    for (const interceptor of this.requestInterceptors) {\n63 +      currentConfig = await interceptor(currentConfig);\n64 +    }\n65 +    return currentConfig;\n66 +  }\n67 +\n68 +  private async applyResponseInterceptors<T>(response: ApiResponse<T>): Promise<ApiResponse<T>> {\n69 +    let currentResponse = response;\n70 +    for (const interceptor of this.responseInterceptors) {\n71 +      currentResponse = await interceptor(currentResponse);\n72 +    }\n73 +    return currentResponse;\n74 +  }\n75 +\n76 +  private generateRequestId(): string {\n77 +    return `req_${++this.requestCount}_${Date.now()}`;\n78 +  }\n79 +\n80 +  async refreshAuthToken(): Promise<string> {\n81 +    if (this.isRefreshingToken) {\n82 +      return this.tokenRefreshPromise!;\n83 +    }\n84 +\n85 +    this.isRefreshingToken = true;\n86 +    this.tokenRefreshPromise = this.doRefreshToken();\n87 +\n88 +    const newToken = await this.tokenRefreshPromise;\n89 +    this.config.authToken = newToken;\n90 +    this.isRefreshingToken = false;\n91 +\n92 +    return newToken;\n93 +  }\n94 +\n95 +  private async doRefreshToken(): Promise<string> {\n96 +    const response = await fetch(`${this.config.baseUrl}/auth/refresh`, {\n97 +      method: 'POST',\n98 +      credentials: 'include',\n99 +    });\n100 +\n101 +    if (!response.ok) {\n102 +      throw new Error('Failed to refresh token');\n103 +    }\n104 +\n105 +    const data = await response.json();\n106 +    return data.token;\n107 +  }\n108 +\n109 +  async request<T>(config: RequestConfig): Promise<ApiResponse<T>> {\n110 +    const requestId = this.generateRequestId();\n111 +    const abortController = new AbortController();\n112 +    this.pendingRequests.set(requestId, abortController);\n113 +\n114 +    const finalConfig = await this.applyRequestInterceptors({\n115 +      ...config,\n116 +      timeout: config.timeout ?? this.config.defaultTimeout,\n117 +      retries: config.retries ?? this.config.defaultRetries,\n118 +    });\n119 +\n120 +    const headers: Record<string, string> = {\n121 +      'Content-Type': 'application/json',\n122 +      ...finalConfig.headers,\n123 +    };\n124 +\n125 +    if (this.config.authToken) {\n126 +      headers['Authorization'] = `Bearer ${this.config.authToken}`;\n127 +    }\n128 +\n129 +    let lastError: Error | null = null;\n130 +    const maxRetries = finalConfig.retries ?? 0;\n131 +\n132 +    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n133 +      try {\n134 +        const timeoutId = setTimeout(() => {\n135 +          abortController.abort();\n136 +        }, finalConfig.timeout);\n137 +\n138 +        const response = await fetch(`${this.config.baseUrl}${finalConfig.url}`, {\n139 +          method: finalConfig.method,\n140 +          headers,\n141 +          body: finalConfig.data ? JSON.stringify(finalConfig.data) : undefined,\n142 +          signal: abortController.signal,\n143 +        });\n144 +\n145 +        clearTimeout(timeoutId);\n146 +\n147 +        if (response.status === 401 && this.config.authToken) {\n148 +          await this.refreshAuthToken();\n149 +          headers['Authorization'] = `Bearer ${this.config.authToken}`;\n150 +          continue;\n151 +        }\n152 +\n153 +        if (!response.ok) {\n154 +          if (RETRY_STATUS_CODES.includes(response.status) && attempt < maxRetries) {\n155 +            await this.delay(Math.pow(2, attempt) * 1000);\n156 +            continue;\n157 +          }\n158 +          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n159 +        }\n160 +\n161 +        const data = await response.json();\n162 +        const apiResponse: ApiResponse<T> = {\n163 +          data,\n164 +          status: response.status,\n165 +          headers: Object.fromEntries(response.headers.entries()),\n166 +        };\n167 +\n168 +        this.emit('requestComplete', { requestId, response: apiResponse });\n169 +        return this.applyResponseInterceptors(apiResponse);\n170 +\n171 +      } catch (error) {\n172 +        lastError = error as Error;\n173 +        if (attempt < maxRetries) {\n174 +          await this.delay(Math.pow(2, attempt) * 1000);\n175 +        }\n176 +      }\n177 +    }\n178 +\n179 +    this.emit('requestFailed', { requestId, error: lastError });\n180 +    throw lastError;\n181 +  }\n182 +\n183 +  private delay(ms: number): Promise<void> {\n184 +    return new Promise(resolve => setTimeout(resolve, ms));\n185 +  }\n186 +\n187 +  cancelRequest(requestId: string): void {\n188 +    const controller = this.pendingRequests.get(requestId);\n189 +    if (controller) {\n190 +      controller.abort();\n191 +      this.pendingRequests.delete(requestId);\n192 +    }\n193 +  }\n194 +\n195 +  cancelAllRequests(): void {\n196 +    for (const [id, controller] of this.pendingRequests) {\n197 +      controller.abort();\n198 +    }\n199 +    this.pendingRequests.clear();\n200 +  }\n201 +\n202 +  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n203 +    return this.request<T>({ method: 'GET', url, ...config });\n204 +  }\n205 +\n206 +  async post<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n207 +    return this.request<T>({ method: 'POST', url, data, ...config });\n208 +  }\n209 +\n210 +  async put<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n211 +    return this.request<T>({ method: 'PUT', url, data, ...config });\n212 +  }\n213 +\n214 +  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n215 +    return this.request<T>({ method: 'DELETE', url, ...config });\n216 +  }\n217 +}\n218 +\n219 +export function createApiClient(config: ApiClientConfig): ApiClient {\n220 +  return new ApiClient(config);\n221 +}\n222 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in packages/api/src/client/ApiClient.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "async refreshAuthToken(): Promise<string> {\n    if (this.isRefreshingToken) {\n      return this.tokenRefreshPromise!;\n    }\n\n    this.isRefreshingToken = true;\n    this.tokenRefreshPromise = this.doRefreshToken();", "improvedCode": "async refreshAuthToken(): Promise<string> {\n    if (this.tokenRefreshPromise) {\n      return this.tokenRefreshPromise;\n    }\n\n    this.tokenRefreshPromise = this.doRefreshToken().finally(() => {\n      this.tokenRefreshPromise = null;\n    });", "relevantFile": "packages/api/src/client/ApiClient.ts", "relevantLinesEnd": 90, "suggestionContent": "The `refreshAuthToken` method has a race condition. After checking `this.isRefreshingToken` and before setting it to `true`, another call could pass the check. Also, after the token refresh completes, `this.isRefreshingToken` is set to `false` but `this.tokenRefreshPromise` is not cleared, so subsequent checks of `this.tokenRefreshPromise!` could return a stale resolved promise.", "oneSentenceSummary": "Race condition in token refresh - multiple concurrent refreshes possible", "relevantLinesStart": 78}, {"label": "bug", "language": "TypeScript", "existingCode": "this.emit('requestComplete', { requestId, response: apiResponse });\n        return this.applyResponseInterceptors(apiResponse);", "improvedCode": "this.pendingRequests.delete(requestId);\n        this.emit('requestComplete', { requestId, response: apiResponse });\n        return this.applyResponseInterceptors(apiResponse);", "relevantFile": "packages/api/src/client/ApiClient.ts", "relevantLinesEnd": 157, "suggestionContent": "The `pendingRequests` Map stores AbortControllers but never removes them after a request completes successfully. Only `cancelRequest` removes entries. Over time, this causes a memory leak as the Map grows unboundedly with completed request entries.", "oneSentenceSummary": "Memory leak - pendingRequests Map never cleaned up after successful requests", "relevantLinesStart": 156}, {"label": "bug", "language": "TypeScript", "existingCode": "if (response.status === 401 && this.config.authToken) {\n          await this.refreshAuthToken();\n          headers['Authorization'] = `Bearer ${this.config.authToken}`;\n          continue;\n        }", "improvedCode": "if (response.status === 401 && this.config.authToken) {\n          await this.refreshAuthToken();\n          headers['Authorization'] = `Bearer ${this.config.authToken}`;\n          attempt--; // Don't count 401 retry against retry limit\n          continue;\n        }", "relevantFile": "packages/api/src/client/ApiClient.ts", "relevantLinesEnd": 145, "suggestionContent": "The retry loop continues after a 401 response and token refresh, but the `attempt` counter is still incremented. This means if token refresh happens on the last retry attempt, the request won't be retried with the new token. Also, the finally block doesn't clean up the pendingRequests entry on failure.", "oneSentenceSummary": "401 retry consumes retry attempt - may fail if token expires on last retry", "relevantLinesStart": 140}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/scheduling/src/utils/DateScheduler.ts", "language": "TypeScript", "fileContent": "export interface ScheduleConfig {\n  startDate: string;\n  endDate: string;\n  timezone: string;\n  recurrence?: 'daily' | 'weekly' | 'monthly';\n  excludeWeekends?: boolean;\n}\n\nexport interface ScheduledEvent {\n  id: string;\n  date: Date;\n  originalDate: string;\n}\n\nexport function parseDate(dateString: string): Date {\n  return new Date(dateString);\n}\n\nexport function formatDate(date: Date): string {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\nexport function addDays(date: Date, days: number): Date {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n}\n\nexport function addMonths(date: Date, months: number): Date {\n  const result = new Date(date);\n  result.setMonth(result.getMonth() + months);\n  return result;\n}\n\nexport function isWeekend(date: Date): boolean {\n  const day = date.getDay();\n  return day === 0 || day === 6;\n}\n\nexport function getBusinessDaysBetween(start: Date, end: Date): number {\n  let count = 0;\n  const current = new Date(start);\n\n  while (current <= end) {\n    if (!isWeekend(current)) {\n      count++;\n    }\n    current.setDate(current.getDate() + 1);\n  }\n\n  return count;\n}\n\nexport function generateSchedule(config: ScheduleConfig): ScheduledEvent[] {\n  const events: ScheduledEvent[] = [];\n  const start = parseDate(config.startDate);\n  const end = parseDate(config.endDate);\n\n  let current = start;\n  let eventId = 1;\n\n  while (current <= end) {\n    if (!config.excludeWeekends || !isWeekend(current)) {\n      events.push({\n        id: `event_${eventId++}`,\n        date: current,\n        originalDate: formatDate(current),\n      });\n    }\n\n    switch (config.recurrence) {\n      case 'daily':\n        current = addDays(current, 1);\n        break;\n      case 'weekly':\n        current = addDays(current, 7);\n        break;\n      case 'monthly':\n        current = addMonths(current, 1);\n        break;\n      default:\n        current = addDays(current, 1);\n    }\n  }\n\n  return events;\n}\n\nexport function getNextBusinessDay(date: Date): Date {\n  let next = addDays(date, 1);\n  while (isWeekend(next)) {\n    next = addDays(next, 1);\n  }\n  return next;\n}\n\nexport function isSameDay(date1: Date, date2: Date): boolean {\n  return (\n    date1.getFullYear() === date2.getFullYear() &&\n    date1.getMonth() === date2.getMonth() &&\n    date1.getDate() === date2.getDate()\n  );\n}\n\nexport function getDaysDifference(date1: Date, date2: Date): number {\n  const diffTime = date2.getTime() - date1.getTime();\n  return diffTime / (1000 * 60 * 60 * 24);\n}\n\nexport class DateScheduler {\n  private config: ScheduleConfig;\n\n  constructor(config: ScheduleConfig) {\n    this.config = config;\n  }\n\n  generate(): ScheduledEvent[] {\n    return generateSchedule(this.config);\n  }\n\n  isValidDate(date: Date): boolean {\n    const start = parseDate(this.config.startDate);\n    const end = parseDate(this.config.endDate);\n    return date >= start && date <= end;\n  }\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/scheduling/src/utils/DateScheduler.ts'\n\n@@ -0,0 +1,130 @@\n__new hunk__\n1 +export interface ScheduleConfig {\n2 +  startDate: string;\n3 +  endDate: string;\n4 +  timezone: string;\n5 +  recurrence?: 'daily' | 'weekly' | 'monthly';\n6 +  excludeWeekends?: boolean;\n7 +}\n8 +\n9 +export interface ScheduledEvent {\n10 +  id: string;\n11 +  date: Date;\n12 +  originalDate: string;\n13 +}\n14 +\n15 +export function parseDate(dateString: string): Date {\n16 +  return new Date(dateString);\n17 +}\n18 +\n19 +export function formatDate(date: Date): string {\n20 +  const year = date.getFullYear();\n21 +  const month = String(date.getMonth() + 1).padStart(2, '0');\n22 +  const day = String(date.getDate()).padStart(2, '0');\n23 +  return `${year}-${month}-${day}`;\n24 +}\n25 +\n26 +export function addDays(date: Date, days: number): Date {\n27 +  const result = new Date(date);\n28 +  result.setDate(result.getDate() + days);\n29 +  return result;\n30 +}\n31 +\n32 +export function addMonths(date: Date, months: number): Date {\n33 +  const result = new Date(date);\n34 +  result.setMonth(result.getMonth() + months);\n35 +  return result;\n36 +}\n37 +\n38 +export function isWeekend(date: Date): boolean {\n39 +  const day = date.getDay();\n40 +  return day === 0 || day === 6;\n41 +}\n42 +\n43 +export function getBusinessDaysBetween(start: Date, end: Date): number {\n44 +  let count = 0;\n45 +  const current = new Date(start);\n46 +\n47 +  while (current <= end) {\n48 +    if (!isWeekend(current)) {\n49 +      count++;\n50 +    }\n51 +    current.setDate(current.getDate() + 1);\n52 +  }\n53 +\n54 +  return count;\n55 +}\n56 +\n57 +export function generateSchedule(config: ScheduleConfig): ScheduledEvent[] {\n58 +  const events: ScheduledEvent[] = [];\n59 +  const start = parseDate(config.startDate);\n60 +  const end = parseDate(config.endDate);\n61 +\n62 +  let current = start;\n63 +  let eventId = 1;\n64 +\n65 +  while (current <= end) {\n66 +    if (!config.excludeWeekends || !isWeekend(current)) {\n67 +      events.push({\n68 +        id: `event_${eventId++}`,\n69 +        date: current,\n70 +        originalDate: formatDate(current),\n71 +      });\n72 +    }\n73 +\n74 +    switch (config.recurrence) {\n75 +      case 'daily':\n76 +        current = addDays(current, 1);\n77 +        break;\n78 +      case 'weekly':\n79 +        current = addDays(current, 7);\n80 +        break;\n81 +      case 'monthly':\n82 +        current = addMonths(current, 1);\n83 +        break;\n84 +      default:\n85 +        current = addDays(current, 1);\n86 +    }\n87 +  }\n88 +\n89 +  return events;\n90 +}\n91 +\n92 +export function getNextBusinessDay(date: Date): Date {\n93 +  let next = addDays(date, 1);\n94 +  while (isWeekend(next)) {\n95 +    next = addDays(next, 1);\n96 +  }\n97 +  return next;\n98 +}\n99 +\n100 +export function isSameDay(date1: Date, date2: Date): boolean {\n101 +  return (\n102 +    date1.getFullYear() === date2.getFullYear() &&\n103 +    date1.getMonth() === date2.getMonth() &&\n104 +    date1.getDate() === date2.getDate()\n105 +  );\n106 +}\n107 +\n108 +export function getDaysDifference(date1: Date, date2: Date): number {\n109 +  const diffTime = date2.getTime() - date1.getTime();\n110 +  return diffTime / (1000 * 60 * 60 * 24);\n111 +}\n112 +\n113 +export class DateScheduler {\n114 +  private config: ScheduleConfig;\n115 +\n116 +  constructor(config: ScheduleConfig) {\n117 +    this.config = config;\n118 +  }\n119 +\n120 +  generate(): ScheduledEvent[] {\n121 +    return generateSchedule(this.config);\n122 +  }\n123 +\n124 +  isValidDate(date: Date): boolean {\n125 +    const start = parseDate(this.config.startDate);\n126 +    const end = parseDate(this.config.endDate);\n127 +    return date >= start && date <= end;\n128 +  }\n129 +}\n130 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in packages/scheduling/src/utils/DateScheduler.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "events.push({\n        id: `event_${eventId++}`,\n        date: current,\n        originalDate: formatDate(current),\n      });", "improvedCode": "events.push({\n        id: `event_${eventId++}`,\n        date: new Date(current),\n        originalDate: formatDate(current),\n      });", "relevantFile": "packages/scheduling/src/utils/DateScheduler.ts", "relevantLinesEnd": 67, "suggestionContent": "The `generateSchedule` function pushes the same Date object reference into the events array instead of creating a new Date for each event. Since `current` is mutated in the loop, all events end up pointing to the same Date object, which will have the final value after the loop completes. All events will show the same date.", "oneSentenceSummary": "Same Date object reference pushed to array - all events have same final date", "relevantLinesStart": 63}, {"label": "bug", "language": "TypeScript", "existingCode": "export function getDaysDifference(date1: Date, date2: Date): number {\n  const diffTime = date2.getTime() - date1.getTime();\n  return diffTime / (1000 * 60 * 60 * 24);\n}", "improvedCode": "export function getDaysDifference(date1: Date, date2: Date): number {\n  // Use UTC to avoid DST issues\n  const utc1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());\n  const utc2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  return (utc2 - utc1) / (1000 * 60 * 60 * 24);\n}", "relevantFile": "packages/scheduling/src/utils/DateScheduler.ts", "relevantLinesEnd": 102, "suggestionContent": "The `getDaysDifference` function divides by milliseconds per day but doesn't account for daylight saving time transitions. When crossing DST boundaries, a 'day' might be 23 or 25 hours, causing the function to return incorrect fractional values (e.g., 0.958 instead of 1 for a single day across DST).", "oneSentenceSummary": "Days calculation doesn't handle DST - returns wrong value across timezone changes", "relevantLinesStart": 99}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/database/src/query/QueryBuilder.ts", "language": "TypeScript", "fileContent": "export type WhereOperator = '=' | '!=' | '>' | '<' | '>=' | '<=' | 'LIKE' | 'IN' | 'NOT IN';\nexport type OrderDirection = 'ASC' | 'DESC';\n\nexport interface WhereClause {\n  column: string;\n  operator: WhereOperator;\n  value: unknown;\n}\n\nexport interface OrderByClause {\n  column: string;\n  direction: OrderDirection;\n}\n\nexport interface JoinClause {\n  table: string;\n  type: 'INNER' | 'LEFT' | 'RIGHT';\n  on: string;\n}\n\nexport interface QueryResult<T> {\n  rows: T[];\n  rowCount: number;\n}\n\nexport class QueryBuilder<T = unknown> {\n  private tableName: string;\n  private selectColumns: string[] = ['*'];\n  private whereClauses: WhereClause[] = [];\n  private orderByClauses: OrderByClause[] = [];\n  private joinClauses: JoinClause[] = [];\n  private limitValue?: number;\n  private offsetValue?: number;\n  private params: unknown[] = [];\n\n  constructor(table: string) {\n    this.tableName = table;\n  }\n\n  select(...columns: string[]): this {\n    this.selectColumns = columns.length > 0 ? columns : ['*'];\n    return this;\n  }\n\n  where(column: string, operator: WhereOperator, value: unknown): this {\n    this.whereClauses.push({ column, operator, value });\n    return this;\n  }\n\n  whereEquals(column: string, value: unknown): this {\n    return this.where(column, '=', value);\n  }\n\n  whereLike(column: string, pattern: string): this {\n    return this.where(column, 'LIKE', pattern);\n  }\n\n  whereIn(column: string, values: unknown[]): this {\n    return this.where(column, 'IN', values);\n  }\n\n  orderBy(column: string, direction: OrderDirection = 'ASC'): this {\n    this.orderByClauses.push({ column, direction });\n    return this;\n  }\n\n  join(table: string, on: string, type: 'INNER' | 'LEFT' | 'RIGHT' = 'INNER'): this {\n    this.joinClauses.push({ table, type, on });\n    return this;\n  }\n\n  limit(count: number): this {\n    this.limitValue = count;\n    return this;\n  }\n\n  offset(count: number): this {\n    this.offsetValue = count;\n    return this;\n  }\n\n  buildSelect(): { sql: string; params: unknown[] } {\n    this.params = [];\n    let sql = `SELECT ${this.selectColumns.join(', ')} FROM ${this.tableName}`;\n\n    for (const join of this.joinClauses) {\n      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\n    }\n\n    if (this.whereClauses.length > 0) {\n      const conditions = this.whereClauses.map(clause => {\n        if (clause.operator === 'IN' || clause.operator === 'NOT IN') {\n          const values = clause.value as unknown[];\n          const placeholders = values.map(() => '?').join(', ');\n          this.params.push(...values);\n          return `${clause.column} ${clause.operator} (${placeholders})`;\n        }\n        this.params.push(clause.value);\n        return `${clause.column} ${clause.operator} ?`;\n      });\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    if (this.orderByClauses.length > 0) {\n      const orders = this.orderByClauses.map(\n        clause => `${clause.column} ${clause.direction}`\n      );\n      sql += ` ORDER BY ${orders.join(', ')}`;\n    }\n\n    if (this.limitValue !== undefined) {\n      sql += ` LIMIT ${this.limitValue}`;\n    }\n\n    if (this.offsetValue !== undefined) {\n      sql += ` OFFSET ${this.offsetValue}`;\n    }\n\n    return { sql, params: this.params };\n  }\n\n  buildInsert(data: Partial<T>): { sql: string; params: unknown[] } {\n    const columns = Object.keys(data);\n    const values = Object.values(data);\n    const placeholders = columns.map(() => '?').join(', ');\n\n    const sql = `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`;\n\n    return { sql, params: values };\n  }\n\n  buildUpdate(data: Partial<T>): { sql: string; params: unknown[] } {\n    this.params = [];\n    const setClauses = Object.entries(data).map(([column, value]) => {\n      this.params.push(value);\n      return `${column} = ?`;\n    });\n\n    let sql = `UPDATE ${this.tableName} SET ${setClauses.join(', ')}`;\n\n    if (this.whereClauses.length > 0) {\n      const conditions = this.whereClauses.map(clause => {\n        this.params.push(clause.value);\n        return `${clause.column} ${clause.operator} ?`;\n      });\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    return { sql, params: this.params };\n  }\n\n  buildDelete(): { sql: string; params: unknown[] } {\n    this.params = [];\n    let sql = `DELETE FROM ${this.tableName}`;\n\n    if (this.whereClauses.length > 0) {\n      const conditions = this.whereClauses.map(clause => {\n        this.params.push(clause.value);\n        return `${clause.column} ${clause.operator} ?`;\n      });\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    return { sql, params: this.params };\n  }\n\n  reset(): this {\n    this.selectColumns = ['*'];\n    this.whereClauses = [];\n    this.orderByClauses = [];\n    this.joinClauses = [];\n    this.limitValue = undefined;\n    this.offsetValue = undefined;\n    this.params = [];\n    return this;\n  }\n}\n\nexport function query<T>(table: string): QueryBuilder<T> {\n  return new QueryBuilder<T>(table);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/database/src/query/QueryBuilder.ts'\n\n@@ -0,0 +1,182 @@\n__new hunk__\n1 +export type WhereOperator = '=' | '!=' | '>' | '<' | '>=' | '<=' | 'LIKE' | 'IN' | 'NOT IN';\n2 +export type OrderDirection = 'ASC' | 'DESC';\n3 +\n4 +export interface WhereClause {\n5 +  column: string;\n6 +  operator: WhereOperator;\n7 +  value: unknown;\n8 +}\n9 +\n10 +export interface OrderByClause {\n11 +  column: string;\n12 +  direction: OrderDirection;\n13 +}\n14 +\n15 +export interface JoinClause {\n16 +  table: string;\n17 +  type: 'INNER' | 'LEFT' | 'RIGHT';\n18 +  on: string;\n19 +}\n20 +\n21 +export interface QueryResult<T> {\n22 +  rows: T[];\n23 +  rowCount: number;\n24 +}\n25 +\n26 +export class QueryBuilder<T = unknown> {\n27 +  private tableName: string;\n28 +  private selectColumns: string[] = ['*'];\n29 +  private whereClauses: WhereClause[] = [];\n30 +  private orderByClauses: OrderByClause[] = [];\n31 +  private joinClauses: JoinClause[] = [];\n32 +  private limitValue?: number;\n33 +  private offsetValue?: number;\n34 +  private params: unknown[] = [];\n35 +\n36 +  constructor(table: string) {\n37 +    this.tableName = table;\n38 +  }\n39 +\n40 +  select(...columns: string[]): this {\n41 +    this.selectColumns = columns.length > 0 ? columns : ['*'];\n42 +    return this;\n43 +  }\n44 +\n45 +  where(column: string, operator: WhereOperator, value: unknown): this {\n46 +    this.whereClauses.push({ column, operator, value });\n47 +    return this;\n48 +  }\n49 +\n50 +  whereEquals(column: string, value: unknown): this {\n51 +    return this.where(column, '=', value);\n52 +  }\n53 +\n54 +  whereLike(column: string, pattern: string): this {\n55 +    return this.where(column, 'LIKE', pattern);\n56 +  }\n57 +\n58 +  whereIn(column: string, values: unknown[]): this {\n59 +    return this.where(column, 'IN', values);\n60 +  }\n61 +\n62 +  orderBy(column: string, direction: OrderDirection = 'ASC'): this {\n63 +    this.orderByClauses.push({ column, direction });\n64 +    return this;\n65 +  }\n66 +\n67 +  join(table: string, on: string, type: 'INNER' | 'LEFT' | 'RIGHT' = 'INNER'): this {\n68 +    this.joinClauses.push({ table, type, on });\n69 +    return this;\n70 +  }\n71 +\n72 +  limit(count: number): this {\n73 +    this.limitValue = count;\n74 +    return this;\n75 +  }\n76 +\n77 +  offset(count: number): this {\n78 +    this.offsetValue = count;\n79 +    return this;\n80 +  }\n81 +\n82 +  buildSelect(): { sql: string; params: unknown[] } {\n83 +    this.params = [];\n84 +    let sql = `SELECT ${this.selectColumns.join(', ')} FROM ${this.tableName}`;\n85 +\n86 +    for (const join of this.joinClauses) {\n87 +      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\n88 +    }\n89 +\n90 +    if (this.whereClauses.length > 0) {\n91 +      const conditions = this.whereClauses.map(clause => {\n92 +        if (clause.operator === 'IN' || clause.operator === 'NOT IN') {\n93 +          const values = clause.value as unknown[];\n94 +          const placeholders = values.map(() => '?').join(', ');\n95 +          this.params.push(...values);\n96 +          return `${clause.column} ${clause.operator} (${placeholders})`;\n97 +        }\n98 +        this.params.push(clause.value);\n99 +        return `${clause.column} ${clause.operator} ?`;\n100 +      });\n101 +      sql += ` WHERE ${conditions.join(' AND ')}`;\n102 +    }\n103 +\n104 +    if (this.orderByClauses.length > 0) {\n105 +      const orders = this.orderByClauses.map(\n106 +        clause => `${clause.column} ${clause.direction}`\n107 +      );\n108 +      sql += ` ORDER BY ${orders.join(', ')}`;\n109 +    }\n110 +\n111 +    if (this.limitValue !== undefined) {\n112 +      sql += ` LIMIT ${this.limitValue}`;\n113 +    }\n114 +\n115 +    if (this.offsetValue !== undefined) {\n116 +      sql += ` OFFSET ${this.offsetValue}`;\n117 +    }\n118 +\n119 +    return { sql, params: this.params };\n120 +  }\n121 +\n122 +  buildInsert(data: Partial<T>): { sql: string; params: unknown[] } {\n123 +    const columns = Object.keys(data);\n124 +    const values = Object.values(data);\n125 +    const placeholders = columns.map(() => '?').join(', ');\n126 +\n127 +    const sql = `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`;\n128 +\n129 +    return { sql, params: values };\n130 +  }\n131 +\n132 +  buildUpdate(data: Partial<T>): { sql: string; params: unknown[] } {\n133 +    this.params = [];\n134 +    const setClauses = Object.entries(data).map(([column, value]) => {\n135 +      this.params.push(value);\n136 +      return `${column} = ?`;\n137 +    });\n138 +\n139 +    let sql = `UPDATE ${this.tableName} SET ${setClauses.join(', ')}`;\n140 +\n141 +    if (this.whereClauses.length > 0) {\n142 +      const conditions = this.whereClauses.map(clause => {\n143 +        this.params.push(clause.value);\n144 +        return `${clause.column} ${clause.operator} ?`;\n145 +      });\n146 +      sql += ` WHERE ${conditions.join(' AND ')}`;\n147 +    }\n148 +\n149 +    return { sql, params: this.params };\n150 +  }\n151 +\n152 +  buildDelete(): { sql: string; params: unknown[] } {\n153 +    this.params = [];\n154 +    let sql = `DELETE FROM ${this.tableName}`;\n155 +\n156 +    if (this.whereClauses.length > 0) {\n157 +      const conditions = this.whereClauses.map(clause => {\n158 +        this.params.push(clause.value);\n159 +        return `${clause.column} ${clause.operator} ?`;\n160 +      });\n161 +      sql += ` WHERE ${conditions.join(' AND ')}`;\n162 +    }\n163 +\n164 +    return { sql, params: this.params };\n165 +  }\n166 +\n167 +  reset(): this {\n168 +    this.selectColumns = ['*'];\n169 +    this.whereClauses = [];\n170 +    this.orderByClauses = [];\n171 +    this.joinClauses = [];\n172 +    this.limitValue = undefined;\n173 +    this.offsetValue = undefined;\n174 +    this.params = [];\n175 +    return this;\n176 +  }\n177 +}\n178 +\n179 +export function query<T>(table: string): QueryBuilder<T> {\n180 +  return new QueryBuilder<T>(table);\n181 +}\n182 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in packages/database/src/query/QueryBuilder.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "let sql = `SELECT ${this.selectColumns.join(', ')} FROM ${this.tableName}`;", "improvedCode": "const safeColumns = this.selectColumns.map(col => {\n      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(col) && col !== '*') {\n        throw new Error(`Invalid column name: ${col}`);\n      }\n      return col;\n    });\n    let sql = `SELECT ${safeColumns.join(', ')} FROM ${this.tableName}`;", "relevantFile": "packages/database/src/query/QueryBuilder.ts", "relevantLinesEnd": 76, "suggestionContent": "The `buildSelect` method directly interpolates `this.selectColumns` into the SQL query without sanitization. If column names come from user input, an attacker can inject SQL like `*; DROP TABLE users; --`. Column names should be validated against an allowlist or properly escaped.", "oneSentenceSummary": "SQL injection via column names - user input interpolated without sanitization", "relevantLinesStart": 76}, {"label": "bug", "language": "TypeScript", "existingCode": "if (this.orderByClauses.length > 0) {\n      const orders = this.orderByClauses.map(\n        clause => `${clause.column} ${clause.direction}`\n      );\n      sql += ` ORDER BY ${orders.join(', ')}`;\n    }", "improvedCode": "if (this.orderByClauses.length > 0) {\n      const orders = this.orderByClauses.map(clause => {\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(clause.column)) {\n          throw new Error(`Invalid column name: ${clause.column}`);\n        }\n        return `${clause.column} ${clause.direction}`;\n      });\n      sql += ` ORDER BY ${orders.join(', ')}`;\n    }", "relevantFile": "packages/database/src/query/QueryBuilder.ts", "relevantLinesEnd": 100, "suggestionContent": "The `orderBy` clause uses `clause.column` and `clause.direction` directly in string interpolation. While direction is constrained by the type, column is not validated. An attacker can inject SQL via the column parameter like `id; DROP TABLE users; --`.", "oneSentenceSummary": "SQL injection in ORDER BY clause - column name not validated", "relevantLinesStart": 95}, {"label": "bug", "language": "TypeScript", "existingCode": "for (const join of this.joinClauses) {\n      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\n    }", "improvedCode": "for (const join of this.joinClauses) {\n      // Validate table name\n      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(join.table)) {\n        throw new Error(`Invalid table name: ${join.table}`);\n      }\n      // ON clause should use parameterized format or be validated\n      if (!/^[a-zA-Z_][a-zA-Z0-9_.]+\\s*=\\s*[a-zA-Z_][a-zA-Z0-9_.]+$/.test(join.on)) {\n        throw new Error(`Invalid join condition: ${join.on}`);\n      }\n      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\n    }", "relevantFile": "packages/database/src/query/QueryBuilder.ts", "relevantLinesEnd": 80, "suggestionContent": "The `join` method takes an `on` parameter that is directly interpolated into the SQL query. This allows SQL injection via the join condition, e.g., `users.id = posts.user_id; DROP TABLE users; --`.", "oneSentenceSummary": "SQL injection in JOIN clause - on condition not sanitized", "relevantLinesStart": 78}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/security/src/middleware/RateLimiter.ts", "language": "TypeScript", "fileContent": "export interface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  keyGenerator?: (req: Request) => string;\n  onLimitReached?: (key: string) => void;\n  skipFailedRequests?: boolean;\n}\n\ninterface RateLimitEntry {\n  count: number;\n  resetTime: number;\n}\n\ninterface Request {\n  ip: string;\n  headers: Record<string, string>;\n  path: string;\n}\n\ninterface Response {\n  status: (code: number) => Response;\n  json: (data: unknown) => void;\n  setHeader: (name: string, value: string) => void;\n}\n\ntype NextFunction = () => void;\n\nconst DEFAULT_CONFIG: RateLimitConfig = {\n  windowMs: 60000,\n  maxRequests: 100,\n};\n\nexport class RateLimiter {\n  private config: RateLimitConfig;\n  private store: Map<string, RateLimitEntry> = new Map();\n  private cleanupInterval: NodeJS.Timeout;\n\n  constructor(config: Partial<RateLimitConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.cleanupInterval = setInterval(() => this.cleanup(), this.config.windowMs);\n  }\n\n  private getKey(req: Request): string {\n    if (this.config.keyGenerator) {\n      return this.config.keyGenerator(req);\n    }\n    return req.headers['x-forwarded-for'] || req.ip;\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.store) {\n      if (now > entry.resetTime) {\n        this.store.delete(key);\n      }\n    }\n  }\n\n  isRateLimited(req: Request): { limited: boolean; remaining: number; resetTime: number } {\n    const key = this.getKey(req);\n    const now = Date.now();\n\n    let entry = this.store.get(key);\n\n    if (!entry || now > entry.resetTime) {\n      entry = {\n        count: 0,\n        resetTime: now + this.config.windowMs,\n      };\n      this.store.set(key, entry);\n    }\n\n    entry.count++;\n\n    const remaining = Math.max(0, this.config.maxRequests - entry.count);\n    const limited = entry.count > this.config.maxRequests;\n\n    if (limited && this.config.onLimitReached) {\n      this.config.onLimitReached(key);\n    }\n\n    return { limited, remaining, resetTime: entry.resetTime };\n  }\n\n  middleware() {\n    return (req: Request, res: Response, next: NextFunction) => {\n      const { limited, remaining, resetTime } = this.isRateLimited(req);\n\n      res.setHeader('X-RateLimit-Limit', String(this.config.maxRequests));\n      res.setHeader('X-RateLimit-Remaining', String(remaining));\n      res.setHeader('X-RateLimit-Reset', String(Math.ceil(resetTime / 1000)));\n\n      if (limited) {\n        res.status(429).json({\n          error: 'Too many requests',\n          retryAfter: Math.ceil((resetTime - Date.now()) / 1000),\n        });\n        return;\n      }\n\n      next();\n    };\n  }\n\n  reset(key: string): void {\n    this.store.delete(key);\n  }\n\n  resetAll(): void {\n    this.store.clear();\n  }\n\n  getStats(): { totalKeys: number; totalRequests: number } {\n    let totalRequests = 0;\n    for (const entry of this.store.values()) {\n      totalRequests += entry.count;\n    }\n    return {\n      totalKeys: this.store.size,\n      totalRequests,\n    };\n  }\n\n  destroy(): void {\n    clearInterval(this.cleanupInterval);\n    this.store.clear();\n  }\n}\n\nexport function createRateLimiter(config?: Partial<RateLimitConfig>): RateLimiter {\n  return new RateLimiter(config);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/security/src/middleware/RateLimiter.ts'\n\n@@ -0,0 +1,133 @@\n__new hunk__\n1 +export interface RateLimitConfig {\n2 +  windowMs: number;\n3 +  maxRequests: number;\n4 +  keyGenerator?: (req: Request) => string;\n5 +  onLimitReached?: (key: string) => void;\n6 +  skipFailedRequests?: boolean;\n7 +}\n8 +\n9 +interface RateLimitEntry {\n10 +  count: number;\n11 +  resetTime: number;\n12 +}\n13 +\n14 +interface Request {\n15 +  ip: string;\n16 +  headers: Record<string, string>;\n17 +  path: string;\n18 +}\n19 +\n20 +interface Response {\n21 +  status: (code: number) => Response;\n22 +  json: (data: unknown) => void;\n23 +  setHeader: (name: string, value: string) => void;\n24 +}\n25 +\n26 +type NextFunction = () => void;\n27 +\n28 +const DEFAULT_CONFIG: RateLimitConfig = {\n29 +  windowMs: 60000,\n30 +  maxRequests: 100,\n31 +};\n32 +\n33 +export class RateLimiter {\n34 +  private config: RateLimitConfig;\n35 +  private store: Map<string, RateLimitEntry> = new Map();\n36 +  private cleanupInterval: NodeJS.Timeout;\n37 +\n38 +  constructor(config: Partial<RateLimitConfig> = {}) {\n39 +    this.config = { ...DEFAULT_CONFIG, ...config };\n40 +    this.cleanupInterval = setInterval(() => this.cleanup(), this.config.windowMs);\n41 +  }\n42 +\n43 +  private getKey(req: Request): string {\n44 +    if (this.config.keyGenerator) {\n45 +      return this.config.keyGenerator(req);\n46 +    }\n47 +    return req.headers['x-forwarded-for'] || req.ip;\n48 +  }\n49 +\n50 +  private cleanup(): void {\n51 +    const now = Date.now();\n52 +    for (const [key, entry] of this.store) {\n53 +      if (now > entry.resetTime) {\n54 +        this.store.delete(key);\n55 +      }\n56 +    }\n57 +  }\n58 +\n59 +  isRateLimited(req: Request): { limited: boolean; remaining: number; resetTime: number } {\n60 +    const key = this.getKey(req);\n61 +    const now = Date.now();\n62 +\n63 +    let entry = this.store.get(key);\n64 +\n65 +    if (!entry || now > entry.resetTime) {\n66 +      entry = {\n67 +        count: 0,\n68 +        resetTime: now + this.config.windowMs,\n69 +      };\n70 +      this.store.set(key, entry);\n71 +    }\n72 +\n73 +    entry.count++;\n74 +\n75 +    const remaining = Math.max(0, this.config.maxRequests - entry.count);\n76 +    const limited = entry.count > this.config.maxRequests;\n77 +\n78 +    if (limited && this.config.onLimitReached) {\n79 +      this.config.onLimitReached(key);\n80 +    }\n81 +\n82 +    return { limited, remaining, resetTime: entry.resetTime };\n83 +  }\n84 +\n85 +  middleware() {\n86 +    return (req: Request, res: Response, next: NextFunction) => {\n87 +      const { limited, remaining, resetTime } = this.isRateLimited(req);\n88 +\n89 +      res.setHeader('X-RateLimit-Limit', String(this.config.maxRequests));\n90 +      res.setHeader('X-RateLimit-Remaining', String(remaining));\n91 +      res.setHeader('X-RateLimit-Reset', String(Math.ceil(resetTime / 1000)));\n92 +\n93 +      if (limited) {\n94 +        res.status(429).json({\n95 +          error: 'Too many requests',\n96 +          retryAfter: Math.ceil((resetTime - Date.now()) / 1000),\n97 +        });\n98 +        return;\n99 +      }\n100 +\n101 +      next();\n102 +    };\n103 +  }\n104 +\n105 +  reset(key: string): void {\n106 +    this.store.delete(key);\n107 +  }\n108 +\n109 +  resetAll(): void {\n110 +    this.store.clear();\n111 +  }\n112 +\n113 +  getStats(): { totalKeys: number; totalRequests: number } {\n114 +    let totalRequests = 0;\n115 +    for (const entry of this.store.values()) {\n116 +      totalRequests += entry.count;\n117 +    }\n118 +    return {\n119 +      totalKeys: this.store.size,\n120 +      totalRequests,\n121 +    };\n122 +  }\n123 +\n124 +  destroy(): void {\n125 +    clearInterval(this.cleanupInterval);\n126 +    this.store.clear();\n127 +  }\n128 +}\n129 +\n130 +export function createRateLimiter(config?: Partial<RateLimitConfig>): RateLimiter {\n131 +  return new RateLimiter(config);\n132 +}\n133 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/security/src/middleware/RateLimiter.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "let entry = this.store.get(key);\n\n    if (!entry || now > entry.resetTime) {\n      entry = {\n        count: 0,\n        resetTime: now + this.config.windowMs,\n      };\n      this.store.set(key, entry);\n    }\n\n    entry.count++;", "improvedCode": "// Use atomic check-and-increment pattern\n    let entry = this.store.get(key);\n    const needsReset = !entry || now > entry.resetTime;\n    \n    if (needsReset) {\n      entry = {\n        count: 1,  // Start at 1, not 0 then increment\n        resetTime: now + this.config.windowMs,\n      };\n      this.store.set(key, entry);\n    } else {\n      entry.count++;\n    }", "relevantFile": "packages/security/src/middleware/RateLimiter.ts", "relevantLinesEnd": 67, "suggestionContent": "The `isRateLimited` method has a race condition. Between checking if the entry exists and incrementing the count, another concurrent request could create or modify the entry. In a high-concurrency environment (or when using clustering), this allows more requests than the limit because multiple requests can pass the check before any of them increment the counter. Use atomic operations or a mutex for thread-safe rate limiting.", "oneSentenceSummary": "Race condition in rate limiting - concurrent requests can bypass limit", "relevantLinesStart": 57}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/state/src/reducers/cartReducer.ts", "language": "TypeScript", "fileContent": "export interface CartItem {\n  productId: string;\n  name: string;\n  price: number;\n  quantity: number;\n  options?: Record<string, string>;\n}\n\nexport interface CartState {\n  items: CartItem[];\n  couponCode: string | null;\n  discountPercent: number;\n  lastUpdated: number;\n}\n\nexport type CartAction =\n  | { type: 'ADD_ITEM'; payload: CartItem }\n  | { type: 'REMOVE_ITEM'; payload: { productId: string } }\n  | { type: 'UPDATE_QUANTITY'; payload: { productId: string; quantity: number } }\n  | { type: 'APPLY_COUPON'; payload: { code: string; discount: number } }\n  | { type: 'CLEAR_CART' }\n  | { type: 'RESTORE_CART'; payload: CartState };\n\nexport const initialCartState: CartState = {\n  items: [],\n  couponCode: null,\n  discountPercent: 0,\n  lastUpdated: Date.now(),\n};\n\nfunction findItemIndex(items: CartItem[], productId: string): number {\n  return items.findIndex(item => item.productId === productId);\n}\n\nexport function cartReducer(\n  state: CartState = initialCartState,\n  action: CartAction\n): CartState {\n  switch (action.type) {\n    case 'ADD_ITEM': {\n      const existingIndex = findItemIndex(state.items, action.payload.productId);\n\n      if (existingIndex >= 0) {\n        const updatedItems = [...state.items];\n        updatedItems[existingIndex].quantity += action.payload.quantity;\n        return {\n          ...state,\n          items: updatedItems,\n          lastUpdated: Date.now(),\n        };\n      }\n\n      return {\n        ...state,\n        items: [...state.items, action.payload],\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'REMOVE_ITEM': {\n      return {\n        ...state,\n        items: state.items.filter(\n          item => item.productId !== action.payload.productId\n        ),\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'UPDATE_QUANTITY': {\n      const index = findItemIndex(state.items, action.payload.productId);\n      if (index < 0) return state;\n\n      if (action.payload.quantity <= 0) {\n        return cartReducer(state, {\n          type: 'REMOVE_ITEM',\n          payload: { productId: action.payload.productId },\n        });\n      }\n\n      const updatedItems = [...state.items];\n      updatedItems[index].quantity = action.payload.quantity;\n      return {\n        ...state,\n        items: updatedItems,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'APPLY_COUPON': {\n      return {\n        ...state,\n        couponCode: action.payload.code,\n        discountPercent: action.payload.discount,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'CLEAR_CART': {\n      return {\n        ...initialCartState,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'RESTORE_CART': {\n      return {\n        ...action.payload,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n\nexport function selectCartTotal(state: CartState): number {\n  const subtotal = state.items.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n  return subtotal * (1 - state.discountPercent / 100);\n}\n\nexport function selectItemCount(state: CartState): number {\n  return state.items.reduce((sum, item) => sum + item.quantity, 0);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/state/src/reducers/cartReducer.ts'\n\n@@ -0,0 +1,129 @@\n__new hunk__\n1 +export interface CartItem {\n2 +  productId: string;\n3 +  name: string;\n4 +  price: number;\n5 +  quantity: number;\n6 +  options?: Record<string, string>;\n7 +}\n8 +\n9 +export interface CartState {\n10 +  items: CartItem[];\n11 +  couponCode: string | null;\n12 +  discountPercent: number;\n13 +  lastUpdated: number;\n14 +}\n15 +\n16 +export type CartAction =\n17 +  | { type: 'ADD_ITEM'; payload: CartItem }\n18 +  | { type: 'REMOVE_ITEM'; payload: { productId: string } }\n19 +  | { type: 'UPDATE_QUANTITY'; payload: { productId: string; quantity: number } }\n20 +  | { type: 'APPLY_COUPON'; payload: { code: string; discount: number } }\n21 +  | { type: 'CLEAR_CART' }\n22 +  | { type: 'RESTORE_CART'; payload: CartState };\n23 +\n24 +export const initialCartState: CartState = {\n25 +  items: [],\n26 +  couponCode: null,\n27 +  discountPercent: 0,\n28 +  lastUpdated: Date.now(),\n29 +};\n30 +\n31 +function findItemIndex(items: CartItem[], productId: string): number {\n32 +  return items.findIndex(item => item.productId === productId);\n33 +}\n34 +\n35 +export function cartReducer(\n36 +  state: CartState = initialCartState,\n37 +  action: CartAction\n38 +): CartState {\n39 +  switch (action.type) {\n40 +    case 'ADD_ITEM': {\n41 +      const existingIndex = findItemIndex(state.items, action.payload.productId);\n42 +\n43 +      if (existingIndex >= 0) {\n44 +        const updatedItems = [...state.items];\n45 +        updatedItems[existingIndex].quantity += action.payload.quantity;\n46 +        return {\n47 +          ...state,\n48 +          items: updatedItems,\n49 +          lastUpdated: Date.now(),\n50 +        };\n51 +      }\n52 +\n53 +      return {\n54 +        ...state,\n55 +        items: [...state.items, action.payload],\n56 +        lastUpdated: Date.now(),\n57 +      };\n58 +    }\n59 +\n60 +    case 'REMOVE_ITEM': {\n61 +      return {\n62 +        ...state,\n63 +        items: state.items.filter(\n64 +          item => item.productId !== action.payload.productId\n65 +        ),\n66 +        lastUpdated: Date.now(),\n67 +      };\n68 +    }\n69 +\n70 +    case 'UPDATE_QUANTITY': {\n71 +      const index = findItemIndex(state.items, action.payload.productId);\n72 +      if (index < 0) return state;\n73 +\n74 +      if (action.payload.quantity <= 0) {\n75 +        return cartReducer(state, {\n76 +          type: 'REMOVE_ITEM',\n77 +          payload: { productId: action.payload.productId },\n78 +        });\n79 +      }\n80 +\n81 +      const updatedItems = [...state.items];\n82 +      updatedItems[index].quantity = action.payload.quantity;\n83 +      return {\n84 +        ...state,\n85 +        items: updatedItems,\n86 +        lastUpdated: Date.now(),\n87 +      };\n88 +    }\n89 +\n90 +    case 'APPLY_COUPON': {\n91 +      return {\n92 +        ...state,\n93 +        couponCode: action.payload.code,\n94 +        discountPercent: action.payload.discount,\n95 +        lastUpdated: Date.now(),\n96 +      };\n97 +    }\n98 +\n99 +    case 'CLEAR_CART': {\n100 +      return {\n101 +        ...initialCartState,\n102 +        lastUpdated: Date.now(),\n103 +      };\n104 +    }\n105 +\n106 +    case 'RESTORE_CART': {\n107 +      return {\n108 +        ...action.payload,\n109 +        lastUpdated: Date.now(),\n110 +      };\n111 +    }\n112 +\n113 +    default:\n114 +      return state;\n115 +  }\n116 +}\n117 +\n118 +export function selectCartTotal(state: CartState): number {\n119 +  const subtotal = state.items.reduce(\n120 +    (sum, item) => sum + item.price * item.quantity,\n121 +    0\n122 +  );\n123 +  return subtotal * (1 - state.discountPercent / 100);\n124 +}\n125 +\n126 +export function selectItemCount(state: CartState): number {\n127 +  return state.items.reduce((sum, item) => sum + item.quantity, 0);\n128 +}\n129 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/state/src/reducers/cartReducer.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "const updatedItems = [...state.items];\n        updatedItems[existingIndex].quantity += action.payload.quantity;", "improvedCode": "const updatedItems = state.items.map((item, index) =>\n          index === existingIndex\n            ? { ...item, quantity: item.quantity + action.payload.quantity }\n            : item\n        );", "relevantFile": "packages/state/src/reducers/cartReducer.ts", "relevantLinesEnd": 44, "suggestionContent": "In the 'ADD_ITEM' and 'UPDATE_QUANTITY' cases, the code creates a shallow copy of the items array with `[...state.items]`, but then mutates the object at `updatedItems[index]` directly. Since array spread only creates a shallow copy, `updatedItems[existingIndex]` still references the same object as `state.items[existingIndex]`. This mutates the original state, breaking Redux/reducer immutability principles and causing issues with change detection, memoization, and time-travel debugging.", "oneSentenceSummary": "Shallow array copy followed by object mutation breaks reducer immutability", "relevantLinesStart": 43}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/state/src/store/StateManager.ts", "language": "TypeScript", "fileContent": "export type StateListener<T> = (state: T, prevState: T) => void;\nexport type StateSelector<T, R> = (state: T) => R;\nexport type StateUpdater<T> = (state: T) => Partial<T>;\n\nexport interface StateManagerOptions<T> {\n  initialState: T;\n  persist?: boolean;\n  storageKey?: string;\n  middleware?: Array<(state: T, action: string) => T>;\n}\n\nexport interface StateSnapshot<T> {\n  state: T;\n  timestamp: number;\n  action: string;\n}\n\nfunction deepMerge<T extends object>(target: T, source: Partial<T>): T {\n  const result = { ...target };\n\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      const sourceValue = source[key];\n      const targetValue = target[key];\n\n      if (\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        targetValue !== null &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue)\n      ) {\n        (result as any)[key] = deepMerge(targetValue as object, sourceValue as object);\n      } else {\n        (result as any)[key] = sourceValue;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepClone(item)) as unknown as T;\n  }\n\n  const cloned = {} as T;\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      (cloned as any)[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n\nexport class StateManager<T extends object> {\n  private state: T;\n  private listeners: Set<StateListener<T>> = new Set();\n  private history: StateSnapshot<T>[] = [];\n  private maxHistoryLength = 50;\n  private options: StateManagerOptions<T>;\n\n  constructor(options: StateManagerOptions<T>) {\n    this.options = options;\n    this.state = this.loadPersistedState() || deepClone(options.initialState);\n    this.saveSnapshot('init');\n  }\n\n  private loadPersistedState(): T | null {\n    if (!this.options.persist || !this.options.storageKey) {\n      return null;\n    }\n\n    try {\n      const stored = localStorage.getItem(this.options.storageKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n    } catch (error) {\n      console.warn('Failed to load persisted state:', error);\n    }\n\n    return null;\n  }\n\n  private persistState(): void {\n    if (!this.options.persist || !this.options.storageKey) {\n      return;\n    }\n\n    try {\n      localStorage.setItem(this.options.storageKey, JSON.stringify(this.state));\n    } catch (error) {\n      console.warn('Failed to persist state:', error);\n    }\n  }\n\n  private saveSnapshot(action: string): void {\n    this.history.push({\n      state: deepClone(this.state),\n      timestamp: Date.now(),\n      action,\n    });\n\n    if (this.history.length > this.maxHistoryLength) {\n      this.history.shift();\n    }\n  }\n\n  private notifyListeners(prevState: T): void {\n    this.listeners.forEach(listener => {\n      listener(this.state, prevState);\n    });\n  }\n\n  getState(): T {\n    return this.state;\n  }\n\n  setState(updater: StateUpdater<T> | Partial<T>, action = 'setState'): void {\n    const prevState = this.state;\n    const updates = typeof updater === 'function' ? updater(this.state) : updater;\n\n    this.state = deepMerge(this.state, updates);\n\n    if (this.options.middleware) {\n      for (const mw of this.options.middleware) {\n        this.state = mw(this.state, action);\n      }\n    }\n\n    this.saveSnapshot(action);\n    this.persistState();\n    this.notifyListeners(prevState);\n  }\n\n  subscribe(listener: StateListener<T>): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  select<R>(selector: StateSelector<T, R>): R {\n    return selector(this.state);\n  }\n\n  undo(): boolean {\n    if (this.history.length < 2) {\n      return false;\n    }\n\n    this.history.pop(); // Remove current state\n    const previousSnapshot = this.history[this.history.length - 1];\n\n    if (previousSnapshot) {\n      const prevState = this.state;\n      this.state = deepClone(previousSnapshot.state);\n      this.persistState();\n      this.notifyListeners(prevState);\n      return true;\n    }\n\n    return false;\n  }\n\n  getHistory(): StateSnapshot<T>[] {\n    return [...this.history];\n  }\n\n  importState(serialized: string): void {\n    const imported = JSON.parse(serialized);\n    this.setState(imported, 'import');\n  }\n\n  exportState(): string {\n    return JSON.stringify(this.state);\n  }\n\n  reset(): void {\n    const prevState = this.state;\n    this.state = deepClone(this.options.initialState);\n    this.history = [];\n    this.saveSnapshot('reset');\n    this.persistState();\n    this.notifyListeners(prevState);\n  }\n}\n\nexport function createStateManager<T extends object>(\n  options: StateManagerOptions<T>\n): StateManager<T> {\n  return new StateManager(options);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/state/src/store/StateManager.ts'\n\n@@ -0,0 +1,199 @@\n__new hunk__\n1 +export type StateListener<T> = (state: T, prevState: T) => void;\n2 +export type StateSelector<T, R> = (state: T) => R;\n3 +export type StateUpdater<T> = (state: T) => Partial<T>;\n4 +\n5 +export interface StateManagerOptions<T> {\n6 +  initialState: T;\n7 +  persist?: boolean;\n8 +  storageKey?: string;\n9 +  middleware?: Array<(state: T, action: string) => T>;\n10 +}\n11 +\n12 +export interface StateSnapshot<T> {\n13 +  state: T;\n14 +  timestamp: number;\n15 +  action: string;\n16 +}\n17 +\n18 +function deepMerge<T extends object>(target: T, source: Partial<T>): T {\n19 +  const result = { ...target };\n20 +\n21 +  for (const key in source) {\n22 +    if (source.hasOwnProperty(key)) {\n23 +      const sourceValue = source[key];\n24 +      const targetValue = target[key];\n25 +\n26 +      if (\n27 +        sourceValue !== null &&\n28 +        typeof sourceValue === 'object' &&\n29 +        !Array.isArray(sourceValue) &&\n30 +        targetValue !== null &&\n31 +        typeof targetValue === 'object' &&\n32 +        !Array.isArray(targetValue)\n33 +      ) {\n34 +        (result as any)[key] = deepMerge(targetValue as object, sourceValue as object);\n35 +      } else {\n36 +        (result as any)[key] = sourceValue;\n37 +      }\n38 +    }\n39 +  }\n40 +\n41 +  return result;\n42 +}\n43 +\n44 +function deepClone<T>(obj: T): T {\n45 +  if (obj === null || typeof obj !== 'object') {\n46 +    return obj;\n47 +  }\n48 +\n49 +  if (Array.isArray(obj)) {\n50 +    return obj.map(item => deepClone(item)) as unknown as T;\n51 +  }\n52 +\n53 +  const cloned = {} as T;\n54 +  for (const key in obj) {\n55 +    if (obj.hasOwnProperty(key)) {\n56 +      (cloned as any)[key] = deepClone(obj[key]);\n57 +    }\n58 +  }\n59 +  return cloned;\n60 +}\n61 +\n62 +export class StateManager<T extends object> {\n63 +  private state: T;\n64 +  private listeners: Set<StateListener<T>> = new Set();\n65 +  private history: StateSnapshot<T>[] = [];\n66 +  private maxHistoryLength = 50;\n67 +  private options: StateManagerOptions<T>;\n68 +\n69 +  constructor(options: StateManagerOptions<T>) {\n70 +    this.options = options;\n71 +    this.state = this.loadPersistedState() || deepClone(options.initialState);\n72 +    this.saveSnapshot('init');\n73 +  }\n74 +\n75 +  private loadPersistedState(): T | null {\n76 +    if (!this.options.persist || !this.options.storageKey) {\n77 +      return null;\n78 +    }\n79 +\n80 +    try {\n81 +      const stored = localStorage.getItem(this.options.storageKey);\n82 +      if (stored) {\n83 +        return JSON.parse(stored);\n84 +      }\n85 +    } catch (error) {\n86 +      console.warn('Failed to load persisted state:', error);\n87 +    }\n88 +\n89 +    return null;\n90 +  }\n91 +\n92 +  private persistState(): void {\n93 +    if (!this.options.persist || !this.options.storageKey) {\n94 +      return;\n95 +    }\n96 +\n97 +    try {\n98 +      localStorage.setItem(this.options.storageKey, JSON.stringify(this.state));\n99 +    } catch (error) {\n100 +      console.warn('Failed to persist state:', error);\n101 +    }\n102 +  }\n103 +\n104 +  private saveSnapshot(action: string): void {\n105 +    this.history.push({\n106 +      state: deepClone(this.state),\n107 +      timestamp: Date.now(),\n108 +      action,\n109 +    });\n110 +\n111 +    if (this.history.length > this.maxHistoryLength) {\n112 +      this.history.shift();\n113 +    }\n114 +  }\n115 +\n116 +  private notifyListeners(prevState: T): void {\n117 +    this.listeners.forEach(listener => {\n118 +      listener(this.state, prevState);\n119 +    });\n120 +  }\n121 +\n122 +  getState(): T {\n123 +    return this.state;\n124 +  }\n125 +\n126 +  setState(updater: StateUpdater<T> | Partial<T>, action = 'setState'): void {\n127 +    const prevState = this.state;\n128 +    const updates = typeof updater === 'function' ? updater(this.state) : updater;\n129 +\n130 +    this.state = deepMerge(this.state, updates);\n131 +\n132 +    if (this.options.middleware) {\n133 +      for (const mw of this.options.middleware) {\n134 +        this.state = mw(this.state, action);\n135 +      }\n136 +    }\n137 +\n138 +    this.saveSnapshot(action);\n139 +    this.persistState();\n140 +    this.notifyListeners(prevState);\n141 +  }\n142 +\n143 +  subscribe(listener: StateListener<T>): () => void {\n144 +    this.listeners.add(listener);\n145 +    return () => this.listeners.delete(listener);\n146 +  }\n147 +\n148 +  select<R>(selector: StateSelector<T, R>): R {\n149 +    return selector(this.state);\n150 +  }\n151 +\n152 +  undo(): boolean {\n153 +    if (this.history.length < 2) {\n154 +      return false;\n155 +    }\n156 +\n157 +    this.history.pop(); // Remove current state\n158 +    const previousSnapshot = this.history[this.history.length - 1];\n159 +\n160 +    if (previousSnapshot) {\n161 +      const prevState = this.state;\n162 +      this.state = deepClone(previousSnapshot.state);\n163 +      this.persistState();\n164 +      this.notifyListeners(prevState);\n165 +      return true;\n166 +    }\n167 +\n168 +    return false;\n169 +  }\n170 +\n171 +  getHistory(): StateSnapshot<T>[] {\n172 +    return [...this.history];\n173 +  }\n174 +\n175 +  importState(serialized: string): void {\n176 +    const imported = JSON.parse(serialized);\n177 +    this.setState(imported, 'import');\n178 +  }\n179 +\n180 +  exportState(): string {\n181 +    return JSON.stringify(this.state);\n182 +  }\n183 +\n184 +  reset(): void {\n185 +    const prevState = this.state;\n186 +    this.state = deepClone(this.options.initialState);\n187 +    this.history = [];\n188 +    this.saveSnapshot('reset');\n189 +    this.persistState();\n190 +    this.notifyListeners(prevState);\n191 +  }\n192 +}\n193 +\n194 +export function createStateManager<T extends object>(\n195 +  options: StateManagerOptions<T>\n196 +): StateManager<T> {\n197 +  return new StateManager(options);\n198 +}\n199 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in packages/state/src/store/StateManager.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "for (const key in source) {\n    if (source.hasOwnProperty(key)) {", "improvedCode": "for (const key in source) {\n    if (source.hasOwnProperty(key) && key !== '__proto__' && key !== 'constructor' && key !== 'prototype') {", "relevantFile": "packages/state/src/store/StateManager.ts", "relevantLinesEnd": 22, "suggestionContent": "The `deepMerge` function uses `hasOwnProperty` check but doesn't guard against `__proto__` or `constructor` keys. An attacker can pass `{\"__proto__\": {\"polluted\": true}}` as the source object, which will modify `Object.prototype` and affect all objects in the application. This is a prototype pollution vulnerability.", "oneSentenceSummary": "Prototype pollution vulnerability - deepMerge doesn't sanitize __proto__ keys", "relevantLinesStart": 20}, {"label": "bug", "language": "TypeScript", "existingCode": "importState(serialized: string): void {\n    const imported = JSON.parse(serialized);\n    this.setState(imported, 'import');\n  }", "improvedCode": "importState(serialized: string, validator?: (state: unknown) => state is Partial<T>): void {\n    const imported = JSON.parse(serialized);\n    if (validator && !validator(imported)) {\n      throw new Error('Invalid state format');\n    }\n    // Use Object.assign for flat merge to avoid prototype pollution\n    this.setState(imported as Partial<T>, 'import');\n  }", "relevantFile": "packages/state/src/store/StateManager.ts", "relevantLinesEnd": 161, "suggestionContent": "The `importState` method parses untrusted JSON and passes it directly to `setState`, which uses `deepMerge`. Combined with the prototype pollution in `deepMerge`, an attacker can pollute prototypes by importing malicious state. Also, there's no validation that the imported state matches the expected schema.", "oneSentenceSummary": "Unsafe deserialization - importState accepts untrusted JSON without validation", "relevantLinesStart": 158}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/billing/src/services/InvoiceCalculator.ts", "language": "TypeScript", "fileContent": "export interface LineItem {\n  id: string;\n  description: string;\n  quantity: number;\n  unitPrice: number;\n  taxRate: number;\n  discountPercent?: number;\n}\n\nexport interface Invoice {\n  id: string;\n  customerId: string;\n  items: LineItem[];\n  currency: string;\n  issuedAt: Date;\n  dueAt: Date;\n}\n\nexport interface InvoiceTotals {\n  subtotal: number;\n  totalDiscount: number;\n  totalTax: number;\n  grandTotal: number;\n}\n\nexport function calculateLineItemTotal(item: LineItem): number {\n  const baseAmount = item.quantity * item.unitPrice;\n  const discount = item.discountPercent\n    ? baseAmount * (item.discountPercent / 100)\n    : 0;\n  const afterDiscount = baseAmount - discount;\n  const tax = afterDiscount * (item.taxRate / 100);\n  return afterDiscount + tax;\n}\n\nexport function calculateInvoiceTotals(invoice: Invoice): InvoiceTotals {\n  let subtotal = 0;\n  let totalDiscount = 0;\n  let totalTax = 0;\n\n  for (const item of invoice.items) {\n    const baseAmount = item.quantity * item.unitPrice;\n    const discount = item.discountPercent\n      ? baseAmount * (item.discountPercent / 100)\n      : 0;\n    const afterDiscount = baseAmount - discount;\n    const tax = afterDiscount * (item.taxRate / 100);\n\n    subtotal += baseAmount;\n    totalDiscount += discount;\n    totalTax += tax;\n  }\n\n  const grandTotal = subtotal - totalDiscount + totalTax;\n\n  return {\n    subtotal,\n    totalDiscount,\n    totalTax,\n    grandTotal,\n  };\n}\n\nexport function formatCurrency(amount: number, currency: string): string {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency,\n  }).format(amount);\n}\n\nexport function splitPayment(\n  total: number,\n  installments: number\n): number[] {\n  const baseAmount = total / installments;\n  const payments = Array(installments).fill(baseAmount);\n\n  const sum = payments.reduce((a, b) => a + b, 0);\n  const remainder = total - sum;\n\n  if (remainder !== 0) {\n    payments[payments.length - 1] += remainder;\n  }\n\n  return payments;\n}\n\nexport class InvoiceCalculator {\n  calculateTotals(invoice: Invoice): InvoiceTotals {\n    return calculateInvoiceTotals(invoice);\n  }\n\n  calculateMonthlyPayments(\n    invoice: Invoice,\n    months: number\n  ): number[] {\n    const totals = this.calculateTotals(invoice);\n    return splitPayment(totals.grandTotal, months);\n  }\n\n  applyPromoCode(\n    invoice: Invoice,\n    discountPercent: number\n  ): Invoice {\n    return {\n      ...invoice,\n      items: invoice.items.map(item => ({\n        ...item,\n        discountPercent: (item.discountPercent ?? 0) + discountPercent,\n      })),\n    };\n  }\n\n  validateInvoice(invoice: Invoice): string[] {\n    const errors: string[] = [];\n\n    if (invoice.items.length === 0) {\n      errors.push('Invoice must have at least one line item');\n    }\n\n    for (const item of invoice.items) {\n      if (item.quantity <= 0) {\n        errors.push(`Item ${item.id}: quantity must be positive`);\n      }\n      if (item.unitPrice < 0) {\n        errors.push(`Item ${item.id}: unit price cannot be negative`);\n      }\n      if (item.taxRate < 0 || item.taxRate > 100) {\n        errors.push(`Item ${item.id}: tax rate must be between 0 and 100`);\n      }\n    }\n\n    return errors;\n  }\n}\n\nexport default InvoiceCalculator;\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/billing/src/services/InvoiceCalculator.ts'\n\n@@ -0,0 +1,138 @@\n__new hunk__\n1 +export interface LineItem {\n2 +  id: string;\n3 +  description: string;\n4 +  quantity: number;\n5 +  unitPrice: number;\n6 +  taxRate: number;\n7 +  discountPercent?: number;\n8 +}\n9 +\n10 +export interface Invoice {\n11 +  id: string;\n12 +  customerId: string;\n13 +  items: LineItem[];\n14 +  currency: string;\n15 +  issuedAt: Date;\n16 +  dueAt: Date;\n17 +}\n18 +\n19 +export interface InvoiceTotals {\n20 +  subtotal: number;\n21 +  totalDiscount: number;\n22 +  totalTax: number;\n23 +  grandTotal: number;\n24 +}\n25 +\n26 +export function calculateLineItemTotal(item: LineItem): number {\n27 +  const baseAmount = item.quantity * item.unitPrice;\n28 +  const discount = item.discountPercent\n29 +    ? baseAmount * (item.discountPercent / 100)\n30 +    : 0;\n31 +  const afterDiscount = baseAmount - discount;\n32 +  const tax = afterDiscount * (item.taxRate / 100);\n33 +  return afterDiscount + tax;\n34 +}\n35 +\n36 +export function calculateInvoiceTotals(invoice: Invoice): InvoiceTotals {\n37 +  let subtotal = 0;\n38 +  let totalDiscount = 0;\n39 +  let totalTax = 0;\n40 +\n41 +  for (const item of invoice.items) {\n42 +    const baseAmount = item.quantity * item.unitPrice;\n43 +    const discount = item.discountPercent\n44 +      ? baseAmount * (item.discountPercent / 100)\n45 +      : 0;\n46 +    const afterDiscount = baseAmount - discount;\n47 +    const tax = afterDiscount * (item.taxRate / 100);\n48 +\n49 +    subtotal += baseAmount;\n50 +    totalDiscount += discount;\n51 +    totalTax += tax;\n52 +  }\n53 +\n54 +  const grandTotal = subtotal - totalDiscount + totalTax;\n55 +\n56 +  return {\n57 +    subtotal,\n58 +    totalDiscount,\n59 +    totalTax,\n60 +    grandTotal,\n61 +  };\n62 +}\n63 +\n64 +export function formatCurrency(amount: number, currency: string): string {\n65 +  return new Intl.NumberFormat('en-US', {\n66 +    style: 'currency',\n67 +    currency,\n68 +  }).format(amount);\n69 +}\n70 +\n71 +export function splitPayment(\n72 +  total: number,\n73 +  installments: number\n74 +): number[] {\n75 +  const baseAmount = total / installments;\n76 +  const payments = Array(installments).fill(baseAmount);\n77 +\n78 +  const sum = payments.reduce((a, b) => a + b, 0);\n79 +  const remainder = total - sum;\n80 +\n81 +  if (remainder !== 0) {\n82 +    payments[payments.length - 1] += remainder;\n83 +  }\n84 +\n85 +  return payments;\n86 +}\n87 +\n88 +export class InvoiceCalculator {\n89 +  calculateTotals(invoice: Invoice): InvoiceTotals {\n90 +    return calculateInvoiceTotals(invoice);\n91 +  }\n92 +\n93 +  calculateMonthlyPayments(\n94 +    invoice: Invoice,\n95 +    months: number\n96 +  ): number[] {\n97 +    const totals = this.calculateTotals(invoice);\n98 +    return splitPayment(totals.grandTotal, months);\n99 +  }\n100 +\n101 +  applyPromoCode(\n102 +    invoice: Invoice,\n103 +    discountPercent: number\n104 +  ): Invoice {\n105 +    return {\n106 +      ...invoice,\n107 +      items: invoice.items.map(item => ({\n108 +        ...item,\n109 +        discountPercent: (item.discountPercent ?? 0) + discountPercent,\n110 +      })),\n111 +    };\n112 +  }\n113 +\n114 +  validateInvoice(invoice: Invoice): string[] {\n115 +    const errors: string[] = [];\n116 +\n117 +    if (invoice.items.length === 0) {\n118 +      errors.push('Invoice must have at least one line item');\n119 +    }\n120 +\n121 +    for (const item of invoice.items) {\n122 +      if (item.quantity <= 0) {\n123 +        errors.push(`Item ${item.id}: quantity must be positive`);\n124 +      }\n125 +      if (item.unitPrice < 0) {\n126 +        errors.push(`Item ${item.id}: unit price cannot be negative`);\n127 +      }\n128 +      if (item.taxRate < 0 || item.taxRate > 100) {\n129 +        errors.push(`Item ${item.id}: tax rate must be between 0 and 100`);\n130 +      }\n131 +    }\n132 +\n133 +    return errors;\n134 +  }\n135 +}\n136 +\n137 +export default InvoiceCalculator;\n138 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/billing/src/services/InvoiceCalculator.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "const baseAmount = item.quantity * item.unitPrice;\n    const discount = item.discountPercent\n      ? baseAmount * (item.discountPercent / 100)\n      : 0;\n    const afterDiscount = baseAmount - discount;\n    const tax = afterDiscount * (item.taxRate / 100);", "improvedCode": "const baseAmount = Math.round(item.quantity * item.unitPrice * 100) / 100;\n    const discount = item.discountPercent\n      ? Math.round(baseAmount * (item.discountPercent / 100) * 100) / 100\n      : 0;\n    const afterDiscount = Math.round((baseAmount - discount) * 100) / 100;\n    const tax = Math.round(afterDiscount * (item.taxRate / 100) * 100) / 100;", "relevantFile": "packages/billing/src/services/InvoiceCalculator.ts", "relevantLinesEnd": 47, "suggestionContent": "Financial calculations using floating point arithmetic will accumulate precision errors. For example, `0.1 + 0.2 = 0.30000000000000004` in JavaScript. When calculating invoice totals with multiple line items, these errors compound and can result in incorrect totals (e.g., $99.99999999 instead of $100.00). Use integer arithmetic with cents, a decimal library like decimal.js, or round intermediate results to avoid displaying incorrect amounts to customers.", "oneSentenceSummary": "Floating point arithmetic in financial calculations causes precision errors", "relevantLinesStart": 40}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/events/src/emitter/TypedEventEmitter.ts", "language": "TypeScript", "fileContent": "export type EventCallback<T = unknown> = (data: T) => void | Promise<void>;\nexport type UnsubscribeFn = () => void;\n\ninterface EventSubscription<T> {\n  callback: EventCallback<T>;\n  once: boolean;\n  priority: number;\n}\n\nexport class TypedEventEmitter<TEvents extends Record<string, unknown>> {\n  private listeners: Map<keyof TEvents, EventSubscription<any>[]> = new Map();\n  private maxListeners = 10;\n  private eventHistory: Map<keyof TEvents, unknown[]> = new Map();\n  private historySize = 100;\n\n  setMaxListeners(n: number): this {\n    this.maxListeners = n;\n    return this;\n  }\n\n  on<K extends keyof TEvents>(\n    event: K,\n    callback: EventCallback<TEvents[K]>,\n    priority = 0\n  ): UnsubscribeFn {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n\n    const subscriptions = this.listeners.get(event)!;\n\n    if (subscriptions.length >= this.maxListeners) {\n      console.warn(\n        `MaxListenersExceededWarning: Possible memory leak detected. ` +\n        `${subscriptions.length + 1} listeners added for event \"${String(event)}\".`\n      );\n    }\n\n    subscriptions.push({ callback, once: false, priority });\n    subscriptions.sort((a, b) => b.priority - a.priority);\n\n    return () => this.off(event, callback);\n  }\n\n  once<K extends keyof TEvents>(\n    event: K,\n    callback: EventCallback<TEvents[K]>,\n    priority = 0\n  ): UnsubscribeFn {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n\n    const subscriptions = this.listeners.get(event)!;\n    subscriptions.push({ callback, once: true, priority });\n    subscriptions.sort((a, b) => b.priority - a.priority);\n\n    return () => this.off(event, callback);\n  }\n\n  off<K extends keyof TEvents>(\n    event: K,\n    callback: EventCallback<TEvents[K]>\n  ): this {\n    const subscriptions = this.listeners.get(event);\n    if (!subscriptions) return this;\n\n    const index = subscriptions.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n      subscriptions.splice(index, 1);\n    }\n\n    return this;\n  }\n\n  emit<K extends keyof TEvents>(event: K, data: TEvents[K]): this {\n    this.recordHistory(event, data);\n\n    const subscriptions = this.listeners.get(event);\n    if (!subscriptions) return this;\n\n    const toRemove: EventSubscription<TEvents[K]>[] = [];\n\n    for (const sub of subscriptions) {\n      sub.callback(data);\n\n      if (sub.once) {\n        toRemove.push(sub);\n      }\n    }\n\n    for (const sub of toRemove) {\n      const index = subscriptions.indexOf(sub);\n      if (index !== -1) {\n        subscriptions.splice(index, 1);\n      }\n    }\n\n    return this;\n  }\n\n  async emitAsync<K extends keyof TEvents>(\n    event: K,\n    data: TEvents[K]\n  ): Promise<void> {\n    this.recordHistory(event, data);\n\n    const subscriptions = this.listeners.get(event);\n    if (!subscriptions) return;\n\n    for (const sub of subscriptions) {\n      await sub.callback(data);\n\n      if (sub.once) {\n        this.off(event, sub.callback);\n      }\n    }\n  }\n\n  private recordHistory<K extends keyof TEvents>(event: K, data: TEvents[K]): void {\n    if (!this.eventHistory.has(event)) {\n      this.eventHistory.set(event, []);\n    }\n\n    const history = this.eventHistory.get(event)!;\n    history.push(data);\n\n    if (history.length > this.historySize) {\n      history.shift();\n    }\n  }\n\n  getHistory<K extends keyof TEvents>(event: K): TEvents[K][] {\n    return (this.eventHistory.get(event) as TEvents[K][]) || [];\n  }\n\n  listenerCount<K extends keyof TEvents>(event: K): number {\n    return this.listeners.get(event)?.length ?? 0;\n  }\n\n  removeAllListeners<K extends keyof TEvents>(event?: K): this {\n    if (event) {\n      this.listeners.delete(event);\n    } else {\n      this.listeners.clear();\n    }\n    return this;\n  }\n\n  eventNames(): (keyof TEvents)[] {\n    return Array.from(this.listeners.keys());\n  }\n}\n\nexport function createEventEmitter<TEvents extends Record<string, unknown>>(): TypedEventEmitter<TEvents> {\n  return new TypedEventEmitter<TEvents>();\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/events/src/emitter/TypedEventEmitter.ts'\n\n@@ -0,0 +1,158 @@\n__new hunk__\n1 +export type EventCallback<T = unknown> = (data: T) => void | Promise<void>;\n2 +export type UnsubscribeFn = () => void;\n3 +\n4 +interface EventSubscription<T> {\n5 +  callback: EventCallback<T>;\n6 +  once: boolean;\n7 +  priority: number;\n8 +}\n9 +\n10 +export class TypedEventEmitter<TEvents extends Record<string, unknown>> {\n11 +  private listeners: Map<keyof TEvents, EventSubscription<any>[]> = new Map();\n12 +  private maxListeners = 10;\n13 +  private eventHistory: Map<keyof TEvents, unknown[]> = new Map();\n14 +  private historySize = 100;\n15 +\n16 +  setMaxListeners(n: number): this {\n17 +    this.maxListeners = n;\n18 +    return this;\n19 +  }\n20 +\n21 +  on<K extends keyof TEvents>(\n22 +    event: K,\n23 +    callback: EventCallback<TEvents[K]>,\n24 +    priority = 0\n25 +  ): UnsubscribeFn {\n26 +    if (!this.listeners.has(event)) {\n27 +      this.listeners.set(event, []);\n28 +    }\n29 +\n30 +    const subscriptions = this.listeners.get(event)!;\n31 +\n32 +    if (subscriptions.length >= this.maxListeners) {\n33 +      console.warn(\n34 +        `MaxListenersExceededWarning: Possible memory leak detected. ` +\n35 +        `${subscriptions.length + 1} listeners added for event \"${String(event)}\".`\n36 +      );\n37 +    }\n38 +\n39 +    subscriptions.push({ callback, once: false, priority });\n40 +    subscriptions.sort((a, b) => b.priority - a.priority);\n41 +\n42 +    return () => this.off(event, callback);\n43 +  }\n44 +\n45 +  once<K extends keyof TEvents>(\n46 +    event: K,\n47 +    callback: EventCallback<TEvents[K]>,\n48 +    priority = 0\n49 +  ): UnsubscribeFn {\n50 +    if (!this.listeners.has(event)) {\n51 +      this.listeners.set(event, []);\n52 +    }\n53 +\n54 +    const subscriptions = this.listeners.get(event)!;\n55 +    subscriptions.push({ callback, once: true, priority });\n56 +    subscriptions.sort((a, b) => b.priority - a.priority);\n57 +\n58 +    return () => this.off(event, callback);\n59 +  }\n60 +\n61 +  off<K extends keyof TEvents>(\n62 +    event: K,\n63 +    callback: EventCallback<TEvents[K]>\n64 +  ): this {\n65 +    const subscriptions = this.listeners.get(event);\n66 +    if (!subscriptions) return this;\n67 +\n68 +    const index = subscriptions.findIndex(sub => sub.callback === callback);\n69 +    if (index !== -1) {\n70 +      subscriptions.splice(index, 1);\n71 +    }\n72 +\n73 +    return this;\n74 +  }\n75 +\n76 +  emit<K extends keyof TEvents>(event: K, data: TEvents[K]): this {\n77 +    this.recordHistory(event, data);\n78 +\n79 +    const subscriptions = this.listeners.get(event);\n80 +    if (!subscriptions) return this;\n81 +\n82 +    const toRemove: EventSubscription<TEvents[K]>[] = [];\n83 +\n84 +    for (const sub of subscriptions) {\n85 +      sub.callback(data);\n86 +\n87 +      if (sub.once) {\n88 +        toRemove.push(sub);\n89 +      }\n90 +    }\n91 +\n92 +    for (const sub of toRemove) {\n93 +      const index = subscriptions.indexOf(sub);\n94 +      if (index !== -1) {\n95 +        subscriptions.splice(index, 1);\n96 +      }\n97 +    }\n98 +\n99 +    return this;\n100 +  }\n101 +\n102 +  async emitAsync<K extends keyof TEvents>(\n103 +    event: K,\n104 +    data: TEvents[K]\n105 +  ): Promise<void> {\n106 +    this.recordHistory(event, data);\n107 +\n108 +    const subscriptions = this.listeners.get(event);\n109 +    if (!subscriptions) return;\n110 +\n111 +    for (const sub of subscriptions) {\n112 +      await sub.callback(data);\n113 +\n114 +      if (sub.once) {\n115 +        this.off(event, sub.callback);\n116 +      }\n117 +    }\n118 +  }\n119 +\n120 +  private recordHistory<K extends keyof TEvents>(event: K, data: TEvents[K]): void {\n121 +    if (!this.eventHistory.has(event)) {\n122 +      this.eventHistory.set(event, []);\n123 +    }\n124 +\n125 +    const history = this.eventHistory.get(event)!;\n126 +    history.push(data);\n127 +\n128 +    if (history.length > this.historySize) {\n129 +      history.shift();\n130 +    }\n131 +  }\n132 +\n133 +  getHistory<K extends keyof TEvents>(event: K): TEvents[K][] {\n134 +    return (this.eventHistory.get(event) as TEvents[K][]) || [];\n135 +  }\n136 +\n137 +  listenerCount<K extends keyof TEvents>(event: K): number {\n138 +    return this.listeners.get(event)?.length ?? 0;\n139 +  }\n140 +\n141 +  removeAllListeners<K extends keyof TEvents>(event?: K): this {\n142 +    if (event) {\n143 +      this.listeners.delete(event);\n144 +    } else {\n145 +      this.listeners.clear();\n146 +    }\n147 +    return this;\n148 +  }\n149 +\n150 +  eventNames(): (keyof TEvents)[] {\n151 +    return Array.from(this.listeners.keys());\n152 +  }\n153 +}\n154 +\n155 +export function createEventEmitter<TEvents extends Record<string, unknown>>(): TypedEventEmitter<TEvents> {\n156 +  return new TypedEventEmitter<TEvents>();\n157 +}\n158 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/events/src/emitter/TypedEventEmitter.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "for (const sub of subscriptions) {\n      sub.callback(data);\n\n      if (sub.once) {\n        toRemove.push(sub);\n      }\n    }\n\n    for (const sub of toRemove) {\n      const index = subscriptions.indexOf(sub);\n      if (index !== -1) {\n        subscriptions.splice(index, 1);\n      }\n    }", "improvedCode": "const toExecute = [...subscriptions];\n    \n    for (const sub of toExecute) {\n      sub.callback(data);\n\n      if (sub.once) {\n        const index = subscriptions.indexOf(sub);\n        if (index !== -1) {\n          subscriptions.splice(index, 1);\n        }\n      }\n    }", "relevantFile": "packages/events/src/emitter/TypedEventEmitter.ts", "relevantLinesEnd": 88, "suggestionContent": "In the `emit` method, the code iterates over `subscriptions` array while also modifying it (removing 'once' listeners via splice). This causes items to be skipped when iterating. For example, if subscriptions[0] is a 'once' listener and gets removed, subscriptions[1] shifts to index 0, but the loop continues to index 1, skipping what was originally subscriptions[1].", "oneSentenceSummary": "Iterating and splicing same array causes listeners to be skipped", "relevantLinesStart": 74}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/dom/src/observers/ResizeObserverManager.ts", "language": "TypeScript", "fileContent": "type ResizeCallback = (entry: ResizeObserverEntry) => void;\n\ninterface ObservedElement {\n  element: Element;\n  callback: ResizeCallback;\n}\n\nexport class ResizeObserverManager {\n  private observer: ResizeObserver;\n  private observedElements: Map<Element, ResizeCallback> = new Map();\n  private isInitialized = false;\n\n  constructor() {\n    this.observer = new ResizeObserver(this.handleResize.bind(this));\n    this.isInitialized = true;\n  }\n\n  private handleResize(entries: ResizeObserverEntry[]): void {\n    for (const entry of entries) {\n      const callback = this.observedElements.get(entry.target);\n      if (callback) {\n        try {\n          callback(entry);\n        } catch (error) {\n          console.error('Resize callback error:', error);\n        }\n      }\n    }\n  }\n\n  observe(element: Element, callback: ResizeCallback): void {\n    if (!this.isInitialized) {\n      throw new Error('ResizeObserverManager not initialized');\n    }\n\n    if (this.observedElements.has(element)) {\n      console.warn('Element already being observed, updating callback');\n    }\n\n    this.observedElements.set(element, callback);\n    this.observer.observe(element);\n  }\n\n  unobserve(element: Element): void {\n    this.observer.unobserve(element);\n    this.observedElements.delete(element);\n  }\n\n  disconnect(): void {\n    this.observer.disconnect();\n    this.observedElements.clear();\n  }\n\n  isObserving(element: Element): boolean {\n    return this.observedElements.has(element);\n  }\n}\n\nexport function useResizeObserver(\n  elementRef: { current: Element | null },\n  callback: ResizeCallback\n): void {\n  const manager = getGlobalManager();\n\n  if (elementRef.current) {\n    manager.observe(elementRef.current, callback);\n  }\n\n  return () => {\n    if (elementRef.current) {\n      manager.unobserve(elementRef.current);\n    }\n  };\n}\n\nlet globalManager: ResizeObserverManager | null = null;\n\nfunction getGlobalManager(): ResizeObserverManager {\n  if (!globalManager) {\n    globalManager = new ResizeObserverManager();\n  }\n  return globalManager;\n}\n\nexport class ElementResizeWatcher {\n  private cleanup: (() => void) | null = null;\n\n  watch(element: Element, onResize: ResizeCallback): void {\n    const manager = getGlobalManager();\n    manager.observe(element, onResize);\n\n    this.cleanup = () => {\n      manager.unobserve(element);\n    };\n\n    window.addEventListener('beforeunload', this.cleanup.bind(this));\n  }\n\n  unwatch(): void {\n    if (this.cleanup) {\n      this.cleanup();\n      this.cleanup = null;\n    }\n  }\n\n  destroy(): void {\n    this.unwatch();\n    window.removeEventListener('beforeunload', this.cleanup?.bind(this) as EventListener);\n  }\n}\n\nexport default ResizeObserverManager;\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/dom/src/observers/ResizeObserverManager.ts'\n\n@@ -0,0 +1,113 @@\n__new hunk__\n1 +type ResizeCallback = (entry: ResizeObserverEntry) => void;\n2 +\n3 +interface ObservedElement {\n4 +  element: Element;\n5 +  callback: ResizeCallback;\n6 +}\n7 +\n8 +export class ResizeObserverManager {\n9 +  private observer: ResizeObserver;\n10 +  private observedElements: Map<Element, ResizeCallback> = new Map();\n11 +  private isInitialized = false;\n12 +\n13 +  constructor() {\n14 +    this.observer = new ResizeObserver(this.handleResize.bind(this));\n15 +    this.isInitialized = true;\n16 +  }\n17 +\n18 +  private handleResize(entries: ResizeObserverEntry[]): void {\n19 +    for (const entry of entries) {\n20 +      const callback = this.observedElements.get(entry.target);\n21 +      if (callback) {\n22 +        try {\n23 +          callback(entry);\n24 +        } catch (error) {\n25 +          console.error('Resize callback error:', error);\n26 +        }\n27 +      }\n28 +    }\n29 +  }\n30 +\n31 +  observe(element: Element, callback: ResizeCallback): void {\n32 +    if (!this.isInitialized) {\n33 +      throw new Error('ResizeObserverManager not initialized');\n34 +    }\n35 +\n36 +    if (this.observedElements.has(element)) {\n37 +      console.warn('Element already being observed, updating callback');\n38 +    }\n39 +\n40 +    this.observedElements.set(element, callback);\n41 +    this.observer.observe(element);\n42 +  }\n43 +\n44 +  unobserve(element: Element): void {\n45 +    this.observer.unobserve(element);\n46 +    this.observedElements.delete(element);\n47 +  }\n48 +\n49 +  disconnect(): void {\n50 +    this.observer.disconnect();\n51 +    this.observedElements.clear();\n52 +  }\n53 +\n54 +  isObserving(element: Element): boolean {\n55 +    return this.observedElements.has(element);\n56 +  }\n57 +}\n58 +\n59 +export function useResizeObserver(\n60 +  elementRef: { current: Element | null },\n61 +  callback: ResizeCallback\n62 +): void {\n63 +  const manager = getGlobalManager();\n64 +\n65 +  if (elementRef.current) {\n66 +    manager.observe(elementRef.current, callback);\n67 +  }\n68 +\n69 +  return () => {\n70 +    if (elementRef.current) {\n71 +      manager.unobserve(elementRef.current);\n72 +    }\n73 +  };\n74 +}\n75 +\n76 +let globalManager: ResizeObserverManager | null = null;\n77 +\n78 +function getGlobalManager(): ResizeObserverManager {\n79 +  if (!globalManager) {\n80 +    globalManager = new ResizeObserverManager();\n81 +  }\n82 +  return globalManager;\n83 +}\n84 +\n85 +export class ElementResizeWatcher {\n86 +  private cleanup: (() => void) | null = null;\n87 +\n88 +  watch(element: Element, onResize: ResizeCallback): void {\n89 +    const manager = getGlobalManager();\n90 +    manager.observe(element, onResize);\n91 +\n92 +    this.cleanup = () => {\n93 +      manager.unobserve(element);\n94 +    };\n95 +\n96 +    window.addEventListener('beforeunload', this.cleanup.bind(this));\n97 +  }\n98 +\n99 +  unwatch(): void {\n100 +    if (this.cleanup) {\n101 +      this.cleanup();\n102 +      this.cleanup = null;\n103 +    }\n104 +  }\n105 +\n106 +  destroy(): void {\n107 +    this.unwatch();\n108 +    window.removeEventListener('beforeunload', this.cleanup?.bind(this) as EventListener);\n109 +  }\n110 +}\n111 +\n112 +export default ResizeObserverManager;\n113 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/dom/src/observers/ResizeObserverManager.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "window.addEventListener('beforeunload', this.cleanup.bind(this));\n  }\n\n  unwatch(): void {\n    if (this.cleanup) {\n      this.cleanup();\n      this.cleanup = null;\n    }\n  }\n\n  destroy(): void {\n    this.unwatch();\n    window.removeEventListener('beforeunload', this.cleanup?.bind(this) as EventListener);\n  }", "improvedCode": "private boundCleanup: (() => void) | null = null;\n\n  watch(element: Element, onResize: ResizeCallback): void {\n    // ... existing code ...\n    this.boundCleanup = this.cleanup.bind(this);\n    window.addEventListener('beforeunload', this.boundCleanup);\n  }\n\n  destroy(): void {\n    this.unwatch();\n    if (this.boundCleanup) {\n      window.removeEventListener('beforeunload', this.boundCleanup);\n      this.boundCleanup = null;\n    }\n  }", "relevantFile": "packages/dom/src/observers/ResizeObserverManager.ts", "relevantLinesEnd": 100, "suggestionContent": "In the `destroy` method, `removeEventListener` is called with `this.cleanup?.bind(this)` which creates a new function reference. Since `bind()` always creates a new function, this will never match the function added in `watch()` (which used a different `.bind(this)` call). The event listener will never be removed, causing a memory leak. Store the bound function reference and use the same reference for both `addEventListener` and `removeEventListener`.", "oneSentenceSummary": "bind() creates new function reference - removeEventListener never matches addEventListener", "relevantLinesStart": 89}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/ui/src/components/InfiniteScroll.tsx", "language": "TypeScript", "fileContent": "import React, { useEffect, useRef, useState, useCallback } from 'react';\n\ninterface InfiniteScrollProps {\n  onLoadMore: () => Promise<void>;\n  hasMore: boolean;\n  threshold?: number;\n  children: React.ReactNode;\n  loader?: React.ReactNode;\n}\n\ninterface ScrollState {\n  isLoading: boolean;\n  error: Error | null;\n  page: number;\n}\n\nexport function InfiniteScroll({\n  onLoadMore,\n  hasMore,\n  threshold = 200,\n  children,\n  loader = <div className=\"loading\">Loading...</div>,\n}: InfiniteScrollProps) {\n  const [state, setState] = useState<ScrollState>({\n    isLoading: false,\n    error: null,\n    page: 1,\n  });\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const loadingRef = useRef(false);\n\n  const handleScroll = useCallback(() => {\n    const container = containerRef.current;\n    if (!container || loadingRef.current || !hasMore) return;\n\n    const { scrollTop, scrollHeight, clientHeight } = container;\n    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n\n    if (distanceFromBottom < threshold) {\n      loadingRef.current = true;\n      setState(prev => ({ ...prev, isLoading: true }));\n\n      onLoadMore()\n        .then(() => {\n          setState(prev => ({\n            ...prev,\n            isLoading: false,\n            page: prev.page + 1,\n          }));\n        })\n        .catch((error) => {\n          setState(prev => ({\n            ...prev,\n            isLoading: false,\n            error,\n          }));\n        })\n        .finally(() => {\n          loadingRef.current = false;\n        });\n    }\n  }, [threshold, onLoadMore]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    container.addEventListener('scroll', handleScroll);\n    return () => container.removeEventListener('scroll', handleScroll);\n  }, [handleScroll]);\n\n  useEffect(() => {\n    handleScroll();\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"infinite-scroll-container\"\n      style={{ overflow: 'auto', height: '100%' }}\n    >\n      {children}\n      {state.isLoading && loader}\n      {state.error && (\n        <div className=\"error\">\n          Failed to load: {state.error.message}\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default InfiniteScroll;\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/ui/src/components/InfiniteScroll.tsx'\n\n@@ -0,0 +1,95 @@\n__new hunk__\n1 +import React, { useEffect, useRef, useState, useCallback } from 'react';\n2 +\n3 +interface InfiniteScrollProps {\n4 +  onLoadMore: () => Promise<void>;\n5 +  hasMore: boolean;\n6 +  threshold?: number;\n7 +  children: React.ReactNode;\n8 +  loader?: React.ReactNode;\n9 +}\n10 +\n11 +interface ScrollState {\n12 +  isLoading: boolean;\n13 +  error: Error | null;\n14 +  page: number;\n15 +}\n16 +\n17 +export function InfiniteScroll({\n18 +  onLoadMore,\n19 +  hasMore,\n20 +  threshold = 200,\n21 +  children,\n22 +  loader = <div className=\"loading\">Loading...</div>,\n23 +}: InfiniteScrollProps) {\n24 +  const [state, setState] = useState<ScrollState>({\n25 +    isLoading: false,\n26 +    error: null,\n27 +    page: 1,\n28 +  });\n29 +\n30 +  const containerRef = useRef<HTMLDivElement>(null);\n31 +  const loadingRef = useRef(false);\n32 +\n33 +  const handleScroll = useCallback(() => {\n34 +    const container = containerRef.current;\n35 +    if (!container || loadingRef.current || !hasMore) return;\n36 +\n37 +    const { scrollTop, scrollHeight, clientHeight } = container;\n38 +    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n39 +\n40 +    if (distanceFromBottom < threshold) {\n41 +      loadingRef.current = true;\n42 +      setState(prev => ({ ...prev, isLoading: true }));\n43 +\n44 +      onLoadMore()\n45 +        .then(() => {\n46 +          setState(prev => ({\n47 +            ...prev,\n48 +            isLoading: false,\n49 +            page: prev.page + 1,\n50 +          }));\n51 +        })\n52 +        .catch((error) => {\n53 +          setState(prev => ({\n54 +            ...prev,\n55 +            isLoading: false,\n56 +            error,\n57 +          }));\n58 +        })\n59 +        .finally(() => {\n60 +          loadingRef.current = false;\n61 +        });\n62 +    }\n63 +  }, [threshold, onLoadMore]);\n64 +\n65 +  useEffect(() => {\n66 +    const container = containerRef.current;\n67 +    if (!container) return;\n68 +\n69 +    container.addEventListener('scroll', handleScroll);\n70 +    return () => container.removeEventListener('scroll', handleScroll);\n71 +  }, [handleScroll]);\n72 +\n73 +  useEffect(() => {\n74 +    handleScroll();\n75 +  }, []);\n76 +\n77 +  return (\n78 +    <div\n79 +      ref={containerRef}\n80 +      className=\"infinite-scroll-container\"\n81 +      style={{ overflow: 'auto', height: '100%' }}\n82 +    >\n83 +      {children}\n84 +      {state.isLoading && loader}\n85 +      {state.error && (\n86 +        <div className=\"error\">\n87 +          Failed to load: {state.error.message}\n88 +        </div>\n89 +      )}\n90 +    </div>\n91 +  );\n92 +}\n93 +\n94 +export default InfiniteScroll;\n95 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 1 bug(s) in packages/ui/src/components/InfiniteScroll.tsx", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "const handleScroll = useCallback(() => {\n    const container = containerRef.current;\n    if (!container || loadingRef.current || !hasMore) return;", "improvedCode": "const handleScroll = useCallback(() => {\n    const container = containerRef.current;\n    if (!container || loadingRef.current || !hasMore) return;", "relevantFile": "packages/ui/src/components/InfiniteScroll.tsx", "relevantLinesEnd": 56, "suggestionContent": "The `handleScroll` callback has `hasMore` in its closure but `hasMore` is not included in the dependency array. When `hasMore` changes to `false`, the callback still uses the stale `true` value, causing unnecessary load attempts. Additionally, the initial scroll check in useEffect on line 68 has an empty dependency array but calls `handleScroll` which may not be the latest version.", "oneSentenceSummary": "useCallback missing hasMore dependency causes stale closure bug", "relevantLinesStart": 31}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/upload/src/handlers/FileUploadHandler.ts", "language": "TypeScript", "fileContent": "import * as path from 'path';\nimport * as fs from 'fs/promises';\nimport * as crypto from 'crypto';\n\nexport interface UploadConfig {\n  uploadDir: string;\n  maxFileSize: number;\n  allowedExtensions: string[];\n  allowedMimeTypes: string[];\n}\n\nexport interface UploadedFile {\n  originalName: string;\n  savedPath: string;\n  size: number;\n  mimeType: string;\n  hash: string;\n}\n\nexport interface FileMetadata {\n  name: string;\n  size: number;\n  type: string;\n}\n\nconst DEFAULT_CONFIG: UploadConfig = {\n  uploadDir: './uploads',\n  maxFileSize: 10 * 1024 * 1024, // 10MB\n  allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx'],\n  allowedMimeTypes: [\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'application/pdf',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  ],\n};\n\nexport function getFileExtension(filename: string): string {\n  return path.extname(filename).toLowerCase();\n}\n\nexport function generateUniqueFilename(originalName: string): string {\n  const ext = getFileExtension(originalName);\n  const timestamp = Date.now();\n  const random = crypto.randomBytes(8).toString('hex');\n  return `${timestamp}_${random}${ext}`;\n}\n\nexport function sanitizeFilename(filename: string): string {\n  return filename\n    .replace(/[^a-zA-Z0-9._-]/g, '_')\n    .replace(/_{2,}/g, '_');\n}\n\nexport async function calculateFileHash(buffer: Buffer): Promise<string> {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}\n\nexport class FileUploadHandler {\n  private config: UploadConfig;\n\n  constructor(config: Partial<UploadConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async ensureUploadDir(): Promise<void> {\n    await fs.mkdir(this.config.uploadDir, { recursive: true });\n  }\n\n  validateExtension(filename: string): boolean {\n    const ext = getFileExtension(filename);\n    return this.config.allowedExtensions.includes(ext);\n  }\n\n  validateMimeType(mimeType: string): boolean {\n    return this.config.allowedMimeTypes.includes(mimeType);\n  }\n\n  validateFileSize(size: number): boolean {\n    return size <= this.config.maxFileSize;\n  }\n\n  async saveFile(\n    buffer: Buffer,\n    metadata: FileMetadata\n  ): Promise<UploadedFile> {\n    await this.ensureUploadDir();\n\n    if (!this.validateExtension(metadata.name)) {\n      throw new Error(`File extension not allowed: ${getFileExtension(metadata.name)}`);\n    }\n\n    if (!this.validateMimeType(metadata.type)) {\n      throw new Error(`MIME type not allowed: ${metadata.type}`);\n    }\n\n    if (!this.validateFileSize(metadata.size)) {\n      throw new Error(`File size exceeds limit: ${metadata.size} bytes`);\n    }\n\n    const sanitized = sanitizeFilename(metadata.name);\n    const filename = generateUniqueFilename(sanitized);\n    const filepath = path.join(this.config.uploadDir, filename);\n\n    await fs.writeFile(filepath, buffer);\n\n    const hash = await calculateFileHash(buffer);\n\n    return {\n      originalName: metadata.name,\n      savedPath: filepath,\n      size: buffer.length,\n      mimeType: metadata.type,\n      hash,\n    };\n  }\n\n  async deleteFile(filepath: string): Promise<void> {\n    const fullPath = path.join(this.config.uploadDir, filepath);\n    await fs.unlink(fullPath);\n  }\n\n  async getFile(filepath: string): Promise<Buffer> {\n    const fullPath = path.join(this.config.uploadDir, filepath);\n    return fs.readFile(fullPath);\n  }\n\n  async listFiles(): Promise<string[]> {\n    return fs.readdir(this.config.uploadDir);\n  }\n\n  getConfig(): UploadConfig {\n    return { ...this.config };\n  }\n}\n\nexport function createUploadHandler(config?: Partial<UploadConfig>): FileUploadHandler {\n  return new FileUploadHandler(config);\n}\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/upload/src/handlers/FileUploadHandler.ts'\n\n@@ -0,0 +1,142 @@\n__new hunk__\n1 +import * as path from 'path';\n2 +import * as fs from 'fs/promises';\n3 +import * as crypto from 'crypto';\n4 +\n5 +export interface UploadConfig {\n6 +  uploadDir: string;\n7 +  maxFileSize: number;\n8 +  allowedExtensions: string[];\n9 +  allowedMimeTypes: string[];\n10 +}\n11 +\n12 +export interface UploadedFile {\n13 +  originalName: string;\n14 +  savedPath: string;\n15 +  size: number;\n16 +  mimeType: string;\n17 +  hash: string;\n18 +}\n19 +\n20 +export interface FileMetadata {\n21 +  name: string;\n22 +  size: number;\n23 +  type: string;\n24 +}\n25 +\n26 +const DEFAULT_CONFIG: UploadConfig = {\n27 +  uploadDir: './uploads',\n28 +  maxFileSize: 10 * 1024 * 1024, // 10MB\n29 +  allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx'],\n30 +  allowedMimeTypes: [\n31 +    'image/jpeg',\n32 +    'image/png',\n33 +    'image/gif',\n34 +    'application/pdf',\n35 +    'application/msword',\n36 +    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n37 +  ],\n38 +};\n39 +\n40 +export function getFileExtension(filename: string): string {\n41 +  return path.extname(filename).toLowerCase();\n42 +}\n43 +\n44 +export function generateUniqueFilename(originalName: string): string {\n45 +  const ext = getFileExtension(originalName);\n46 +  const timestamp = Date.now();\n47 +  const random = crypto.randomBytes(8).toString('hex');\n48 +  return `${timestamp}_${random}${ext}`;\n49 +}\n50 +\n51 +export function sanitizeFilename(filename: string): string {\n52 +  return filename\n53 +    .replace(/[^a-zA-Z0-9._-]/g, '_')\n54 +    .replace(/_{2,}/g, '_');\n55 +}\n56 +\n57 +export async function calculateFileHash(buffer: Buffer): Promise<string> {\n58 +  return crypto.createHash('sha256').update(buffer).digest('hex');\n59 +}\n60 +\n61 +export class FileUploadHandler {\n62 +  private config: UploadConfig;\n63 +\n64 +  constructor(config: Partial<UploadConfig> = {}) {\n65 +    this.config = { ...DEFAULT_CONFIG, ...config };\n66 +  }\n67 +\n68 +  async ensureUploadDir(): Promise<void> {\n69 +    await fs.mkdir(this.config.uploadDir, { recursive: true });\n70 +  }\n71 +\n72 +  validateExtension(filename: string): boolean {\n73 +    const ext = getFileExtension(filename);\n74 +    return this.config.allowedExtensions.includes(ext);\n75 +  }\n76 +\n77 +  validateMimeType(mimeType: string): boolean {\n78 +    return this.config.allowedMimeTypes.includes(mimeType);\n79 +  }\n80 +\n81 +  validateFileSize(size: number): boolean {\n82 +    return size <= this.config.maxFileSize;\n83 +  }\n84 +\n85 +  async saveFile(\n86 +    buffer: Buffer,\n87 +    metadata: FileMetadata\n88 +  ): Promise<UploadedFile> {\n89 +    await this.ensureUploadDir();\n90 +\n91 +    if (!this.validateExtension(metadata.name)) {\n92 +      throw new Error(`File extension not allowed: ${getFileExtension(metadata.name)}`);\n93 +    }\n94 +\n95 +    if (!this.validateMimeType(metadata.type)) {\n96 +      throw new Error(`MIME type not allowed: ${metadata.type}`);\n97 +    }\n98 +\n99 +    if (!this.validateFileSize(metadata.size)) {\n100 +      throw new Error(`File size exceeds limit: ${metadata.size} bytes`);\n101 +    }\n102 +\n103 +    const sanitized = sanitizeFilename(metadata.name);\n104 +    const filename = generateUniqueFilename(sanitized);\n105 +    const filepath = path.join(this.config.uploadDir, filename);\n106 +\n107 +    await fs.writeFile(filepath, buffer);\n108 +\n109 +    const hash = await calculateFileHash(buffer);\n110 +\n111 +    return {\n112 +      originalName: metadata.name,\n113 +      savedPath: filepath,\n114 +      size: buffer.length,\n115 +      mimeType: metadata.type,\n116 +      hash,\n117 +    };\n118 +  }\n119 +\n120 +  async deleteFile(filepath: string): Promise<void> {\n121 +    const fullPath = path.join(this.config.uploadDir, filepath);\n122 +    await fs.unlink(fullPath);\n123 +  }\n124 +\n125 +  async getFile(filepath: string): Promise<Buffer> {\n126 +    const fullPath = path.join(this.config.uploadDir, filepath);\n127 +    return fs.readFile(fullPath);\n128 +  }\n129 +\n130 +  async listFiles(): Promise<string[]> {\n131 +    return fs.readdir(this.config.uploadDir);\n132 +  }\n133 +\n134 +  getConfig(): UploadConfig {\n135 +    return { ...this.config };\n136 +  }\n137 +}\n138 +\n139 +export function createUploadHandler(config?: Partial<UploadConfig>): FileUploadHandler {\n140 +  return new FileUploadHandler(config);\n141 +}\n142 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 2 bug(s) in packages/upload/src/handlers/FileUploadHandler.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": "async deleteFile(filepath: string): Promise<void> {\n    const fullPath = path.join(this.config.uploadDir, filepath);\n    await fs.unlink(fullPath);\n  }\n\n  async getFile(filepath: string): Promise<Buffer> {\n    const fullPath = path.join(this.config.uploadDir, filepath);\n    return fs.readFile(fullPath);\n  }", "improvedCode": "async deleteFile(filepath: string): Promise<void> {\n    const fullPath = path.resolve(this.config.uploadDir, filepath);\n    const uploadDirResolved = path.resolve(this.config.uploadDir);\n    if (!fullPath.startsWith(uploadDirResolved + path.sep)) {\n      throw new Error('Invalid file path');\n    }\n    await fs.unlink(fullPath);\n  }\n\n  async getFile(filepath: string): Promise<Buffer> {\n    const fullPath = path.resolve(this.config.uploadDir, filepath);\n    const uploadDirResolved = path.resolve(this.config.uploadDir);\n    if (!fullPath.startsWith(uploadDirResolved + path.sep)) {\n      throw new Error('Invalid file path');\n    }\n    return fs.readFile(fullPath);\n  }", "relevantFile": "packages/upload/src/handlers/FileUploadHandler.ts", "relevantLinesEnd": 114, "suggestionContent": "The `deleteFile` and `getFile` methods are vulnerable to path traversal attacks. An attacker can pass `../../../etc/passwd` as the filepath parameter. Using `path.join(uploadDir, filepath)` doesn't prevent escaping the upload directory. Need to validate that the resolved path is still within the upload directory.", "oneSentenceSummary": "Path traversal vulnerability - can read/delete files outside upload directory", "relevantLinesStart": 106}, {"label": "bug", "language": "TypeScript", "existingCode": "if (!this.validateFileSize(metadata.size)) {\n      throw new Error(`File size exceeds limit: ${metadata.size} bytes`);\n    }", "improvedCode": "if (!this.validateFileSize(buffer.length)) {\n      throw new Error(`File size exceeds limit: ${buffer.length} bytes`);\n    }\n    \n    if (buffer.length !== metadata.size) {\n      throw new Error(`Size mismatch: claimed ${metadata.size}, actual ${buffer.length}`);\n    }", "relevantFile": "packages/upload/src/handlers/FileUploadHandler.ts", "relevantLinesEnd": 93, "suggestionContent": "The `saveFile` method validates `metadata.size` but then writes `buffer` without checking if `buffer.length` matches `metadata.size`. An attacker can claim a small file size in metadata while sending a large buffer, bypassing the size limit check.", "oneSentenceSummary": "Size validation uses metadata instead of actual buffer length - bypass possible", "relevantLinesStart": 91}]}}}
{"metadata" : {}, "inputs" : {"inputs": {"filePath": "packages/forms/src/validators/FormValidator.ts", "language": "TypeScript", "fileContent": "export interface FieldValidation {\n  field: string;\n  isValid: boolean;\n  errors: string[];\n}\n\nexport interface FormValidationResult {\n  isValid: boolean;\n  fields: FieldValidation[];\n  summary: string;\n}\n\nexport interface ValidationRule {\n  name: string;\n  message: string;\n  validate: (value: string, formData?: Record<string, string>) => boolean;\n}\n\nconst emailRegex = /^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,}|[0-9]{1,3})(\\]?)$/;\nconst passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$/;\nconst urlRegex = /^(https?:\\/\\/)?(([\\da-z\\.-]+)\\.([a-z\\.]{2,6})|localhost)([\\/\\w \\.-]*)*\\/?$/;\n\nexport const commonRules: Record<string, ValidationRule> = {\n  required: {\n    name: 'required',\n    message: 'This field is required',\n    validate: (value) => value.trim().length > 0,\n  },\n  email: {\n    name: 'email',\n    message: 'Please enter a valid email address',\n    validate: (value) => emailRegex.test(value),\n  },\n  password: {\n    name: 'password',\n    message: 'Password must be at least 8 characters with uppercase, lowercase, number and special character',\n    validate: (value) => passwordRegex.test(value),\n  },\n  url: {\n    name: 'url',\n    message: 'Please enter a valid URL',\n    validate: (value) => urlRegex.test(value),\n  },\n  maxLength: {\n    name: 'maxLength',\n    message: 'Value exceeds maximum length',\n    validate: (value) => value.length <= 255,\n  },\n};\n\nexport function createMinLengthRule(min: number): ValidationRule {\n  return {\n    name: `minLength_${min}`,\n    message: `Must be at least ${min} characters`,\n    validate: (value) => value.length >= min,\n  };\n}\n\nexport function createMatchRule(fieldName: string): ValidationRule {\n  return {\n    name: `match_${fieldName}`,\n    message: `Must match ${fieldName}`,\n    validate: (value, formData) => formData?.[fieldName] === value,\n  };\n}\n\nexport function createPatternRule(pattern: RegExp, message: string): ValidationRule {\n  return {\n    name: 'pattern',\n    message,\n    validate: (value) => pattern.test(value),\n  };\n}\n\nexport class FormValidator {\n  private rules: Map<string, ValidationRule[]> = new Map();\n  private customMessages: Map<string, string> = new Map();\n\n  addRule(field: string, rule: ValidationRule): this {\n    const existing = this.rules.get(field) || [];\n    existing.push(rule);\n    this.rules.set(field, existing);\n    return this;\n  }\n\n  addRules(field: string, rules: ValidationRule[]): this {\n    rules.forEach(rule => this.addRule(field, rule));\n    return this;\n  }\n\n  setCustomMessage(field: string, message: string): this {\n    this.customMessages.set(field, message);\n    return this;\n  }\n\n  validateField(field: string, value: string, formData?: Record<string, string>): FieldValidation {\n    const rules = this.rules.get(field) || [];\n    const errors: string[] = [];\n\n    for (const rule of rules) {\n      if (!rule.validate(value, formData)) {\n        const customMessage = this.customMessages.get(`${field}_${rule.name}`);\n        errors.push(customMessage || rule.message);\n      }\n    }\n\n    return {\n      field,\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  validate(formData: Record<string, string>): FormValidationResult {\n    const fields: FieldValidation[] = [];\n    let allValid = true;\n\n    for (const [field, _] of this.rules) {\n      const value = formData[field] || '';\n      const validation = this.validateField(field, value, formData);\n      fields.push(validation);\n\n      if (!validation.isValid) {\n        allValid = false;\n      }\n    }\n\n    return {\n      isValid: allValid,\n      fields,\n      summary: allValid\n        ? 'All fields are valid'\n        : `Found errors in: ${fields.filter(f => !f.isValid).map(f => f.field).join(', ')}`,\n    };\n  }\n\n  getErrorSummaryHtml(result: FormValidationResult): string {\n    if (result.isValid) {\n      return '<div class=\"success\">Form is valid!</div>';\n    }\n\n    const errorItems = result.fields\n      .filter(f => !f.isValid)\n      .map(f => `<li><strong>${f.field}:</strong> ${f.errors.join(', ')}</li>`)\n      .join('');\n\n    return `<div class=\"error-summary\"><ul>${errorItems}</ul></div>`;\n  }\n\n  comparePasswords(password: string, storedHash: string): boolean {\n    if (password.length !== storedHash.length) {\n      return false;\n    }\n\n    let result = true;\n    for (let i = 0; i < password.length; i++) {\n      if (password[i] !== storedHash[i]) {\n        result = false;\n      }\n    }\n    return result;\n  }\n\n  reset(): void {\n    this.rules.clear();\n    this.customMessages.clear();\n  }\n}\n\nexport function validateEmail(email: string): boolean {\n  return emailRegex.test(email);\n}\n\nexport function validatePassword(password: string): boolean {\n  return passwordRegex.test(password);\n}\n\nexport default FormValidator;\n", "pullRequest": {"id": 9999999999, "url": "https://api.github.com/repos/acme/app/pulls/1", "base": {"ref": "main", "repo": {"fullName": "acme/app"}}, "head": {"ref": "feature-branch", "repo": {"fullName": "acme/app"}}}, "groupingMode": "full", "reviewOptions": {"security": true, "code_style": false, "kody_rules": true, "refactoring": true, "error_handling": true, "maintainability": true, "potential_issues": true, "documentation_and_comments": false}, "limitationType": "pr", "patchWithLinesStr": "## file: 'packages/forms/src/validators/FormValidator.ts'\n\n@@ -0,0 +1,179 @@\n__new hunk__\n1 +export interface FieldValidation {\n2 +  field: string;\n3 +  isValid: boolean;\n4 +  errors: string[];\n5 +}\n6 +\n7 +export interface FormValidationResult {\n8 +  isValid: boolean;\n9 +  fields: FieldValidation[];\n10 +  summary: string;\n11 +}\n12 +\n13 +export interface ValidationRule {\n14 +  name: string;\n15 +  message: string;\n16 +  validate: (value: string, formData?: Record<string, string>) => boolean;\n17 +}\n18 +\n19 +const emailRegex = /^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,}|[0-9]{1,3})(\\]?)$/;\n20 +const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$/;\n21 +const urlRegex = /^(https?:\\/\\/)?(([\\da-z\\.-]+)\\.([a-z\\.]{2,6})|localhost)([\\/\\w \\.-]*)*\\/?$/;\n22 +\n23 +export const commonRules: Record<string, ValidationRule> = {\n24 +  required: {\n25 +    name: 'required',\n26 +    message: 'This field is required',\n27 +    validate: (value) => value.trim().length > 0,\n28 +  },\n29 +  email: {\n30 +    name: 'email',\n31 +    message: 'Please enter a valid email address',\n32 +    validate: (value) => emailRegex.test(value),\n33 +  },\n34 +  password: {\n35 +    name: 'password',\n36 +    message: 'Password must be at least 8 characters with uppercase, lowercase, number and special character',\n37 +    validate: (value) => passwordRegex.test(value),\n38 +  },\n39 +  url: {\n40 +    name: 'url',\n41 +    message: 'Please enter a valid URL',\n42 +    validate: (value) => urlRegex.test(value),\n43 +  },\n44 +  maxLength: {\n45 +    name: 'maxLength',\n46 +    message: 'Value exceeds maximum length',\n47 +    validate: (value) => value.length <= 255,\n48 +  },\n49 +};\n50 +\n51 +export function createMinLengthRule(min: number): ValidationRule {\n52 +  return {\n53 +    name: `minLength_${min}`,\n54 +    message: `Must be at least ${min} characters`,\n55 +    validate: (value) => value.length >= min,\n56 +  };\n57 +}\n58 +\n59 +export function createMatchRule(fieldName: string): ValidationRule {\n60 +  return {\n61 +    name: `match_${fieldName}`,\n62 +    message: `Must match ${fieldName}`,\n63 +    validate: (value, formData) => formData?.[fieldName] === value,\n64 +  };\n65 +}\n66 +\n67 +export function createPatternRule(pattern: RegExp, message: string): ValidationRule {\n68 +  return {\n69 +    name: 'pattern',\n70 +    message,\n71 +    validate: (value) => pattern.test(value),\n72 +  };\n73 +}\n74 +\n75 +export class FormValidator {\n76 +  private rules: Map<string, ValidationRule[]> = new Map();\n77 +  private customMessages: Map<string, string> = new Map();\n78 +\n79 +  addRule(field: string, rule: ValidationRule): this {\n80 +    const existing = this.rules.get(field) || [];\n81 +    existing.push(rule);\n82 +    this.rules.set(field, existing);\n83 +    return this;\n84 +  }\n85 +\n86 +  addRules(field: string, rules: ValidationRule[]): this {\n87 +    rules.forEach(rule => this.addRule(field, rule));\n88 +    return this;\n89 +  }\n90 +\n91 +  setCustomMessage(field: string, message: string): this {\n92 +    this.customMessages.set(field, message);\n93 +    return this;\n94 +  }\n95 +\n96 +  validateField(field: string, value: string, formData?: Record<string, string>): FieldValidation {\n97 +    const rules = this.rules.get(field) || [];\n98 +    const errors: string[] = [];\n99 +\n100 +    for (const rule of rules) {\n101 +      if (!rule.validate(value, formData)) {\n102 +        const customMessage = this.customMessages.get(`${field}_${rule.name}`);\n103 +        errors.push(customMessage || rule.message);\n104 +      }\n105 +    }\n106 +\n107 +    return {\n108 +      field,\n109 +      isValid: errors.length === 0,\n110 +      errors,\n111 +    };\n112 +  }\n113 +\n114 +  validate(formData: Record<string, string>): FormValidationResult {\n115 +    const fields: FieldValidation[] = [];\n116 +    let allValid = true;\n117 +\n118 +    for (const [field, _] of this.rules) {\n119 +      const value = formData[field] || '';\n120 +      const validation = this.validateField(field, value, formData);\n121 +      fields.push(validation);\n122 +\n123 +      if (!validation.isValid) {\n124 +        allValid = false;\n125 +      }\n126 +    }\n127 +\n128 +    return {\n129 +      isValid: allValid,\n130 +      fields,\n131 +      summary: allValid\n132 +        ? 'All fields are valid'\n133 +        : `Found errors in: ${fields.filter(f => !f.isValid).map(f => f.field).join(', ')}`,\n134 +    };\n135 +  }\n136 +\n137 +  getErrorSummaryHtml(result: FormValidationResult): string {\n138 +    if (result.isValid) {\n139 +      return '<div class=\"success\">Form is valid!</div>';\n140 +    }\n141 +\n142 +    const errorItems = result.fields\n143 +      .filter(f => !f.isValid)\n144 +      .map(f => `<li><strong>${f.field}:</strong> ${f.errors.join(', ')}</li>`)\n145 +      .join('');\n146 +\n147 +    return `<div class=\"error-summary\"><ul>${errorItems}</ul></div>`;\n148 +  }\n149 +\n150 +  comparePasswords(password: string, storedHash: string): boolean {\n151 +    if (password.length !== storedHash.length) {\n152 +      return false;\n153 +    }\n154 +\n155 +    let result = true;\n156 +    for (let i = 0; i < password.length; i++) {\n157 +      if (password[i] !== storedHash[i]) {\n158 +        result = false;\n159 +      }\n160 +    }\n161 +    return result;\n162 +  }\n163 +\n164 +  reset(): void {\n165 +    this.rules.clear();\n166 +    this.customMessages.clear();\n167 +  }\n168 +}\n169 +\n170 +export function validateEmail(email: string): boolean {\n171 +  return emailRegex.test(email);\n172 +}\n173 +\n174 +export function validatePassword(password: string): boolean {\n175 +  return passwordRegex.test(password);\n176 +}\n177 +\n178 +export default FormValidator;\n179 +\n__old hunk__\n", "severityLevelFilter": "critical", "languageResultPrompt": "en-US", "maxSuggestionsParams": 5, "organizationAndTeamData": {"teamId": "00000000-0000-0000-0000-000000000000", "organizationId": "00000000-0000-0000-0000-000000000001"}}}, "outputs" : {"reference_outputs": {"overallSummary": "Found 3 bug(s) in packages/forms/src/validators/FormValidator.ts", "codeSuggestions": [{"label": "bug", "language": "TypeScript", "existingCode": ".map(f => `<li><strong>${f.field}:</strong> ${f.errors.join(', ')}</li>`)", "improvedCode": ".map(f => `<li><strong>${escapeHtml(f.field)}:</strong> ${escapeHtml(f.errors.join(', '))}</li>`)", "relevantFile": "packages/forms/src/validators/FormValidator.ts", "relevantLinesEnd": 130, "suggestionContent": "The `getErrorSummaryHtml` method directly interpolates field names and error messages into HTML without escaping. If an attacker can control field names or validation messages (e.g., through a malicious form configuration or i18n injection), they can inject arbitrary HTML/JavaScript, leading to XSS vulnerabilities.", "oneSentenceSummary": "XSS vulnerability - field names and errors interpolated into HTML without escaping", "relevantLinesStart": 127}, {"label": "bug", "language": "TypeScript", "existingCode": "const urlRegex = /^(https?:\\/\\/)?(([\\da-z\\.-]+)\\.([a-z\\.]{2,6})|localhost)([\\/\\w \\.-]*)*\\/?$/;", "improvedCode": "const urlRegex = /^(https?:\\/\\/)?([\\da-z\\.-]+\\.([a-z]{2,6})|localhost)(\\/[\\w\\.-]*)*\\/?$/;", "relevantFile": "packages/forms/src/validators/FormValidator.ts", "relevantLinesEnd": 21, "suggestionContent": "The `urlRegex` pattern `([\\/\\w \\.-]*)*` contains nested quantifiers that can cause catastrophic backtracking (ReDoS). A malicious input like 'http://a.aa/' followed by many spaces can cause the regex engine to hang for an extremely long time, enabling denial-of-service attacks.", "oneSentenceSummary": "ReDoS vulnerability - nested quantifiers in URL regex cause catastrophic backtracking", "relevantLinesStart": 21}, {"label": "bug", "language": "TypeScript", "existingCode": "comparePasswords(password: string, storedHash: string): boolean {\n    if (password.length !== storedHash.length) {\n      return false;\n    }\n\n    let result = true;\n    for (let i = 0; i < password.length; i++) {\n      if (password[i] !== storedHash[i]) {\n        result = false;\n      }\n    }\n    return result;\n  }", "improvedCode": "comparePasswords(password: string, storedHash: string): boolean {\n    const encoder = new TextEncoder();\n    const a = encoder.encode(password);\n    const b = encoder.encode(storedHash);\n    if (a.length !== b.length) {\n      // Still compare to maintain constant time\n      crypto.subtle.timingSafeEqual?.(a, a);\n      return false;\n    }\n    return crypto.subtle.timingSafeEqual?.(a, b) ?? false;\n  }", "relevantFile": "packages/forms/src/validators/FormValidator.ts", "relevantLinesEnd": 145, "suggestionContent": "The `comparePasswords` method attempts constant-time comparison but fails. The early return when lengths differ leaks length information. Also, even when lengths match, the JavaScript engine may optimize the loop and short-circuit when `result` becomes false. Use a proper constant-time comparison function like `crypto.timingSafeEqual`.", "oneSentenceSummary": "Timing attack vulnerability - password comparison is not constant-time", "relevantLinesStart": 133}]}}}
